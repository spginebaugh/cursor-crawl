{
  "esbuild.js": [
    {
      "name": "esbuild",
      "type": "variable",
      "filePath": "esbuild.js",
      "location": {
        "line": 1,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "esbuild = require(\"esbuild\")",
      "dependents": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 27,
          "contextSnippet": "};\n\nasync function main() {\n\tconst ctx = await esbuild.context({\n\t\tentryPoints: [\n\t\t\t'src/extension.ts'\n\t\t],"
        }
      ],
      "depends_on": []
    },
    {
      "name": "production",
      "type": "variable",
      "filePath": "esbuild.js",
      "location": {
        "line": 3,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "production = process.argv.includes('--production')",
      "dependents": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 33,
          "contextSnippet": "\t\t],\n\t\tbundle: true,\n\t\tformat: 'cjs',\n\t\tminify: production,\n\t\tsourcemap: !production,\n\t\tsourcesContent: false,\n\t\tplatform: 'node',"
        }
      ],
      "depends_on": []
    },
    {
      "name": "watch",
      "type": "variable",
      "filePath": "esbuild.js",
      "location": {
        "line": 4,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "watch = process.argv.includes('--watch')",
      "dependents": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 45,
          "contextSnippet": "\t\t\tesbuildProblemMatcherPlugin,\n\t\t],\n\t});\n\tif (watch) {\n\t\tawait ctx.watch();\n\t} else {\n\t\tawait ctx.rebuild();"
        }
      ],
      "depends_on": []
    },
    {
      "name": "esbuildProblemMatcherPlugin",
      "type": "variable",
      "filePath": "esbuild.js",
      "location": {
        "line": 9,
        "character": 6
      },
      "docstring": "/**\n * @type {import('esbuild').Plugin}\n */",
      "snippet": "esbuildProblemMatcherPlugin = {\n\tname: 'esbuild-problem-matcher',\n\n\tsetup(build) {\n\t\tbuild.onStart(() => {\n\t\t\tconsole.log('[watch] build started');\n\t\t});\n\t\tbuild.onEnd((result) => {\n\t\t\tresult.errors.forEach(({ text, location }) => {\n\t\t\t\tconsole.error(`âœ˜ [ERROR] ${text}`);\n\t\t\t\tconsole.error(`    ${location.file}:${location.line}:${location.column}:`);\n\t\t\t});\n\t\t\tconsole.log('[watch] build finished');\n\t\t});\n\t},\n}",
      "dependents": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 42,
          "contextSnippet": "\t\tlogLevel: 'silent',\n\t\tplugins: [\n\t\t\t/* add to the end of plugins array */\n\t\t\tesbuildProblemMatcherPlugin,\n\t\t],\n\t});\n\tif (watch) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "main",
      "type": "function",
      "filePath": "esbuild.js",
      "location": {
        "line": 26,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "async function main() {\n\tconst ctx = await esbuild.context({\n\t\tentryPoints: [\n\t\t\t'src/extension.ts'\n\t\t],\n\t\tbundle: true,\n\t\tformat: 'cjs',\n\t\tminify: production,\n\t\tsourcemap: !production,\n\t\tsourcesContent: false,\n\t\tplatform: 'node',\n\t\toutfile: 'dist/extension.js',\n\t\texternal: ['vscode'],\n\t\tlogLevel: 'silent',\n\t\tplugins: [\n\t\t\t/* add to the end of plugins array */\n\t\t\tesbuildProblemMatcherPlugin,\n\t\t],\n\t});\n\tif (watch) {\n\t\tawait ctx.watch();\n\t} else {\n\t\tawait ctx.rebuild();\n\t\tawait ctx.dispose();\n\t}\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "esbuild.js",
          "line": 53,
          "contextSnippet": "\t}\n}\n\nmain().catch(e => {\n\tconsole.error(e);\n\tprocess.exit(1);\n});"
        }
      ],
      "depends_on": [
        {
          "name": "esbuild",
          "filePath": "esbuild.js",
          "line": 27
        },
        {
          "name": "production",
          "filePath": "esbuild.js",
          "line": 33
        },
        {
          "name": "esbuildProblemMatcherPlugin",
          "filePath": "esbuild.js",
          "line": 42
        },
        {
          "name": "watch",
          "filePath": "esbuild.js",
          "line": 45
        },
        {
          "name": "ctx",
          "filePath": "esbuild.js",
          "line": 46
        }
      ]
    },
    {
      "name": "ctx",
      "type": "variable",
      "filePath": "esbuild.js",
      "location": {
        "line": 27,
        "character": 7
      },
      "docstring": "/** */",
      "snippet": "ctx = await esbuild.context({\n\t\tentryPoints: [\n\t\t\t'src/extension.ts'\n\t\t],\n\t\tbundle: true,\n\t\tformat: 'cjs',\n\t\tminify: production,\n\t\tsourcemap: !production,\n\t\tsourcesContent: false,\n\t\tplatform: 'node',\n\t\toutfile: 'dist/extension.js',\n\t\texternal: ['vscode'],\n\t\tlogLevel: 'silent',\n\t\tplugins: [\n\t\t\t/* add to the end of plugins array */\n\t\t\tesbuildProblemMatcherPlugin,\n\t\t],\n\t})",
      "dependents": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 46,
          "contextSnippet": "\t\t],\n\t});\n\tif (watch) {\n\t\tawait ctx.watch();\n\t} else {\n\t\tawait ctx.rebuild();\n\t\tawait ctx.dispose();"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "esbuild.js",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "main",
          "filePath": "esbuild.js",
          "line": 53
        }
      ]
    }
  ],
  "src/commands/analyze-command.ts": [
    {
      "name": "registerAnalyzeCommand",
      "type": "variable",
      "filePath": "src/commands/analyze-command.ts",
      "location": {
        "line": 10,
        "character": 13
      },
      "docstring": "/**\n * Registers the analyze command that builds the symbol index and optionally generates docstrings\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerAnalyzeCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.analyze', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }\n\n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        // Ask if docstrings should be generated\n        const generateDocstrings = await vscode.window.showQuickPick(\n            [\n                { label: 'Yes', description: 'Build symbol index and generate docstrings' },\n                { label: 'No', description: 'Build symbol index only (no AI-generated docstrings)' }\n            ],\n            { placeHolder: 'Would you like to generate docstrings? This requires an OpenAI API key.' }\n        );\n        \n        if (!generateDocstrings) {\n            return; // User canceled\n        }\n        \n        // First, build the symbol index only\n        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false, // Never generate docstrings here\n                    showMessages: generateDocstrings.label === 'No', // Only show messages if not generating docstrings later\n                    progress\n                });\n            }\n        );\n        \n        // If user wants docstrings, trigger the regular docstring generation command\n        if (generateDocstrings.label === 'Yes') {\n            // Execute the dedicated Generate Docstring command (which has a cancel button)\n            await vscode.commands.executeCommand('cursorcrawl.generateDocstringIndex');\n        }\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolders",
          "filePath": "src/commands/analyze-command.ts",
          "line": 13
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/commands/analyze-command.ts",
          "line": 29
        },
        {
          "name": "rootPath",
          "filePath": "src/commands/analyze-command.ts",
          "line": 37
        },
        {
          "name": "command",
          "filePath": "src/commands/analyze-command.ts",
          "line": 52
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/analyze-command.ts",
      "location": {
        "line": 11,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.analyze', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }\n\n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        // Ask if docstrings should be generated\n        const generateDocstrings = await vscode.window.showQuickPick(\n            [\n                { label: 'Yes', description: 'Build symbol index and generate docstrings' },\n                { label: 'No', description: 'Build symbol index only (no AI-generated docstrings)' }\n            ],\n            { placeHolder: 'Would you like to generate docstrings? This requires an OpenAI API key.' }\n        );\n        \n        if (!generateDocstrings) {\n            return; // User canceled\n        }\n        \n        // First, build the symbol index only\n        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false, // Never generate docstrings here\n                    showMessages: generateDocstrings.label === 'No', // Only show messages if not generating docstrings later\n                    progress\n                });\n            }\n        );\n        \n        // If user wants docstrings, trigger the regular docstring generation command\n        if (generateDocstrings.label === 'Yes') {\n            // Execute the dedicated Generate Docstring command (which has a cancel button)\n            await vscode.commands.executeCommand('cursorcrawl.generateDocstringIndex');\n        }\n    })",
      "dependents": [
        {
          "name": "registerAnalyzeCommand",
          "filePath": "src/commands/analyze-command.ts",
          "line": 52,
          "contextSnippet": "        }\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolders",
      "type": "variable",
      "filePath": "src/commands/analyze-command.ts",
      "location": {
        "line": 12,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolders = vscode.workspace.workspaceFolders",
      "dependents": [
        {
          "name": "registerAnalyzeCommand",
          "filePath": "src/commands/analyze-command.ts",
          "line": 13,
          "contextSnippet": "export const registerAnalyzeCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.analyze', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/commands/analyze-command.ts",
      "location": {
        "line": 18,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "rootPath = workspaceFolders[0].uri.fsPath",
      "dependents": [
        {
          "name": "registerAnalyzeCommand",
          "filePath": "src/commands/analyze-command.ts",
          "line": 37,
          "contextSnippet": "        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false, // Never generate docstrings here\n                    showMessages: generateDocstrings.label === 'No', // Only show messages if not generating docstrings later\n                    progress"
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateDocstrings",
      "type": "variable",
      "filePath": "src/commands/analyze-command.ts",
      "location": {
        "line": 21,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "generateDocstrings = await vscode.window.showQuickPick(\n            [\n                { label: 'Yes', description: 'Build symbol index and generate docstrings' },\n                { label: 'No', description: 'Build symbol index only (no AI-generated docstrings)' }\n            ],\n            { placeHolder: 'Would you like to generate docstrings? This requires an OpenAI API key.' }\n        )",
      "dependents": [
        {
          "name": "registerAnalyzeCommand",
          "filePath": "src/commands/analyze-command.ts",
          "line": 29,
          "contextSnippet": "            { placeHolder: 'Would you like to generate docstrings? This requires an OpenAI API key.' }\n        );\n        \n        if (!generateDocstrings) {\n            return; // User canceled\n        }\n        "
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/analyze-duplicate-logic-command.ts": [
    {
      "name": "registerAnalyzeDuplicateLogicCommand",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 13,
        "character": 13
      },
      "docstring": "/**\n * Registers the analyze duplicate logic command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerAnalyzeDuplicateLogicCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.analyzeDuplicateLogic', async () => {\n        // Initialize the workspace with required services\n        const result = await ProjectService.initializeWorkspace({\n            checkOpenAi: true,\n            requireOpenAi: true,\n            validateSymbolIndex: true\n        });\n        \n        if (!result.rootPath) {\n            return;\n        }\n        \n        const rootPath = result.rootPath;\n        \n        await ProgressService.runWithProgress(\n            'Analyzing Codebase for Duplicate Logic',\n            async (progress) => {\n                try {\n                    // Step 1: Verify codebase context exists\n                    progress.report({ message: 'Checking codebase context...' });\n                    \n                    // Check if codebase context file exists\n                    try {\n                        await DuplicateLogicAnalyzerService.readCodebaseContext(rootPath);\n                    } catch (error) {\n                        // If not, prompt to generate it\n                        const generateResponse = await vscode.window.showErrorMessage(\n                            'Codebase context not found. Would you like to generate it first?',\n                            'Yes', 'No'\n                        );\n                        \n                        if (generateResponse === 'Yes') {\n                            // Generate codebase context first\n                            await vscode.commands.executeCommand('cursorcrawl.generateCodebaseContext');\n                        } else {\n                            throw new Error('Codebase context is required for analysis');\n                        }\n                    }\n                    \n                    // Step 2: Analyze codebase for duplicate logic in chunks\n                    progress.report({ message: 'Starting analysis...' });\n                    \n                    // Analyze with progress reports\n                    const filePath = await DuplicateLogicAnalyzerService.analyzeDuplicateLogic(\n                        rootPath,\n                        (progressMessage) => {\n                            progress.report({ message: progressMessage });\n                        }\n                    );\n                    \n                    // Step 3: Show results\n                    progress.report({ message: 'Analysis complete.' });\n                    \n                    // Find all the type-specific JSON files\n                    const cursorTestDir = path.join(rootPath, '.cursortest');\n                    const typeFiles = (await fs.readdir(cursorTestDir))\n                        .filter(file => file.startsWith('duplicate-analysis-') && file.endsWith('.json'))\n                        .map(file => path.join(cursorTestDir, file));\n                    \n                    // Create a summary message\n                    let summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`;\n                    summaryMessage += `Combined results: ${filePath}\\n`;\n                    \n                    if (typeFiles.length > 0) {\n                        summaryMessage += `\\nType-specific results:\\n`;\n                        for (const typeFile of typeFiles) {\n                            const typeName = path.basename(typeFile).replace('duplicate-analysis-', '').replace('.json', '');\n                            summaryMessage += `- ${typeName}: ${typeFile}\\n`;\n                        }\n                        \n                        // Add instructions for viewing the files\n                        summaryMessage += `\\nYou can open these files from the File Explorer or use the \"Open Type-Specific Results\" option.`;\n                    }\n                    \n                    // Show success message with file locations\n                    const openTypeSpecific = 'Open Type-Specific Results';\n                    const userChoice = await vscode.window.showInformationMessage(\n                        summaryMessage,\n                        { modal: false },\n                        openTypeSpecific\n                    );\n                    \n                    // Open the combined JSON file first\n                    const mainFileUri = vscode.Uri.file(filePath);\n                    await vscode.window.showTextDocument(mainFileUri);\n                    \n                    // If user wants to open type-specific files\n                    if (userChoice === openTypeSpecific && typeFiles.length > 0) {\n                        // Create a quick pick to select which type file to open\n                        const items = typeFiles.map(file => {\n                            const typeName = path.basename(file).replace('duplicate-analysis-', '').replace('.json', '');\n                            return {\n                                label: typeName,\n                                description: file,\n                                file\n                            };\n                        });\n                        \n                        const selectedItem = await vscode.window.showQuickPick(items, {\n                            placeHolder: 'Select a type-specific results file to open'\n                        });\n                        \n                        if (selectedItem) {\n                            const fileUri = vscode.Uri.file(selectedItem.file);\n                            await vscode.window.showTextDocument(fileUri);\n                        }\n                    }\n                    \n                } catch (error) {\n                    showErrorMessage('Failed to analyze codebase for duplicate logic', error);\n                    throw error;\n                }\n            }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "result",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 22
        },
        {
          "name": "rootPath",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 37
        },
        {
          "name": "generateResponse",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 45
        },
        {
          "name": "cursorTestDir",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 69
        },
        {
          "name": "summaryMessage",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 75
        },
        {
          "name": "filePath",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 75
        },
        {
          "name": "typeFiles",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 77
        },
        {
          "name": "typeName",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 81
        },
        {
          "name": "openTypeSpecific",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 93
        },
        {
          "name": "mainFileUri",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 98
        },
        {
          "name": "userChoice",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 101
        },
        {
          "name": "items",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 112
        },
        {
          "name": "selectedItem",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 116
        },
        {
          "name": "fileUri",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 118
        },
        {
          "name": "command",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 130
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 14,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.analyzeDuplicateLogic', async () => {\n        // Initialize the workspace with required services\n        const result = await ProjectService.initializeWorkspace({\n            checkOpenAi: true,\n            requireOpenAi: true,\n            validateSymbolIndex: true\n        });\n        \n        if (!result.rootPath) {\n            return;\n        }\n        \n        const rootPath = result.rootPath;\n        \n        await ProgressService.runWithProgress(\n            'Analyzing Codebase for Duplicate Logic',\n            async (progress) => {\n                try {\n                    // Step 1: Verify codebase context exists\n                    progress.report({ message: 'Checking codebase context...' });\n                    \n                    // Check if codebase context file exists\n                    try {\n                        await DuplicateLogicAnalyzerService.readCodebaseContext(rootPath);\n                    } catch (error) {\n                        // If not, prompt to generate it\n                        const generateResponse = await vscode.window.showErrorMessage(\n                            'Codebase context not found. Would you like to generate it first?',\n                            'Yes', 'No'\n                        );\n                        \n                        if (generateResponse === 'Yes') {\n                            // Generate codebase context first\n                            await vscode.commands.executeCommand('cursorcrawl.generateCodebaseContext');\n                        } else {\n                            throw new Error('Codebase context is required for analysis');\n                        }\n                    }\n                    \n                    // Step 2: Analyze codebase for duplicate logic in chunks\n                    progress.report({ message: 'Starting analysis...' });\n                    \n                    // Analyze with progress reports\n                    const filePath = await DuplicateLogicAnalyzerService.analyzeDuplicateLogic(\n                        rootPath,\n                        (progressMessage) => {\n                            progress.report({ message: progressMessage });\n                        }\n                    );\n                    \n                    // Step 3: Show results\n                    progress.report({ message: 'Analysis complete.' });\n                    \n                    // Find all the type-specific JSON files\n                    const cursorTestDir = path.join(rootPath, '.cursortest');\n                    const typeFiles = (await fs.readdir(cursorTestDir))\n                        .filter(file => file.startsWith('duplicate-analysis-') && file.endsWith('.json'))\n                        .map(file => path.join(cursorTestDir, file));\n                    \n                    // Create a summary message\n                    let summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`;\n                    summaryMessage += `Combined results: ${filePath}\\n`;\n                    \n                    if (typeFiles.length > 0) {\n                        summaryMessage += `\\nType-specific results:\\n`;\n                        for (const typeFile of typeFiles) {\n                            const typeName = path.basename(typeFile).replace('duplicate-analysis-', '').replace('.json', '');\n                            summaryMessage += `- ${typeName}: ${typeFile}\\n`;\n                        }\n                        \n                        // Add instructions for viewing the files\n                        summaryMessage += `\\nYou can open these files from the File Explorer or use the \"Open Type-Specific Results\" option.`;\n                    }\n                    \n                    // Show success message with file locations\n                    const openTypeSpecific = 'Open Type-Specific Results';\n                    const userChoice = await vscode.window.showInformationMessage(\n                        summaryMessage,\n                        { modal: false },\n                        openTypeSpecific\n                    );\n                    \n                    // Open the combined JSON file first\n                    const mainFileUri = vscode.Uri.file(filePath);\n                    await vscode.window.showTextDocument(mainFileUri);\n                    \n                    // If user wants to open type-specific files\n                    if (userChoice === openTypeSpecific && typeFiles.length > 0) {\n                        // Create a quick pick to select which type file to open\n                        const items = typeFiles.map(file => {\n                            const typeName = path.basename(file).replace('duplicate-analysis-', '').replace('.json', '');\n                            return {\n                                label: typeName,\n                                description: file,\n                                file\n                            };\n                        });\n                        \n                        const selectedItem = await vscode.window.showQuickPick(items, {\n                            placeHolder: 'Select a type-specific results file to open'\n                        });\n                        \n                        if (selectedItem) {\n                            const fileUri = vscode.Uri.file(selectedItem.file);\n                            await vscode.window.showTextDocument(fileUri);\n                        }\n                    }\n                    \n                } catch (error) {\n                    showErrorMessage('Failed to analyze codebase for duplicate logic', error);\n                    throw error;\n                }\n            }\n        );\n    })",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 130,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 16,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "result = await ProjectService.initializeWorkspace({\n            checkOpenAi: true,\n            requireOpenAi: true,\n            validateSymbolIndex: true\n        })",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 22,
          "contextSnippet": "            validateSymbolIndex: true\n        });\n        \n        if (!result.rootPath) {\n            return;\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 26,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "rootPath = result.rootPath",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 37,
          "contextSnippet": "                    \n                    // Check if codebase context file exists\n                    try {\n                        await DuplicateLogicAnalyzerService.readCodebaseContext(rootPath);\n                    } catch (error) {\n                        // If not, prompt to generate it\n                        const generateResponse = await vscode.window.showErrorMessage("
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateResponse",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 40,
        "character": 30
      },
      "docstring": "/** */",
      "snippet": "generateResponse = await vscode.window.showErrorMessage(\n                            'Codebase context not found. Would you like to generate it first?',\n                            'Yes', 'No'\n                        )",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 45,
          "contextSnippet": "                            'Yes', 'No'\n                        );\n                        \n                        if (generateResponse === 'Yes') {\n                            // Generate codebase context first\n                            await vscode.commands.executeCommand('cursorcrawl.generateCodebaseContext');\n                        } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 57,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "filePath = await DuplicateLogicAnalyzerService.analyzeDuplicateLogic(\n                        rootPath,\n                        (progressMessage) => {\n                            progress.report({ message: progressMessage });\n                        }\n                    )",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 75,
          "contextSnippet": "                    \n                    // Create a summary message\n                    let summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`;\n                    summaryMessage += `Combined results: ${filePath}\\n`;\n                    \n                    if (typeFiles.length > 0) {\n                        summaryMessage += `\\nType-specific results:\\n`;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "cursorTestDir",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 68,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "cursorTestDir = path.join(rootPath, '.cursortest')",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 69,
          "contextSnippet": "                    \n                    // Find all the type-specific JSON files\n                    const cursorTestDir = path.join(rootPath, '.cursortest');\n                    const typeFiles = (await fs.readdir(cursorTestDir))\n                        .filter(file => file.startsWith('duplicate-analysis-') && file.endsWith('.json'))\n                        .map(file => path.join(cursorTestDir, file));\n                    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "typeFiles",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 69,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "typeFiles = (await fs.readdir(cursorTestDir))\n                        .filter(file => file.startsWith('duplicate-analysis-') && file.endsWith('.json'))\n                        .map(file => path.join(cursorTestDir, file))",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 77,
          "contextSnippet": "                    let summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`;\n                    summaryMessage += `Combined results: ${filePath}\\n`;\n                    \n                    if (typeFiles.length > 0) {\n                        summaryMessage += `\\nType-specific results:\\n`;\n                        for (const typeFile of typeFiles) {\n                            const typeName = path.basename(typeFile).replace('duplicate-analysis-', '').replace('.json', '');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "summaryMessage",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 74,
        "character": 24
      },
      "docstring": "/** */",
      "snippet": "summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 75,
          "contextSnippet": "                    \n                    // Create a summary message\n                    let summaryMessage = `Duplicate logic analysis completed successfully.\\n\\n`;\n                    summaryMessage += `Combined results: ${filePath}\\n`;\n                    \n                    if (typeFiles.length > 0) {\n                        summaryMessage += `\\nType-specific results:\\n`;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "typeName",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 80,
        "character": 34
      },
      "docstring": "/** */",
      "snippet": "typeName = path.basename(typeFile).replace('duplicate-analysis-', '').replace('.json', '')",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 81,
          "contextSnippet": "                        summaryMessage += `\\nType-specific results:\\n`;\n                        for (const typeFile of typeFiles) {\n                            const typeName = path.basename(typeFile).replace('duplicate-analysis-', '').replace('.json', '');\n                            summaryMessage += `- ${typeName}: ${typeFile}\\n`;\n                        }\n                        \n                        // Add instructions for viewing the files"
        }
      ],
      "depends_on": []
    },
    {
      "name": "openTypeSpecific",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 89,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "openTypeSpecific = 'Open Type-Specific Results'",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 93,
          "contextSnippet": "                    const userChoice = await vscode.window.showInformationMessage(\n                        summaryMessage,\n                        { modal: false },\n                        openTypeSpecific\n                    );\n                    \n                    // Open the combined JSON file first"
        }
      ],
      "depends_on": []
    },
    {
      "name": "userChoice",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 90,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "userChoice = await vscode.window.showInformationMessage(\n                        summaryMessage,\n                        { modal: false },\n                        openTypeSpecific\n                    )",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 101,
          "contextSnippet": "                    await vscode.window.showTextDocument(mainFileUri);\n                    \n                    // If user wants to open type-specific files\n                    if (userChoice === openTypeSpecific && typeFiles.length > 0) {\n                        // Create a quick pick to select which type file to open\n                        const items = typeFiles.map(file => {\n                            const typeName = path.basename(file).replace('duplicate-analysis-', '').replace('.json', '');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mainFileUri",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 97,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "mainFileUri = vscode.Uri.file(filePath)",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 98,
          "contextSnippet": "                    \n                    // Open the combined JSON file first\n                    const mainFileUri = vscode.Uri.file(filePath);\n                    await vscode.window.showTextDocument(mainFileUri);\n                    \n                    // If user wants to open type-specific files\n                    if (userChoice === openTypeSpecific && typeFiles.length > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "items",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 103,
        "character": 30
      },
      "docstring": "/** */",
      "snippet": "items = typeFiles.map(file => {\n                            const typeName = path.basename(file).replace('duplicate-analysis-', '').replace('.json', '');\n                            return {\n                                label: typeName,\n                                description: file,\n                                file\n                            };\n                        })",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 112,
          "contextSnippet": "                            };\n                        });\n                        \n                        const selectedItem = await vscode.window.showQuickPick(items, {\n                            placeHolder: 'Select a type-specific results file to open'\n                        });\n                        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "typeName",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 104,
        "character": 34
      },
      "docstring": "/** */",
      "snippet": "typeName = path.basename(file).replace('duplicate-analysis-', '').replace('.json', '')",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "selectedItem",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 112,
        "character": 30
      },
      "docstring": "/** */",
      "snippet": "selectedItem = await vscode.window.showQuickPick(items, {\n                            placeHolder: 'Select a type-specific results file to open'\n                        })",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 116,
          "contextSnippet": "                            placeHolder: 'Select a type-specific results file to open'\n                        });\n                        \n                        if (selectedItem) {\n                            const fileUri = vscode.Uri.file(selectedItem.file);\n                            await vscode.window.showTextDocument(fileUri);\n                        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileUri",
      "type": "variable",
      "filePath": "src/commands/analyze-duplicate-logic-command.ts",
      "location": {
        "line": 117,
        "character": 34
      },
      "docstring": "/** */",
      "snippet": "fileUri = vscode.Uri.file(selectedItem.file)",
      "dependents": [
        {
          "name": "registerAnalyzeDuplicateLogicCommand",
          "filePath": "src/commands/analyze-duplicate-logic-command.ts",
          "line": 118,
          "contextSnippet": "                        \n                        if (selectedItem) {\n                            const fileUri = vscode.Uri.file(selectedItem.file);\n                            await vscode.window.showTextDocument(fileUri);\n                        }\n                    }\n                    "
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/build-symbol-index-command.ts": [
    {
      "name": "registerBuildSymbolIndexCommand",
      "type": "variable",
      "filePath": "src/commands/build-symbol-index-command.ts",
      "location": {
        "line": 10,
        "character": 13
      },
      "docstring": "/**\n * Registers the build symbol index command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerBuildSymbolIndexCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.buildSymbolIndex', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false,\n                    showMessages: true,\n                    progress\n                });\n            }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolders",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 13
        },
        {
          "name": "rootPath",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 23
        },
        {
          "name": "command",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 32
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/build-symbol-index-command.ts",
      "location": {
        "line": 11,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.buildSymbolIndex', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false,\n                    showMessages: true,\n                    progress\n                });\n            }\n        );\n    })",
      "dependents": [
        {
          "name": "registerBuildSymbolIndexCommand",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 32,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolders",
      "type": "variable",
      "filePath": "src/commands/build-symbol-index-command.ts",
      "location": {
        "line": 12,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolders = vscode.workspace.workspaceFolders",
      "dependents": [
        {
          "name": "registerBuildSymbolIndexCommand",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 13,
          "contextSnippet": "export const registerBuildSymbolIndexCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.buildSymbolIndex', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/commands/build-symbol-index-command.ts",
      "location": {
        "line": 18,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "rootPath = workspaceFolders[0].uri.fsPath",
      "dependents": [
        {
          "name": "registerBuildSymbolIndexCommand",
          "filePath": "src/commands/build-symbol-index-command.ts",
          "line": 23,
          "contextSnippet": "        await ProgressService.runWithProgress(\n            'Building Symbol Index',\n            async (progress) => {\n                await ensureProjectAnalysis(rootPath, {\n                    generateDocstrings: false,\n                    showMessages: true,\n                    progress"
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/extract-context-command.ts": [
    {
      "name": "registerExtractContextCommand",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 12,
        "character": 13
      },
      "docstring": "/**\n * Registers the extract context command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerExtractContextCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.extractContext', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }\n\n        // Show input box for the prompt\n        const promptText = await vscode.window.showInputBox({\n            placeHolder: 'Enter your prompt with file references using @filename.ts syntax',\n            prompt: 'Files referenced with @ will be included as context',\n            ignoreFocusOut: true\n        });\n        \n        if (!promptText) {\n            return; // User cancelled\n        }\n        \n        try {\n            // Show progress indicator\n            await ProgressService.runWithProgress(\n                \"Extracting Context Information\",\n                async (progress) => {\n                    progress.report({ message: \"Processing prompt and extracting context...\" });\n                    \n                    // Execute the context extraction workflow\n                    const result = await executeContextExtraction(promptText, workspaceFolder);\n                    \n                    if (!result.success) {\n                        // Handle specific error case for missing symbol index\n                        if (result.message.includes('Symbol index not found')) {\n                            const response = await vscode.window.showErrorMessage(\n                                'Symbol index not found. Would you like to run analysis first?',\n                                'Yes', 'No'\n                            );\n                            \n                            if (response === 'Yes') {\n                                // Run analysis first\n                                await vscode.commands.executeCommand('cursorcrawl.analyze');\n                                \n                                // Try extraction again after analysis\n                                progress.report({ message: \"Re-attempting context extraction after analysis...\" });\n                                const retryResult = await executeContextExtraction(promptText, workspaceFolder);\n                                \n                                if (!retryResult.success) {\n                                    showErrorMessage(retryResult.message);\n                                    return;\n                                }\n                                \n                                // Update result with retry result if successful\n                                Object.assign(result, retryResult);\n                            } else {\n                                return;\n                            }\n                        } else {\n                            showErrorMessage(result.message);\n                            return;\n                        }\n                    }\n                    \n                    // Show success message\n                    showInformationMessage(result.message);\n                    \n                    // Open the relevant-info.json file in the editor\n                    if (result.relevantInfoPath) {\n                        const document = await vscode.workspace.openTextDocument(result.relevantInfoPath);\n                        await vscode.window.showTextDocument(document);\n                    }\n                }\n            );\n        } catch (error) {\n            showErrorMessage(`Error extracting context: ${error}`);\n        }\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 15
        },
        {
          "name": "promptText",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 27
        },
        {
          "name": "result",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 41
        },
        {
          "name": "response",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 49
        },
        {
          "name": "retryResult",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 57
        },
        {
          "name": "command",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 88
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 13,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.extractContext', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }\n\n        // Show input box for the prompt\n        const promptText = await vscode.window.showInputBox({\n            placeHolder: 'Enter your prompt with file references using @filename.ts syntax',\n            prompt: 'Files referenced with @ will be included as context',\n            ignoreFocusOut: true\n        });\n        \n        if (!promptText) {\n            return; // User cancelled\n        }\n        \n        try {\n            // Show progress indicator\n            await ProgressService.runWithProgress(\n                \"Extracting Context Information\",\n                async (progress) => {\n                    progress.report({ message: \"Processing prompt and extracting context...\" });\n                    \n                    // Execute the context extraction workflow\n                    const result = await executeContextExtraction(promptText, workspaceFolder);\n                    \n                    if (!result.success) {\n                        // Handle specific error case for missing symbol index\n                        if (result.message.includes('Symbol index not found')) {\n                            const response = await vscode.window.showErrorMessage(\n                                'Symbol index not found. Would you like to run analysis first?',\n                                'Yes', 'No'\n                            );\n                            \n                            if (response === 'Yes') {\n                                // Run analysis first\n                                await vscode.commands.executeCommand('cursorcrawl.analyze');\n                                \n                                // Try extraction again after analysis\n                                progress.report({ message: \"Re-attempting context extraction after analysis...\" });\n                                const retryResult = await executeContextExtraction(promptText, workspaceFolder);\n                                \n                                if (!retryResult.success) {\n                                    showErrorMessage(retryResult.message);\n                                    return;\n                                }\n                                \n                                // Update result with retry result if successful\n                                Object.assign(result, retryResult);\n                            } else {\n                                return;\n                            }\n                        } else {\n                            showErrorMessage(result.message);\n                            return;\n                        }\n                    }\n                    \n                    // Show success message\n                    showInformationMessage(result.message);\n                    \n                    // Open the relevant-info.json file in the editor\n                    if (result.relevantInfoPath) {\n                        const document = await vscode.workspace.openTextDocument(result.relevantInfoPath);\n                        await vscode.window.showTextDocument(document);\n                    }\n                }\n            );\n        } catch (error) {\n            showErrorMessage(`Error extracting context: ${error}`);\n        }\n    })",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 88,
          "contextSnippet": "        }\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 14,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 15,
          "contextSnippet": "export const registerExtractContextCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.extractContext', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder found. Please open a folder first.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "promptText",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 21,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "promptText = await vscode.window.showInputBox({\n            placeHolder: 'Enter your prompt with file references using @filename.ts syntax',\n            prompt: 'Files referenced with @ will be included as context',\n            ignoreFocusOut: true\n        })",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 27,
          "contextSnippet": "            ignoreFocusOut: true\n        });\n        \n        if (!promptText) {\n            return; // User cancelled\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 39,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "result = await executeContextExtraction(promptText, workspaceFolder)",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 41,
          "contextSnippet": "                    // Execute the context extraction workflow\n                    const result = await executeContextExtraction(promptText, workspaceFolder);\n                    \n                    if (!result.success) {\n                        // Handle specific error case for missing symbol index\n                        if (result.message.includes('Symbol index not found')) {\n                            const response = await vscode.window.showErrorMessage("
        }
      ],
      "depends_on": []
    },
    {
      "name": "response",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 44,
        "character": 34
      },
      "docstring": "/** */",
      "snippet": "response = await vscode.window.showErrorMessage(\n                                'Symbol index not found. Would you like to run analysis first?',\n                                'Yes', 'No'\n                            )",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 49,
          "contextSnippet": "                                'Yes', 'No'\n                            );\n                            \n                            if (response === 'Yes') {\n                                // Run analysis first\n                                await vscode.commands.executeCommand('cursorcrawl.analyze');\n                                "
        }
      ],
      "depends_on": []
    },
    {
      "name": "retryResult",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 55,
        "character": 38
      },
      "docstring": "/** */",
      "snippet": "retryResult = await executeContextExtraction(promptText, workspaceFolder)",
      "dependents": [
        {
          "name": "registerExtractContextCommand",
          "filePath": "src/commands/extract-context-command.ts",
          "line": 57,
          "contextSnippet": "                                progress.report({ message: \"Re-attempting context extraction after analysis...\" });\n                                const retryResult = await executeContextExtraction(promptText, workspaceFolder);\n                                \n                                if (!retryResult.success) {\n                                    showErrorMessage(retryResult.message);\n                                    return;\n                                }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "document",
      "type": "variable",
      "filePath": "src/commands/extract-context-command.ts",
      "location": {
        "line": 78,
        "character": 30
      },
      "docstring": "/** */",
      "snippet": "document = await vscode.workspace.openTextDocument(result.relevantInfoPath)",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/commands/generate-codebase-context-command.ts": [
    {
      "name": "registerGenerateCodebaseContextCommand",
      "type": "variable",
      "filePath": "src/commands/generate-codebase-context-command.ts",
      "location": {
        "line": 10,
        "character": 13
      },
      "docstring": "/**\n * Registers the generate codebase context command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerGenerateCodebaseContextCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateCodebaseContext', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        await ProgressService.runWithProgress(\n            'Generating Codebase Context',\n            async (progress) => {\n                try {\n                    progress.report({ message: 'Reading symbol index...' });\n                    \n                    progress.report({ message: 'Generating codebase context...' });\n                    const filePath = await CodebaseContextService.generateAndWriteCodebaseContext(rootPath);\n                    \n                    showInformationMessage(`Codebase context generated successfully at ${filePath}`);\n                } catch (error) {\n                    showErrorMessage('Failed to generate codebase context', error);\n                    throw error;\n                }\n            }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolders",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 13
        },
        {
          "name": "rootPath",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 27
        },
        {
          "name": "filePath",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 29
        },
        {
          "name": "command",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 38
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/generate-codebase-context-command.ts",
      "location": {
        "line": 11,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.generateCodebaseContext', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        const rootPath = workspaceFolders[0].uri.fsPath;\n        \n        await ProgressService.runWithProgress(\n            'Generating Codebase Context',\n            async (progress) => {\n                try {\n                    progress.report({ message: 'Reading symbol index...' });\n                    \n                    progress.report({ message: 'Generating codebase context...' });\n                    const filePath = await CodebaseContextService.generateAndWriteCodebaseContext(rootPath);\n                    \n                    showInformationMessage(`Codebase context generated successfully at ${filePath}`);\n                } catch (error) {\n                    showErrorMessage('Failed to generate codebase context', error);\n                    throw error;\n                }\n            }\n        );\n    })",
      "dependents": [
        {
          "name": "registerGenerateCodebaseContextCommand",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 38,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolders",
      "type": "variable",
      "filePath": "src/commands/generate-codebase-context-command.ts",
      "location": {
        "line": 12,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolders = vscode.workspace.workspaceFolders",
      "dependents": [
        {
          "name": "registerGenerateCodebaseContextCommand",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 13,
          "contextSnippet": "export const registerGenerateCodebaseContextCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateCodebaseContext', async () => {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (!workspaceFolders) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/commands/generate-codebase-context-command.ts",
      "location": {
        "line": 18,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "rootPath = workspaceFolders[0].uri.fsPath",
      "dependents": [
        {
          "name": "registerGenerateCodebaseContextCommand",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 27,
          "contextSnippet": "                    progress.report({ message: 'Reading symbol index...' });\n                    \n                    progress.report({ message: 'Generating codebase context...' });\n                    const filePath = await CodebaseContextService.generateAndWriteCodebaseContext(rootPath);\n                    \n                    showInformationMessage(`Codebase context generated successfully at ${filePath}`);\n                } catch (error) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/commands/generate-codebase-context-command.ts",
      "location": {
        "line": 27,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "filePath = await CodebaseContextService.generateAndWriteCodebaseContext(rootPath)",
      "dependents": [
        {
          "name": "registerGenerateCodebaseContextCommand",
          "filePath": "src/commands/generate-codebase-context-command.ts",
          "line": 29,
          "contextSnippet": "                    progress.report({ message: 'Generating codebase context...' });\n                    const filePath = await CodebaseContextService.generateAndWriteCodebaseContext(rootPath);\n                    \n                    showInformationMessage(`Codebase context generated successfully at ${filePath}`);\n                } catch (error) {\n                    showErrorMessage('Failed to generate codebase context', error);\n                    throw error;"
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/generate-docstring-index-command.ts": [
    {
      "name": "registerGenerateDocstringIndexCommand",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 11,
        "character": 13
      },
      "docstring": "/**\n * Registers the generate docstring index command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerGenerateDocstringIndexCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndex', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        await ProgressService.runWithProgress(\n            'Generating Docstring Index',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Generate docstrings for the existing symbol index\n                    const success = await generateDocstrings(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');\n                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage('Docstrings generated successfully.');\n                    } else {\n                        showErrorMessage('Failed to generate docstrings.');\n                    }\n                    \n                    return success;\n                } catch (error) {\n                    console.error('Error generating docstring index:', error);\n                    showErrorMessage('Error generating docstring index', error);\n                    return false;\n                }\n            },\n            { cancellable: true }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 14
        },
        {
          "name": "apiKeyAvailable",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 21
        },
        {
          "name": "response",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 32
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 48
        },
        {
          "name": "success",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 55
        },
        {
          "name": "command",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 72
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 12,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndex', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        await ProgressService.runWithProgress(\n            'Generating Docstring Index',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Generate docstrings for the existing symbol index\n                    const success = await generateDocstrings(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');\n                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage('Docstrings generated successfully.');\n                    } else {\n                        showErrorMessage('Failed to generate docstrings.');\n                    }\n                    \n                    return success;\n                } catch (error) {\n                    console.error('Error generating docstring index:', error);\n                    showErrorMessage('Error generating docstring index', error);\n                    return false;\n                }\n            },\n            { cancellable: true }\n        );\n    })",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 72,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 13,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 14,
          "contextSnippet": "export const registerGenerateDocstringIndexCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndex', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKeyAvailable",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 20,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 21,
          "contextSnippet": "        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "response",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 27,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            )",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 32,
          "contextSnippet": "                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ignoredPatterns",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 45,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "ignoredPatterns = await getIgnoredPatterns(workspaceFolder)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 48,
          "contextSnippet": "                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Generate docstrings for the existing symbol index\n                    const success = await generateDocstrings(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "success",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-command.ts",
      "location": {
        "line": 48,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "success = await generateDocstrings(workspaceFolder, ignoredPatterns, progress, token)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexCommand",
          "filePath": "src/commands/generate-docstring-index-command.ts",
          "line": 55,
          "contextSnippet": "                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage('Docstrings generated successfully.');\n                    } else {\n                        showErrorMessage('Failed to generate docstrings.');"
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/generate-docstring-index-parallel-command.ts": [
    {
      "name": "registerGenerateDocstringIndexParallelCommand",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 12,
        "character": 13
      },
      "docstring": "/**\n * Registers the generate docstring index parallel command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerGenerateDocstringIndexParallelCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndexParallel', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        // Get the concurrency preference from settings with a default of 5\n        const config = vscode.workspace.getConfiguration('cursorcrawl');\n        const maxConcurrency = config.get('docstringGenerationConcurrency', 5);\n        \n        await ProgressService.runWithProgress(\n            'Generating Docstring Index (Parallel)',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Generate docstrings in parallel for the existing symbol index\n                    const success = await generateDocstringsParallel(\n                        workspaceFolder, \n                        ignoredPatterns, \n                        progress, \n                        token,\n                        maxConcurrency\n                    );\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Parallel docstring generation was cancelled.');\n                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage(`Docstrings generated successfully using parallel processing (${maxConcurrency} concurrent files).`);\n                    } else {\n                        showErrorMessage('Failed to generate docstrings in parallel mode.');\n                    }\n                    \n                    return success;\n                } catch (error) {\n                    console.error('Error generating docstring index in parallel:', error);\n                    showErrorMessage('Error generating docstring index in parallel mode', error);\n                    return false;\n                }\n            },\n            { cancellable: true }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 15
        },
        {
          "name": "apiKeyAvailable",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 22
        },
        {
          "name": "response",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 33
        },
        {
          "name": "config",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 43
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 55
        },
        {
          "name": "maxConcurrency",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 58
        },
        {
          "name": "success",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 66
        },
        {
          "name": "command",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 83
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 13,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndexParallel', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        // Get the concurrency preference from settings with a default of 5\n        const config = vscode.workspace.getConfiguration('cursorcrawl');\n        const maxConcurrency = config.get('docstringGenerationConcurrency', 5);\n        \n        await ProgressService.runWithProgress(\n            'Generating Docstring Index (Parallel)',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Generate docstrings in parallel for the existing symbol index\n                    const success = await generateDocstringsParallel(\n                        workspaceFolder, \n                        ignoredPatterns, \n                        progress, \n                        token,\n                        maxConcurrency\n                    );\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Parallel docstring generation was cancelled.');\n                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage(`Docstrings generated successfully using parallel processing (${maxConcurrency} concurrent files).`);\n                    } else {\n                        showErrorMessage('Failed to generate docstrings in parallel mode.');\n                    }\n                    \n                    return success;\n                } catch (error) {\n                    console.error('Error generating docstring index in parallel:', error);\n                    showErrorMessage('Error generating docstring index in parallel mode', error);\n                    return false;\n                }\n            },\n            { cancellable: true }\n        );\n    })",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 83,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 14,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 15,
          "contextSnippet": "export const registerGenerateDocstringIndexParallelCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.generateDocstringIndexParallel', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKeyAvailable",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 21,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 22,
          "contextSnippet": "        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "response",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 28,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            )",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 33,
          "contextSnippet": "                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "config",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 42,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "config = vscode.workspace.getConfiguration('cursorcrawl')",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 43,
          "contextSnippet": "        \n        // Get the concurrency preference from settings with a default of 5\n        const config = vscode.workspace.getConfiguration('cursorcrawl');\n        const maxConcurrency = config.get('docstringGenerationConcurrency', 5);\n        \n        await ProgressService.runWithProgress(\n            'Generating Docstring Index (Parallel)',"
        }
      ],
      "depends_on": []
    },
    {
      "name": "maxConcurrency",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 43,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "maxConcurrency = config.get('docstringGenerationConcurrency', 5)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 58,
          "contextSnippet": "                        ignoredPatterns, \n                        progress, \n                        token,\n                        maxConcurrency\n                    );\n                    \n                    if (token?.isCancellationRequested) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ignoredPatterns",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 50,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "ignoredPatterns = await getIgnoredPatterns(workspaceFolder)",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 55,
          "contextSnippet": "                    // Generate docstrings in parallel for the existing symbol index\n                    const success = await generateDocstringsParallel(\n                        workspaceFolder, \n                        ignoredPatterns, \n                        progress, \n                        token,\n                        maxConcurrency"
        }
      ],
      "depends_on": []
    },
    {
      "name": "success",
      "type": "variable",
      "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
      "location": {
        "line": 53,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "success = await generateDocstringsParallel(\n                        workspaceFolder, \n                        ignoredPatterns, \n                        progress, \n                        token,\n                        maxConcurrency\n                    )",
      "dependents": [
        {
          "name": "registerGenerateDocstringIndexParallelCommand",
          "filePath": "src/commands/generate-docstring-index-parallel-command.ts",
          "line": 66,
          "contextSnippet": "                        return false;\n                    }\n                    \n                    if (success) {\n                        showInformationMessage(`Docstrings generated successfully using parallel processing (${maxConcurrency} concurrent files).`);\n                    } else {\n                        showErrorMessage('Failed to generate docstrings in parallel mode.');"
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/merge-json-for-visualization-command.ts": [
    {
      "name": "registerMergeJsonForVisualizationCommand",
      "type": "variable",
      "filePath": "src/commands/merge-json-for-visualization-command.ts",
      "location": {
        "line": 8,
        "character": 13
      },
      "docstring": "/**\n * Registers the merge JSON for visualization command\n * @param context - The VS Code extension context\n */",
      "snippet": "registerMergeJsonForVisualizationCommand = (context: vscode.ExtensionContext): void => {\n  context.subscriptions.push(mergeJsonForVisualizationCommand());\n}",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/commands/resume-docstring-generation-command.ts": [
    {
      "name": "registerResumeDocstringGenerationCommand",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 12,
        "character": 13
      },
      "docstring": "/**\n * Registers the resume docstring generation command\n * @param context - VS Code extension context for registration\n */",
      "snippet": "registerResumeDocstringGenerationCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.resumeDocstringGeneration', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        await ProgressService.runWithProgress(\n            'Resuming Docstring Generation',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Resume docstring generation for the existing symbol index (only for empty docstrings)\n                    await resumeDocstringGeneration(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');\n                        return;\n                    }\n                    \n                    showInformationMessage('Docstring generation resumed and completed successfully.');\n                } catch (error) {\n                    console.error('Error resuming docstring generation:', error);\n                    showErrorMessage('Error resuming docstring generation', error);\n                }\n            },\n            { cancellable: true }\n        );\n    });\n\n    context.subscriptions.push(command);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 15
        },
        {
          "name": "apiKeyAvailable",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 22
        },
        {
          "name": "response",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 33
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 49
        },
        {
          "name": "command",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 66
        }
      ]
    },
    {
      "name": "command",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 13,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "command = vscode.commands.registerCommand('cursorcrawl.resumeDocstringGeneration', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }\n        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        \n        // Check if symbol index exists\n        if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n            const response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {\n                return;\n            }\n        }\n        \n        await ProgressService.runWithProgress(\n            'Resuming Docstring Generation',\n            async (progress, token) => {\n                try {\n                    // Get ignored patterns from .gitignore\n                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Resume docstring generation for the existing symbol index (only for empty docstrings)\n                    await resumeDocstringGeneration(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');\n                        return;\n                    }\n                    \n                    showInformationMessage('Docstring generation resumed and completed successfully.');\n                } catch (error) {\n                    console.error('Error resuming docstring generation:', error);\n                    showErrorMessage('Error resuming docstring generation', error);\n                }\n            },\n            { cancellable: true }\n        );\n    })",
      "dependents": [
        {
          "name": "registerResumeDocstringGenerationCommand",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 66,
          "contextSnippet": "        );\n    });\n\n    context.subscriptions.push(command);\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 14,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "registerResumeDocstringGenerationCommand",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 15,
          "contextSnippet": "export const registerResumeDocstringGenerationCommand = (context: vscode.ExtensionContext): void => {\n    const command = vscode.commands.registerCommand('cursorcrawl.resumeDocstringGeneration', async () => {\n        const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n        if (!workspaceFolder) {\n            showErrorMessage('No workspace folder open.');\n            return;\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKeyAvailable",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 21,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true)",
      "dependents": [
        {
          "name": "registerResumeDocstringGenerationCommand",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 22,
          "contextSnippet": "        \n        // Ensure OpenAI API key is available\n        const apiKeyAvailable = await ensureOpenAIApiKey(workspaceFolder, true);\n        if (!apiKeyAvailable) {\n            return;\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "response",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 28,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "response = await vscode.window.showErrorMessage(\n                'Symbol index not found. Would you like to build the symbol index first?',\n                'Yes', 'No'\n            )",
      "dependents": [
        {
          "name": "registerResumeDocstringGenerationCommand",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 33,
          "contextSnippet": "                'Yes', 'No'\n            );\n            \n            if (response === 'Yes') {\n                // Run build symbol index first\n                await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n            } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ignoredPatterns",
      "type": "variable",
      "filePath": "src/commands/resume-docstring-generation-command.ts",
      "location": {
        "line": 46,
        "character": 26
      },
      "docstring": "/** */",
      "snippet": "ignoredPatterns = await getIgnoredPatterns(workspaceFolder)",
      "dependents": [
        {
          "name": "registerResumeDocstringGenerationCommand",
          "filePath": "src/commands/resume-docstring-generation-command.ts",
          "line": 49,
          "contextSnippet": "                    const ignoredPatterns = await getIgnoredPatterns(workspaceFolder);\n                    \n                    // Resume docstring generation for the existing symbol index (only for empty docstrings)\n                    await resumeDocstringGeneration(workspaceFolder, ignoredPatterns, progress, token);\n                    \n                    if (token?.isCancellationRequested) {\n                        showInformationMessage('Docstring generation was cancelled.');"
        }
      ],
      "depends_on": []
    }
  ],
  "src/commands/show-dependency-graph-command.ts": [
    {
      "name": "registerShowDependencyGraphCommand",
      "type": "variable",
      "filePath": "src/commands/show-dependency-graph-command.ts",
      "location": {
        "line": 8,
        "character": 13
      },
      "docstring": "/**\n * Registers the show dependency graph command\n * @param context - The VS Code extension context\n */",
      "snippet": "registerShowDependencyGraphCommand = (context: vscode.ExtensionContext): void => {\n  context.subscriptions.push(showDependencyGraphCommand());\n  context.subscriptions.push(showDependencyGraphWithDuplicatesCommand());\n}",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/context-extractor.ts": [
    {
      "name": "extractContextFiles",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 14,
        "character": 13
      },
      "docstring": "/**\n * Extracts context file references from a prompt string\n * @param promptText The prompt text to analyze\n * @returns Array of file paths referenced in the prompt\n */",
      "snippet": "extractContextFiles = ContextFileService.extractContextFiles",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "extractAndResolveContextFiles",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 22,
        "character": 13
      },
      "docstring": "/**\n * Extracts and resolves file references from a prompt to actual file paths\n * @param prompt The prompt text to analyze\n * @param rootPath The workspace root path\n * @returns Promise resolving to array of valid file paths\n */",
      "snippet": "extractAndResolveContextFiles = ContextFileService.extractAndResolveContextFiles",
      "dependents": [
        {
          "name": "executeContextExtraction",
          "filePath": "src/context-extractor.ts",
          "line": 57,
          "contextSnippet": "    }\n\n    // Extract and resolve context files from the prompt\n    const contextFiles = await extractAndResolveContextFiles(promptText, workspaceFolder);\n    \n    if (contextFiles.length === 0) {\n      return {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateRelevantInfo",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 30,
        "character": 13
      },
      "docstring": "/**\n * Generates relevant information based on context files\n * @param rootPath The root path of the project\n * @param contextFiles Array of already-verified file paths from the workspace\n * @returns The filtered relevant information\n */",
      "snippet": "generateRelevantInfo = RelevantInfoService.generateRelevantInfo",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "executeContextExtraction",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 38,
        "character": 13
      },
      "docstring": "/**\n * Executes the complete context extraction workflow\n * @param promptText The prompt text with file references\n * @param workspaceFolder The workspace folder path\n * @returns Object containing result details: success status, message, context files, and relevant info path\n */",
      "snippet": "executeContextExtraction = async (\n  promptText: string,\n  workspaceFolder: string\n): Promise<{\n  success: boolean;\n  message: string;\n  contextFiles?: string[];\n  relevantInfoPath?: string;\n}> => {\n  try {\n    // Check if symbol index exists\n    if (!await SymbolIndexService.symbolIndexExists(workspaceFolder)) {\n      return {\n        success: false,\n        message: 'Symbol index not found. Please run analysis first.'\n      };\n    }\n\n    // Extract and resolve context files from the prompt\n    const contextFiles = await extractAndResolveContextFiles(promptText, workspaceFolder);\n    \n    if (contextFiles.length === 0) {\n      return {\n        success: false,\n        message: 'No file references found in prompt. Please use @filename.ts syntax to reference files.'\n      };\n    }\n    \n    // Generate the relevant-info.json file\n    await RelevantInfoService.generateRelevantInfo(workspaceFolder, contextFiles);\n    \n    // Get path to the generated file\n    const relevantInfoPath = path.join(WorkspaceService.getCursorTestDir(workspaceFolder), 'relevant-info.json');\n    \n    return {\n      success: true,\n      message: `Successfully extracted context for ${contextFiles.length} files: ${contextFiles.slice(0, 3).join(', ')}${contextFiles.length > 3 ? '...' : ''}`,\n      contextFiles,\n      relevantInfoPath\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Error executing context extraction: ${error}`\n    };\n  }\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "contextFiles",
          "filePath": "src/context-extractor.ts",
          "line": 44
        },
        {
          "name": "relevantInfoPath",
          "filePath": "src/context-extractor.ts",
          "line": 45
        },
        {
          "name": "extractAndResolveContextFiles",
          "filePath": "src/context-extractor.ts",
          "line": 57
        }
      ]
    },
    {
      "name": "contextFiles",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 57,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "contextFiles = await extractAndResolveContextFiles(promptText, workspaceFolder)",
      "dependents": [
        {
          "name": "executeContextExtraction",
          "filePath": "src/context-extractor.ts",
          "line": 44,
          "contextSnippet": "): Promise<{\n  success: boolean;\n  message: string;\n  contextFiles?: string[];\n  relevantInfoPath?: string;\n}> => {\n  try {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "relevantInfoPath",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 70,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "relevantInfoPath = path.join(WorkspaceService.getCursorTestDir(workspaceFolder), 'relevant-info.json')",
      "dependents": [
        {
          "name": "executeContextExtraction",
          "filePath": "src/context-extractor.ts",
          "line": 45,
          "contextSnippet": "  success: boolean;\n  message: string;\n  contextFiles?: string[];\n  relevantInfoPath?: string;\n}> => {\n  try {\n    // Check if symbol index exists"
        }
      ],
      "depends_on": []
    },
    {
      "name": "findFilesMatchingPattern",
      "type": "variable",
      "filePath": "src/context-extractor.ts",
      "location": {
        "line": 87,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "findFilesMatchingPattern = ContextFileService.findFilesMatchingPattern",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/extension.ts": [
    {
      "name": "activate",
      "type": "function",
      "filePath": "src/extension.ts",
      "location": {
        "line": 23,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export function activate(context: vscode.ExtensionContext) {\n\tconsole.log('Congratulations, your extension \"cursorcrawl\" is now active!');\n\n\t// Register commands\n\tregisterAnalyzeCommand(context);\n\tregisterBuildSymbolIndexCommand(context);\n\tregisterGenerateDocstringIndexCommand(context);\n\tregisterGenerateDocstringIndexParallelCommand(context);\n\tregisterExtractContextCommand(context);\n\tregisterResumeDocstringGenerationCommand(context);\n\tregisterGenerateCodebaseContextCommand(context);\n\tregisterAnalyzeDuplicateLogicCommand(context);\n\tregisterShowDependencyGraphCommand(context);\n\tregisterMergeJsonForVisualizationCommand(context);\n\t\n\t// Initialize file watcher\n\tsetupFileWatcher(context);\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "deactivate",
      "type": "function",
      "filePath": "src/extension.ts",
      "location": {
        "line": 43,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export function deactivate() {}",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/features/context-extractor/context-file-service.ts": [
    {
      "name": "ContextFileService",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 7,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "ContextFileService = {\n  /**\n   * Extracts context file references from a prompt string\n   * @param prompt The prompt text to analyze\n   * @returns Array of file paths referenced in the prompt\n   */\n  extractContextFiles(prompt: string): string[] {\n    // Match @filename.ext patterns in the prompt\n    const fileMatches = prompt.match(/@[\\w.\\/-]+/g);\n    \n    if (!fileMatches) {\n      return [];\n    }\n    \n    // Remove @ prefix and deduplicate\n    return [...new Set(fileMatches.map(match => match.substring(1).trim()))];\n  },\n\n  /**\n   * Finds all files matching a pattern (using glob matching)\n   * @param rootPath The root path of the project\n   * @param pattern The pattern to match against\n   * @returns Array of file paths that match the pattern\n   */\n  async findFilesMatchingPattern(rootPath: string, pattern: string): Promise<string[]> {\n    // Handle exact file paths\n    if (pattern.includes('.') && !pattern.includes('*')) {\n      // Try with exact path\n      const exactPath = path.join(rootPath, pattern);\n      const fs = await import('fs-extra');\n      if (await fs.pathExists(exactPath)) {\n        return [pattern];\n      }\n      \n      // Try searching for the file name in the project\n      const fileName = path.basename(pattern);\n      const files = await FileSystemService.getProjectFiles(rootPath);\n      \n      return files\n        .filter(file => path.basename(file) === fileName)\n        .map(file => path.relative(rootPath, file));\n    }\n    \n    // Handle wildcard patterns\n    const extension = pattern.includes('.') ? path.extname(pattern) : '.ts';\n    const files = await FileSystemService.getProjectFiles(rootPath);\n    const filteredFiles = files.filter(file => path.extname(file) === extension);\n    \n    // Convert glob pattern to regex\n    const regexPattern = new RegExp(pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'));\n    \n    return filteredFiles\n      .filter(file => regexPattern.test(file))\n      .map(file => path.relative(rootPath, file));\n  },\n\n  /**\n   * Finds all matching files based on an array of patterns\n   * @param rootPath The root path of the project\n   * @param filePatterns Array of patterns to match against\n   * @returns Array of file paths that match any of the patterns\n   */\n  async findAllMatchingFiles(rootPath: string, filePatterns: string[]): Promise<string[]> {\n    const allMatchingFiles: string[] = [];\n    \n    for (const pattern of filePatterns) {\n      const matchingFiles = await this.findFilesMatchingPattern(rootPath, pattern);\n      allMatchingFiles.push(...matchingFiles);\n    }\n    \n    // Remove duplicates\n    return [...new Set(allMatchingFiles)];\n  },\n\n  /**\n   * Unified method to extract file references from prompt and resolve them to actual files\n   * @param prompt The prompt text to analyze\n   * @param rootPath The root path of the project\n   * @returns Promise resolving to a list of validated file paths\n   */\n  async extractAndResolveContextFiles(\n    prompt: string,\n    rootPath: string\n  ): Promise<string[]> {\n    // Step 1: Extract file patterns from the prompt\n    const filePatterns = this.extractContextFiles(prompt);\n    \n    if (filePatterns.length === 0) {\n      return [];\n    }\n    \n    // Step 2: Resolve patterns to actual files and validate their existence\n    const resolvedFiles = await this.findAllMatchingFiles(rootPath, filePatterns);\n    \n    return resolvedFiles;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "fileMatches",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 15,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fileMatches = prompt.match(/@[\\w.\\/-]+/g)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 17,
          "contextSnippet": "    // Match @filename.ext patterns in the prompt\n    const fileMatches = prompt.match(/@[\\w.\\/-]+/g);\n    \n    if (!fileMatches) {\n      return [];\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "exactPath",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 35,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "exactPath = path.join(rootPath, pattern)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 37,
          "contextSnippet": "      // Try with exact path\n      const exactPath = path.join(rootPath, pattern);\n      const fs = await import('fs-extra');\n      if (await fs.pathExists(exactPath)) {\n        return [pattern];\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fs",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 36,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fs = await import('fs-extra')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 37,
          "contextSnippet": "      // Try with exact path\n      const exactPath = path.join(rootPath, pattern);\n      const fs = await import('fs-extra');\n      if (await fs.pathExists(exactPath)) {\n        return [pattern];\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileName",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 42,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileName = path.basename(pattern)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 46,
          "contextSnippet": "      const files = await FileSystemService.getProjectFiles(rootPath);\n      \n      return files\n        .filter(file => path.basename(file) === fileName)\n        .map(file => path.relative(rootPath, file));\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "files",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 43,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "files = await FileSystemService.getProjectFiles(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 45,
          "contextSnippet": "      const fileName = path.basename(pattern);\n      const files = await FileSystemService.getProjectFiles(rootPath);\n      \n      return files\n        .filter(file => path.basename(file) === fileName)\n        .map(file => path.relative(rootPath, file));\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "extension",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 51,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "extension = pattern.includes('.') ? path.extname(pattern) : '.ts'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 53,
          "contextSnippet": "    // Handle wildcard patterns\n    const extension = pattern.includes('.') ? path.extname(pattern) : '.ts';\n    const files = await FileSystemService.getProjectFiles(rootPath);\n    const filteredFiles = files.filter(file => path.extname(file) === extension);\n    \n    // Convert glob pattern to regex\n    const regexPattern = new RegExp(pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'));"
        }
      ],
      "depends_on": []
    },
    {
      "name": "files",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 52,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "files = await FileSystemService.getProjectFiles(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "filteredFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 53,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filteredFiles = files.filter(file => path.extname(file) === extension)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 58,
          "contextSnippet": "    // Convert glob pattern to regex\n    const regexPattern = new RegExp(pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'));\n    \n    return filteredFiles\n      .filter(file => regexPattern.test(file))\n      .map(file => path.relative(rootPath, file));\n  },"
        }
      ],
      "depends_on": []
    },
    {
      "name": "regexPattern",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 56,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "regexPattern = new RegExp(pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 59,
          "contextSnippet": "    const regexPattern = new RegExp(pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'));\n    \n    return filteredFiles\n      .filter(file => regexPattern.test(file))\n      .map(file => path.relative(rootPath, file));\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "allMatchingFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 70,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "allMatchingFiles: string[] = []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 74,
          "contextSnippet": "    \n    for (const pattern of filePatterns) {\n      const matchingFiles = await this.findFilesMatchingPattern(rootPath, pattern);\n      allMatchingFiles.push(...matchingFiles);\n    }\n    \n    // Remove duplicates"
        }
      ],
      "depends_on": []
    },
    {
      "name": "matchingFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 73,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "matchingFiles = await this.findFilesMatchingPattern(rootPath, pattern)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 74,
          "contextSnippet": "    \n    for (const pattern of filePatterns) {\n      const matchingFiles = await this.findFilesMatchingPattern(rootPath, pattern);\n      allMatchingFiles.push(...matchingFiles);\n    }\n    \n    // Remove duplicates"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePatterns",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 92,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filePatterns = this.extractContextFiles(prompt)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 72,
          "contextSnippet": "  async findAllMatchingFiles(rootPath: string, filePatterns: string[]): Promise<string[]> {\n    const allMatchingFiles: string[] = [];\n    \n    for (const pattern of filePatterns) {\n      const matchingFiles = await this.findFilesMatchingPattern(rootPath, pattern);\n      allMatchingFiles.push(...matchingFiles);\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "resolvedFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 99,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "resolvedFiles = await this.findAllMatchingFiles(rootPath, filePatterns)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 101,
          "contextSnippet": "    // Step 2: Resolve patterns to actual files and validate their existence\n    const resolvedFiles = await this.findAllMatchingFiles(rootPath, filePatterns);\n    \n    return resolvedFiles;\n  }\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/context-extractor/context-file-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "fileMatches",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 17
        },
        {
          "name": "fs",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 37
        },
        {
          "name": "exactPath",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 37
        },
        {
          "name": "files",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 45
        },
        {
          "name": "fileName",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 46
        },
        {
          "name": "extension",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 53
        },
        {
          "name": "filteredFiles",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 58
        },
        {
          "name": "regexPattern",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 59
        },
        {
          "name": "filePatterns",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 72
        },
        {
          "name": "allMatchingFiles",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 74
        },
        {
          "name": "matchingFiles",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 74
        },
        {
          "name": "resolvedFiles",
          "filePath": "src/features/context-extractor/context-file-service.ts",
          "line": 101
        }
      ]
    }
  ],
  "src/features/context-extractor/relevant-info-service.ts": [
    {
      "name": "RelevantInfoService",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 14,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "RelevantInfoService = {\n  /**\n   * Gets the path to the relevant info file\n   * @param rootPath The workspace root path\n   * @returns The path to the relevant info file\n   */\n  getRelevantInfoPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', 'relevant-info.json');\n  },\n\n  /**\n   * Reads the relevant info from disk\n   * @param rootPath The workspace root path\n   * @returns The relevant info, or undefined if it doesn't exist\n   */\n  async readRelevantInfo(rootPath: string): Promise<RelevantInfo | undefined> {\n    try {\n      const infoPath = this.getRelevantInfoPath(rootPath);\n      \n      if (!await fs.pathExists(infoPath)) {\n        return undefined;\n      }\n      \n      const content = await fs.readFile(infoPath, 'utf8');\n      return JSON.parse(content) as RelevantInfo;\n    } catch (error) {\n      console.error('Error reading relevant info:', error);\n      return undefined;\n    }\n  },\n\n  /**\n   * Writes the relevant info to disk\n   * @param rootPath The workspace root path\n   * @param relevantInfo The relevant info to write\n   */\n  async writeRelevantInfo(rootPath: string, relevantInfo: RelevantInfo): Promise<void> {\n    try {\n      await WorkspaceService.ensureCursorTestDir(rootPath);\n      const infoPath = this.getRelevantInfoPath(rootPath);\n      await fs.writeFile(infoPath, JSON.stringify(relevantInfo, null, 2), 'utf8');\n    } catch (error) {\n      console.error('Error writing relevant info:', error);\n    }\n  },\n\n  /**\n   * Generates relevant information based on context files\n   * @param rootPath The root path of the project\n   * @param contextFiles Array of already-verified file paths from the workspace\n   * @returns The generated relevant information\n   */\n  async generateRelevantInfo(\n    rootPath: string,\n    contextFiles: string[],\n  ): Promise<RelevantInfo> {\n    // Load symbol index\n    const symbolIndex = await this.loadSymbolIndex(rootPath);\n    \n    // Files are already resolved and validated\n    const matchingFiles = contextFiles;\n    \n    // Extract relevant information for each file\n    const relevantInfo = await this.buildRelevantInfo(rootPath, matchingFiles, symbolIndex);\n    \n    // Write relevant info to file\n    await this.writeRelevantInfo(rootPath, relevantInfo);\n    \n    return relevantInfo;\n  },\n\n  /**\n   * Loads the symbol index from disk\n   * @param rootPath The workspace root path\n   * @returns The symbol index\n   */\n  async loadSymbolIndex(rootPath: string): Promise<SymbolIndex> {\n    try {\n      const symbolIndex = await SymbolIndexService.readSymbolIndex(rootPath);\n      if (!symbolIndex) {\n        return {};\n      }\n      return symbolIndex;\n    } catch (error) {\n      console.error('Error loading symbol index:', error);\n      return {};\n    }\n  },\n\n  /**\n   * Builds the relevant information structure from the context files\n   * @param rootPath The root path of the project\n   * @param contextFiles Array of file paths that are referenced in the prompt\n   * @param symbolIndex The symbol index\n   * @returns The built relevant information\n   */\n  async buildRelevantInfo(\n    rootPath: string,\n    contextFiles: string[],\n    symbolIndex: SymbolIndex\n  ): Promise<RelevantInfo> {\n    const relevantInfo: RelevantInfo = {\n      files: {},\n      dependencyGraph: {}\n    };\n    \n    // Process the symbol index using the SymbolIndexAnalyzer\n    const analysisResult = SymbolIndexAnalyzer.analyzeSymbolIndex(symbolIndex, contextFiles);\n    \n    // Assign dependency graph\n    relevantInfo.dependencyGraph = analysisResult.dependencyInfo;\n    \n    for (const filePath of contextFiles) {\n      if (!FileSystemService.isAnalyzableFile(filePath)) {\n        continue;\n      }\n      \n      try {\n        // Extract file content with context\n        const content = await this.extractSourceWithContext(rootPath, filePath);\n        \n        // Get symbols for this file from the filtered index\n        const fileSymbols = analysisResult.filteredIndex[filePath] || [];\n        \n        // Add file information to the relevant info\n        relevantInfo.files[filePath] = {\n          content,\n          symbols: fileSymbols\n        };\n      } catch (error) {\n        console.error(`Error processing file ${filePath}:`, error);\n      }\n    }\n    \n    return relevantInfo;\n  },\n  \n  /**\n   * Extracts source file content with context\n   * @param rootPath The root path of the project\n   * @param filePath The file path\n   * @returns The source file content with context\n   */\n  async extractSourceWithContext(\n    rootPath: string,\n    filePath: string\n  ): Promise<string> {\n    try {\n      const fs = await import('fs-extra');\n      const absolutePath = path.join(rootPath, filePath);\n      \n      if (await fs.pathExists(absolutePath)) {\n        return await fs.readFile(absolutePath, 'utf8');\n      }\n      \n      return '';\n    } catch (error) {\n      console.error(`Error reading file ${filePath}:`, error);\n      return '';\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "infoPath",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 31,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "infoPath = this.getRelevantInfoPath(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 33,
          "contextSnippet": "    try {\n      const infoPath = this.getRelevantInfoPath(rootPath);\n      \n      if (!await fs.pathExists(infoPath)) {\n        return undefined;\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 37,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "content = await fs.readFile(infoPath, 'utf8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 38,
          "contextSnippet": "      }\n      \n      const content = await fs.readFile(infoPath, 'utf8');\n      return JSON.parse(content) as RelevantInfo;\n    } catch (error) {\n      console.error('Error reading relevant info:', error);\n      return undefined;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "infoPath",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 53,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "infoPath = this.getRelevantInfoPath(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 71,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await this.loadSymbolIndex(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 77,
          "contextSnippet": "    const matchingFiles = contextFiles;\n    \n    // Extract relevant information for each file\n    const relevantInfo = await this.buildRelevantInfo(rootPath, matchingFiles, symbolIndex);\n    \n    // Write relevant info to file\n    await this.writeRelevantInfo(rootPath, relevantInfo);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "matchingFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 74,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "matchingFiles = contextFiles",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 77,
          "contextSnippet": "    const matchingFiles = contextFiles;\n    \n    // Extract relevant information for each file\n    const relevantInfo = await this.buildRelevantInfo(rootPath, matchingFiles, symbolIndex);\n    \n    // Write relevant info to file\n    await this.writeRelevantInfo(rootPath, relevantInfo);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "relevantInfo",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 77,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "relevantInfo = await this.buildRelevantInfo(rootPath, matchingFiles, symbolIndex)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 54,
          "contextSnippet": "    try {\n      await WorkspaceService.ensureCursorTestDir(rootPath);\n      const infoPath = this.getRelevantInfoPath(rootPath);\n      await fs.writeFile(infoPath, JSON.stringify(relevantInfo, null, 2), 'utf8');\n    } catch (error) {\n      console.error('Error writing relevant info:', error);\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 92,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await SymbolIndexService.readSymbolIndex(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "relevantInfo",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 115,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "relevantInfo: RelevantInfo = {\n      files: {},\n      dependencyGraph: {}\n    }",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "analysisResult",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 121,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "analysisResult = SymbolIndexAnalyzer.analyzeSymbolIndex(symbolIndex, contextFiles)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 124,
          "contextSnippet": "    const analysisResult = SymbolIndexAnalyzer.analyzeSymbolIndex(symbolIndex, contextFiles);\n    \n    // Assign dependency graph\n    relevantInfo.dependencyGraph = analysisResult.dependencyInfo;\n    \n    for (const filePath of contextFiles) {\n      if (!FileSystemService.isAnalyzableFile(filePath)) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 133,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "content = await this.extractSourceWithContext(rootPath, filePath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 136,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = analysisResult.filteredIndex[filePath] || []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 141,
          "contextSnippet": "        // Add file information to the relevant info\n        relevantInfo.files[filePath] = {\n          content,\n          symbols: fileSymbols\n        };\n      } catch (error) {\n        console.error(`Error processing file ${filePath}:`, error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fs",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 162,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fs = await import('fs-extra')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 1,
          "contextSnippet": "import * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { RelevantInfo } from '@/shared/types/relevant-info';\nimport { SymbolIndex } from '@/shared/types/symbol-index';"
        }
      ],
      "depends_on": []
    },
    {
      "name": "absolutePath",
      "type": "variable",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 163,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "absolutePath = path.join(rootPath, filePath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 165,
          "contextSnippet": "      const fs = await import('fs-extra');\n      const absolutePath = path.join(rootPath, filePath);\n      \n      if (await fs.pathExists(absolutePath)) {\n        return await fs.readFile(absolutePath, 'utf8');\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/context-extractor/relevant-info-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "fs",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 1
        },
        {
          "name": "infoPath",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 33
        },
        {
          "name": "content",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 38
        },
        {
          "name": "relevantInfo",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 54
        },
        {
          "name": "matchingFiles",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 77
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 77
        },
        {
          "name": "analysisResult",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 124
        },
        {
          "name": "dependencyInfo",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 124
        },
        {
          "name": "filteredIndex",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 136
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 141
        },
        {
          "name": "absolutePath",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 165
        }
      ]
    }
  ],
  "src/features/context-extractor/symbol-index-analyzer.ts": [
    {
      "name": "SymbolIndexAnalysisResult",
      "type": "interface",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 7,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface SymbolIndexAnalysisResult {\n  /**\n   * Filtered symbol index containing only relevant symbols\n   */\n  filteredIndex: SymbolIndex;\n  \n  /**\n   * Dependency information extracted from the symbol index\n   */\n  dependencyInfo: Record<string, FileImportInfo>;\n  \n  /**\n   * Set of relevant files that were included in the analysis\n   */\n  relevantFiles: Set<string>;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 37,
          "contextSnippet": "  analyzeSymbolIndex(\n    symbolIndex: SymbolIndex,\n    contextFiles: string[]\n  ): SymbolIndexAnalysisResult {\n    // Create a set of files we know we want to include\n    const relevantFiles = new Set<string>(contextFiles);\n    "
        }
      ],
      "depends_on": [
        {
          "name": "filteredIndex",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 11
        },
        {
          "name": "dependencyInfo",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 16
        },
        {
          "name": "relevantFiles",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 21
        }
      ]
    },
    {
      "name": "SymbolIndexAnalyzer",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 27,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "SymbolIndexAnalyzer = {\n  /**\n   * Analyzes a symbol index to extract relevant information\n   * @param symbolIndex The complete symbol index\n   * @param contextFiles Array of file paths to filter by\n   * @returns Analysis result containing filtered index and dependency info\n   */\n  analyzeSymbolIndex(\n    symbolIndex: SymbolIndex,\n    contextFiles: string[]\n  ): SymbolIndexAnalysisResult {\n    // Create a set of files we know we want to include\n    const relevantFiles = new Set<string>(contextFiles);\n    \n    // Initialize result structures\n    const filteredIndex: SymbolIndex = {};\n    const dependencyInfo: Record<string, FileImportInfo> = {};\n    \n    // First pass: process direct context files and initialize structures\n    this.processDirectContextFiles(symbolIndex, contextFiles, filteredIndex, dependencyInfo);\n    \n    // Second pass: process references and build dependency relationships\n    this.processReferencesAndDependencies(symbolIndex, filteredIndex, dependencyInfo, relevantFiles);\n    \n    // Third pass: consolidate and normalize results\n    this.normalizeResults(filteredIndex, dependencyInfo);\n    \n    return {\n      filteredIndex,\n      dependencyInfo,\n      relevantFiles\n    };\n  },\n\n  /**\n   * Process direct context files - initialize filtered index and dependency info\n   */\n  processDirectContextFiles(\n    symbolIndex: SymbolIndex,\n    contextFiles: string[],\n    filteredIndex: SymbolIndex,\n    dependencyInfo: Record<string, FileImportInfo>\n  ): void {\n    for (const filePath of contextFiles) {\n      // Initialize dependency info for this file\n      dependencyInfo[filePath] = {\n        imports: [],\n        importedBy: []\n      };\n      \n      // Add symbols from this file to the filtered index\n      if (symbolIndex[filePath]) {\n        filteredIndex[filePath] = symbolIndex[filePath].map(symbol => ({\n          ...symbol,\n          dependents: [],\n          depends_on: []\n        }));\n      }\n    }\n  },\n\n  /**\n   * Process references and build dependency relationships\n   */\n  processReferencesAndDependencies(\n    symbolIndex: SymbolIndex,\n    filteredIndex: SymbolIndex,\n    dependencyInfo: Record<string, FileImportInfo>,\n    relevantFiles: Set<string>\n  ): void {\n    // Process each context file to find dependencies and dependents\n    for (const filePath in filteredIndex) {\n      const fileSymbols = filteredIndex[filePath];\n      \n      if (!fileSymbols) {continue;}\n      \n      for (const symbol of fileSymbols) {\n        // Process dependencies (files this file imports from)\n        this.processDependencies(symbol, filePath, symbolIndex, filteredIndex, dependencyInfo, relevantFiles);\n        \n        // Process dependents (files that import from this file)\n        this.processDependents(symbol, filePath, symbolIndex, filteredIndex, dependencyInfo, relevantFiles);\n      }\n    }\n  },\n\n  /**\n   * Process dependencies for a symbol (files it depends on)\n   */\n  processDependencies(\n    symbol: SymbolIndexEntry,\n    filePath: string,\n    symbolIndex: SymbolIndex,\n    filteredIndex: SymbolIndex,\n    dependencyInfo: Record<string, FileImportInfo>,\n    relevantFiles: Set<string>\n  ): void {\n    for (const dependency of symbol.depends_on || []) {\n      const sourceFile = dependency.filePath;\n      if (!sourceFile || sourceFile === filePath) {continue;}\n      \n      // Add to the set of relevant files\n      relevantFiles.add(sourceFile);\n      \n      // Add to dependency info\n      this.addImportRelationship(\n        dependencyInfo,\n        filePath,\n        sourceFile,\n        dependency.name\n      );\n      \n      // Make sure the source file is in the filtered index\n      if (!filteredIndex[sourceFile] && symbolIndex[sourceFile]) {\n        filteredIndex[sourceFile] = symbolIndex[sourceFile].map(s => ({\n          ...s,\n          dependents: [],\n          depends_on: []\n        }));\n      }\n    }\n  },\n\n  /**\n   * Process dependents for a symbol (files that depend on it)\n   */\n  processDependents(\n    symbol: SymbolIndexEntry,\n    filePath: string,\n    symbolIndex: SymbolIndex,\n    filteredIndex: SymbolIndex,\n    dependencyInfo: Record<string, FileImportInfo>,\n    relevantFiles: Set<string>\n  ): void {\n    for (const dependent of symbol.dependents || []) {\n      const targetFile = dependent.filePath;\n      if (!targetFile || targetFile === filePath) {continue;}\n      \n      // Add to the set of relevant files\n      relevantFiles.add(targetFile);\n      \n      // Add to dependency info\n      this.addImportedByRelationship(\n        dependencyInfo,\n        filePath,\n        targetFile,\n        dependent.name\n      );\n      \n      // Make sure the target file is in the filtered index\n      if (!filteredIndex[targetFile] && symbolIndex[targetFile]) {\n        filteredIndex[targetFile] = symbolIndex[targetFile].map(s => ({\n          ...s,\n          dependents: [],\n          depends_on: []\n        }));\n      }\n    }\n  },\n\n  /**\n   * Add an import relationship to the dependency info\n   */\n  addImportRelationship(\n    dependencyInfo: Record<string, FileImportInfo>,\n    sourceFile: string,\n    targetFile: string,\n    symbolName: string\n  ): void {\n    // Initialize if it doesn't exist\n    if (!dependencyInfo[sourceFile]) {\n      dependencyInfo[sourceFile] = {\n        imports: [],\n        importedBy: []\n      };\n    }\n    \n    // Find existing import or create new one\n    let existingImport = dependencyInfo[sourceFile].imports.find(\n      imp => imp.from === targetFile\n    );\n    \n    if (!existingImport) {\n      existingImport = { from: targetFile, imports: [] };\n      dependencyInfo[sourceFile].imports.push(existingImport);\n    }\n    \n    // Add the symbol to the imports if it's not already there\n    if (!existingImport.imports.includes(symbolName)) {\n      existingImport.imports.push(symbolName);\n    }\n  },\n\n  /**\n   * Add an imported-by relationship to the dependency info\n   */\n  addImportedByRelationship(\n    dependencyInfo: Record<string, FileImportInfo>,\n    targetFile: string,\n    sourceFile: string,\n    symbolName: string\n  ): void {\n    // Initialize if it doesn't exist\n    if (!dependencyInfo[targetFile]) {\n      dependencyInfo[targetFile] = {\n        imports: [],\n        importedBy: []\n      };\n    }\n    \n    // Find existing importedBy or create new one\n    let existingImportedBy = dependencyInfo[targetFile].importedBy.find(\n      imp => imp.from === sourceFile\n    );\n    \n    if (!existingImportedBy) {\n      existingImportedBy = { from: sourceFile, imports: [] };\n      dependencyInfo[targetFile].importedBy.push(existingImportedBy);\n    }\n    \n    // Add the symbol to the importedBy if it's not already there\n    if (!existingImportedBy.imports.includes(symbolName)) {\n      existingImportedBy.imports.push(symbolName);\n    }\n  },\n\n  /**\n   * Normalize and finalize the results\n   */\n  normalizeResults(\n    filteredIndex: SymbolIndex,\n    dependencyInfo: Record<string, FileImportInfo>\n  ): void {\n    // Ensure all files in filteredIndex have entries in dependencyInfo\n    for (const filePath in filteredIndex) {\n      if (!dependencyInfo[filePath]) {\n        dependencyInfo[filePath] = {\n          imports: [],\n          importedBy: []\n        };\n      }\n    }\n    \n    // Ensure all files in dependencyInfo have entries in filteredIndex (if they exist in original index)\n    for (const filePath in dependencyInfo) {\n      if (!filteredIndex[filePath]) {\n        filteredIndex[filePath] = [];\n      }\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "relevantFiles",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 39,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "relevantFiles = new Set<string>(contextFiles)",
      "dependents": [
        {
          "name": "SymbolIndexAnalysisResult",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 21,
          "contextSnippet": "  /**\n   * Set of relevant files that were included in the analysis\n   */\n  relevantFiles: Set<string>;\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 49,
          "contextSnippet": "    this.processDirectContextFiles(symbolIndex, contextFiles, filteredIndex, dependencyInfo);\n    \n    // Second pass: process references and build dependency relationships\n    this.processReferencesAndDependencies(symbolIndex, filteredIndex, dependencyInfo, relevantFiles);\n    \n    // Third pass: consolidate and normalize results\n    this.normalizeResults(filteredIndex, dependencyInfo);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filteredIndex",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 42,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filteredIndex: SymbolIndex = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 136,
          "contextSnippet": "        const content = await this.extractSourceWithContext(rootPath, filePath);\n        \n        // Get symbols for this file from the filtered index\n        const fileSymbols = analysisResult.filteredIndex[filePath] || [];\n        \n        // Add file information to the relevant info\n        relevantInfo.files[filePath] = {"
        },
        {
          "name": "SymbolIndexAnalysisResult",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 11,
          "contextSnippet": "  /**\n   * Filtered symbol index containing only relevant symbols\n   */\n  filteredIndex: SymbolIndex;\n  \n  /**\n   * Dependency information extracted from the symbol index"
        },
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 46,
          "contextSnippet": "    const dependencyInfo: Record<string, FileImportInfo> = {};\n    \n    // First pass: process direct context files and initialize structures\n    this.processDirectContextFiles(symbolIndex, contextFiles, filteredIndex, dependencyInfo);\n    \n    // Second pass: process references and build dependency relationships\n    this.processReferencesAndDependencies(symbolIndex, filteredIndex, dependencyInfo, relevantFiles);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "dependencyInfo",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 43,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "dependencyInfo: Record<string, FileImportInfo> = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/relevant-info-service.ts",
          "line": 124,
          "contextSnippet": "    const analysisResult = SymbolIndexAnalyzer.analyzeSymbolIndex(symbolIndex, contextFiles);\n    \n    // Assign dependency graph\n    relevantInfo.dependencyGraph = analysisResult.dependencyInfo;\n    \n    for (const filePath of contextFiles) {\n      if (!FileSystemService.isAnalyzableFile(filePath)) {"
        },
        {
          "name": "SymbolIndexAnalysisResult",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 16,
          "contextSnippet": "  /**\n   * Dependency information extracted from the symbol index\n   */\n  dependencyInfo: Record<string, FileImportInfo>;\n  \n  /**\n   * Set of relevant files that were included in the analysis"
        },
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 46,
          "contextSnippet": "    const dependencyInfo: Record<string, FileImportInfo> = {};\n    \n    // First pass: process direct context files and initialize structures\n    this.processDirectContextFiles(symbolIndex, contextFiles, filteredIndex, dependencyInfo);\n    \n    // Second pass: process references and build dependency relationships\n    this.processReferencesAndDependencies(symbolIndex, filteredIndex, dependencyInfo, relevantFiles);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 99,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = filteredIndex[filePath]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 101,
          "contextSnippet": "    for (const filePath in filteredIndex) {\n      const fileSymbols = filteredIndex[filePath];\n      \n      if (!fileSymbols) {continue;}\n      \n      for (const symbol of fileSymbols) {\n        // Process dependencies (files this file imports from)"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sourceFile",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 125,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "sourceFile = dependency.filePath",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 126,
          "contextSnippet": "  ): void {\n    for (const dependency of symbol.depends_on || []) {\n      const sourceFile = dependency.filePath;\n      if (!sourceFile || sourceFile === filePath) {continue;}\n      \n      // Add to the set of relevant files\n      relevantFiles.add(sourceFile);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "targetFile",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 162,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "targetFile = dependent.filePath",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 163,
          "contextSnippet": "  ): void {\n    for (const dependent of symbol.dependents || []) {\n      const targetFile = dependent.filePath;\n      if (!targetFile || targetFile === filePath) {continue;}\n      \n      // Add to the set of relevant files\n      relevantFiles.add(targetFile);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingImport",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 205,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "existingImport = dependencyInfo[sourceFile].imports.find(\n      imp => imp.from === targetFile\n    )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 209,
          "contextSnippet": "      imp => imp.from === targetFile\n    );\n    \n    if (!existingImport) {\n      existingImport = { from: targetFile, imports: [] };\n      dependencyInfo[sourceFile].imports.push(existingImport);\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingImportedBy",
      "type": "variable",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 238,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "existingImportedBy = dependencyInfo[targetFile].importedBy.find(\n      imp => imp.from === sourceFile\n    )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 242,
          "contextSnippet": "      imp => imp.from === sourceFile\n    );\n    \n    if (!existingImportedBy) {\n      existingImportedBy = { from: sourceFile, imports: [] };\n      dependencyInfo[targetFile].importedBy.push(existingImportedBy);\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "SymbolIndexAnalysisResult",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 37
        },
        {
          "name": "filteredIndex",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 46
        },
        {
          "name": "dependencyInfo",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 46
        },
        {
          "name": "relevantFiles",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 49
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 101
        },
        {
          "name": "sourceFile",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 126
        },
        {
          "name": "targetFile",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 163
        },
        {
          "name": "existingImport",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 209
        },
        {
          "name": "existingImportedBy",
          "filePath": "src/features/context-extractor/symbol-index-analyzer.ts",
          "line": 242
        }
      ]
    }
  ],
  "src/features/dependency-graph/dependency-graph-command.ts": [
    {
      "name": "showDependencyGraphCommand",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 12,
        "character": 13
      },
      "docstring": "/**\n * Handles execution of the dependency graph visualization command\n * @returns A function that handles the command\n */",
      "snippet": "showDependencyGraphCommand = (): vscode.Disposable => {\n  return vscode.commands.registerCommand('cursorcrawl.showDependencyGraph', async () => {\n    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }\n      \n      // Show progress indicator\n      await vscode.window.withProgress(\n        {\n          location: vscode.ProgressLocation.Notification,\n          title: 'Generating dependency graph...',\n          cancellable: false\n        },\n        async (progress) => {\n          progress.report({ message: 'Processing symbol index...' });\n          \n          try {\n            // Generate the visualization\n            const visualizationPath = await DependencyGraphService.generateVisualization(rootPath);\n            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph visualization opened in browser.');\n          } catch (error) {\n            vscode.window.showErrorMessage(`Failed to generate dependency graph: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n      );\n    } catch (error) {\n      vscode.window.showErrorMessage(`Error showing dependency graph: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  });\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "rootPath",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 17
        },
        {
          "name": "visualizationPath",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 37
        },
        {
          "name": "uri",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 38
        }
      ]
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 15,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "rootPath = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "showDependencyGraphCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 17,
          "contextSnippet": "    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }"
        },
        {
          "name": "showDependencyGraphWithDuplicatesCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 61,
          "contextSnippet": "    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "visualizationPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 34,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "visualizationPath = await DependencyGraphService.generateVisualization(rootPath)",
      "dependents": [
        {
          "name": "showDependencyGraphCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 37,
          "contextSnippet": "            const visualizationPath = await DependencyGraphService.generateVisualization(rootPath);\n            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph visualization opened in browser.');"
        },
        {
          "name": "showDependencyGraphWithDuplicatesCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 90,
          "contextSnippet": "            const visualizationPath = await DependencyGraphService.generateVisualization(rootPath);\n            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph with duplicate analysis opened in browser.');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "uri",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 37,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "uri = vscode.Uri.file(visualizationPath)",
      "dependents": [
        {
          "name": "showDependencyGraphCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 38,
          "contextSnippet": "            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph visualization opened in browser.');\n          } catch (error) {"
        },
        {
          "name": "showDependencyGraphWithDuplicatesCommand",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 91,
          "contextSnippet": "            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph with duplicate analysis opened in browser.');\n          } catch (error) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "showDependencyGraphWithDuplicatesCommand",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 56,
        "character": 13
      },
      "docstring": "/**\n * Handles execution of the dependency graph with duplicate analysis visualization command\n * @returns A function that handles the command\n */",
      "snippet": "showDependencyGraphWithDuplicatesCommand = (): vscode.Disposable => {\n  return vscode.commands.registerCommand('cursorcrawl.showDependencyGraphWithDuplicates', async () => {\n    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }\n      \n      // Show progress indicator\n      await vscode.window.withProgress(\n        {\n          location: vscode.ProgressLocation.Notification,\n          title: 'Generating dependency graph with duplicate analysis...',\n          cancellable: false\n        },\n        async (progress) => {\n          try {\n            // First ensure merged JSON exists\n            progress.report({ message: 'Merging JSON files...' });\n            \n            // Check if we need to generate the merged JSON first\n            const { mergedJsonPath } = MergeJsonService.getFilePaths(rootPath);\n            if (!await fs.pathExists(mergedJsonPath)) {\n              await MergeJsonService.mergeJsonFiles(rootPath);\n            }\n            \n            progress.report({ message: 'Generating visualization...' });\n            \n            // Generate the visualization\n            const visualizationPath = await DependencyGraphService.generateVisualization(rootPath);\n            \n            // Show the visualization in the browser\n            const uri = vscode.Uri.file(visualizationPath);\n            await vscode.env.openExternal(uri);\n            \n            vscode.window.showInformationMessage('Dependency graph with duplicate analysis opened in browser.');\n          } catch (error) {\n            vscode.window.showErrorMessage(`Failed to generate dependency graph with duplicates: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n      );\n    } catch (error) {\n      vscode.window.showErrorMessage(`Error showing dependency graph with duplicates: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  });\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "rootPath",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 61
        },
        {
          "name": "visualizationPath",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 90
        },
        {
          "name": "uri",
          "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
          "line": 91
        }
      ]
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 59,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "rootPath = WorkspaceService.getWorkspaceFolder()",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "visualizationPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 87,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "visualizationPath = await DependencyGraphService.generateVisualization(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "uri",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-command.ts",
      "location": {
        "line": 90,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "uri = vscode.Uri.file(visualizationPath)",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/features/dependency-graph/dependency-graph-service.ts": [
    {
      "name": "GraphNode",
      "type": "interface",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 11,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface GraphNode {\n  id: string;\n  label: string;\n  type: string;\n  filePath: string;\n  duplicateScore?: number;\n}",
      "dependents": [
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 32,
          "contextSnippet": " * Interface for graph data\n */\nexport interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 55,
          "contextSnippet": "   * @returns Graph data for visualization\n   */\n  createGraphData(symbolIndex: SymbolIndex, duplicateAnalysisData?: DuplicateAnalysisData): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();"
        }
      ],
      "depends_on": [
        {
          "name": "duplicateScore",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 16
        }
      ]
    },
    {
      "name": "GraphEdge",
      "type": "interface",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 22,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface GraphEdge {\n  source: string;\n  target: string;\n  type: 'dependency' | 'dependent';\n}",
      "dependents": [
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 33,
          "contextSnippet": " */\nexport interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}\n"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 56,
          "contextSnippet": "   */\n  createGraphData(symbolIndex: SymbolIndex, duplicateAnalysisData?: DuplicateAnalysisData): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();\n    const hasDuplicateAnalysis = !!duplicateAnalysisData && Object.keys(duplicateAnalysisData).length > 0;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "GraphData",
      "type": "interface",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 31,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 54,
          "contextSnippet": "   * @param duplicateAnalysisData - Optional duplicate analysis data\n   * @returns Graph data for visualization\n   */\n  createGraphData(symbolIndex: SymbolIndex, duplicateAnalysisData?: DuplicateAnalysisData): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();"
        }
      ],
      "depends_on": [
        {
          "name": "nodes",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 32
        },
        {
          "name": "GraphNode",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 32
        },
        {
          "name": "edges",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 33
        },
        {
          "name": "GraphEdge",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 33
        },
        {
          "name": "hasDuplicateAnalysis",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 34
        }
      ]
    },
    {
      "name": "DuplicateAnalysisData",
      "type": "interface",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 40,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DuplicateAnalysisData {\n  [filePath: string]: number;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 54,
          "contextSnippet": "   * @param duplicateAnalysisData - Optional duplicate analysis data\n   * @returns Graph data for visualization\n   */\n  createGraphData(symbolIndex: SymbolIndex, duplicateAnalysisData?: DuplicateAnalysisData): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DependencyGraphService",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 47,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "DependencyGraphService = {\n  /**\n   * Creates graph data from symbol index\n   * @param symbolIndex - The symbol index to process\n   * @param duplicateAnalysisData - Optional duplicate analysis data\n   * @returns Graph data for visualization\n   */\n  createGraphData(symbolIndex: SymbolIndex, duplicateAnalysisData?: DuplicateAnalysisData): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();\n    const hasDuplicateAnalysis = !!duplicateAnalysisData && Object.keys(duplicateAnalysisData).length > 0;\n    \n    // Process all symbols in the index\n    Object.values(symbolIndex).forEach(fileSymbols => {\n      fileSymbols.forEach(symbol => {\n        // Create a unique ID for the symbol\n        const nodeId = `${symbol.filePath}:${symbol.name}`;\n        \n        // Add node if it doesn't already exist\n        if (!nodeIds.has(nodeId)) {\n          nodeIds.add(nodeId);\n          \n          const node: GraphNode = {\n            id: nodeId,\n            label: symbol.name,\n            type: symbol.type,\n            filePath: symbol.filePath\n          };\n          \n          // Add duplicate score if available\n          if (hasDuplicateAnalysis && duplicateAnalysisData?.[symbol.filePath]) {\n            node.duplicateScore = duplicateAnalysisData[symbol.filePath];\n          }\n          \n          nodes.push(node);\n        }\n        \n        // Process dependencies\n        symbol.depends_on.forEach(dep => {\n          const targetId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${nodeId}->${targetId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: nodeId,\n              target: targetId,\n              type: 'dependency'\n            });\n          }\n        });\n        \n        // Process dependents\n        symbol.dependents.forEach(dep => {\n          const sourceId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${sourceId}->${nodeId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: sourceId,\n              target: nodeId,\n              type: 'dependent'\n            });\n          }\n        });\n      });\n    });\n    \n    return { nodes, edges, hasDuplicateAnalysis };\n  },\n  \n  /**\n   * Reads duplicate analysis data from file if it exists\n   * @param rootPath - The workspace root path\n   * @returns Duplicate analysis data or undefined if not found\n   */\n  async readDuplicateAnalysisData(rootPath: string): Promise<DuplicateAnalysisData | undefined> {\n    try {\n      const analysisPath = path.join(rootPath, '.cursortest', 'duplicate-analysis.json');\n      \n      if (await fs.pathExists(analysisPath)) {\n        const content = await fs.readFile(analysisPath, 'utf8');\n        return JSON.parse(content) as DuplicateAnalysisData;\n      }\n      \n      return undefined;\n    } catch (error) {\n      console.error('Error reading duplicate analysis data:', error);\n      return undefined;\n    }\n  },\n\n  /**\n   * Reads the merged JSON file if it exists\n   * @param rootPath - The workspace root path\n   * @returns The merged symbol index with scores or undefined if not found\n   */\n  async readMergedJsonData(rootPath: string): Promise<SymbolIndexWithScores | undefined> {\n    try {\n      const mergedJsonPath = path.join(rootPath, '.cursortest', 'merged-json-for-viz.json');\n      \n      if (await fs.pathExists(mergedJsonPath)) {\n        console.log(`Found merged JSON at ${mergedJsonPath}`);\n        const content = await fs.readFile(mergedJsonPath, 'utf8');\n        return JSON.parse(content) as SymbolIndexWithScores;\n      }\n      \n      console.log('Merged JSON file not found');\n      return undefined;\n    } catch (error) {\n      console.error('Error reading merged JSON data:', error);\n      return undefined;\n    }\n  },\n\n  /**\n   * Creates graph data from merged symbol index with scores\n   * @param mergedJson - The merged symbol index with scores\n   * @returns Graph data for visualization\n   */\n  createGraphDataFromMergedJson(mergedJson: SymbolIndexWithScores): GraphData {\n    const nodes: GraphNode[] = [];\n    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();\n    const hasDuplicateAnalysis = Object.values(mergedJson).some(fileSymbols => \n      fileSymbols.some(symbol => symbol.scores?.some(score => score.type === 'duplicateAnalysis'))\n    );\n    \n    // Process all symbols in the merged index\n    Object.values(mergedJson).forEach(fileSymbols => {\n      fileSymbols.forEach(symbol => {\n        // Create a unique ID for the symbol\n        const nodeId = `${symbol.filePath}:${symbol.name}`;\n        \n        // Add node if it doesn't already exist\n        if (!nodeIds.has(nodeId)) {\n          nodeIds.add(nodeId);\n          \n          const node: GraphNode = {\n            id: nodeId,\n            label: symbol.name,\n            type: symbol.type,\n            filePath: symbol.filePath\n          };\n          \n          // Add duplicate score if available\n          const duplicateScore = symbol.scores?.find(score => score.type === 'duplicateAnalysis');\n          if (duplicateScore) {\n            node.duplicateScore = duplicateScore.score;\n          }\n          \n          nodes.push(node);\n        }\n        \n        // Process dependencies\n        symbol.depends_on.forEach(dep => {\n          const targetId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${nodeId}->${targetId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: nodeId,\n              target: targetId,\n              type: 'dependency'\n            });\n          }\n        });\n        \n        // Process dependents\n        symbol.dependents.forEach(dep => {\n          const sourceId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${sourceId}->${nodeId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: sourceId,\n              target: nodeId,\n              type: 'dependent'\n            });\n          }\n        });\n      });\n    });\n    \n    return { nodes, edges, hasDuplicateAnalysis };\n  },\n  \n  /**\n   * Creates the HTML content for the dependency graph visualization\n   * @param graphData - The graph data to visualize\n   * @returns HTML content as string\n   */\n  createVisualizationHtml(graphData: GraphData): string {\n    // Build the view toggle buttons HTML - only include duplicate view button if we have duplicate analysis data\n    const viewToggleButtonsHtml = graphData.hasDuplicateAnalysis \n      ? `\n    <span>View: </span>\n    <button id=\"dependency-view\" class=\"active\">Dependency</button>\n    <button id=\"duplicate-view\">Duplicate</button>\n    `\n      : `\n    <span>View: </span>\n    <button id=\"dependency-view\" class=\"active\">Dependency</button>\n    `;\n\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Dependency Graph Visualization</title>\n  <script src=\"https://unpkg.com/d3@7.8.5/dist/d3.min.js\"></script>\n  <style>\n    body, html {\n      margin: 0;\n      padding: 0;\n      width: 100%;\n      height: 100%;\n      overflow: hidden;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n    }\n    \n    #graph-container {\n      width: 100%;\n      height: 100vh;\n      background-color: #f5f5f5;\n    }\n    \n    .controls {\n      position: absolute;\n      top: 10px;\n      left: 10px;\n      z-index: 1000;\n      background-color: rgba(255, 255, 255, 0.9);\n      padding: 10px;\n      border-radius: 4px;\n      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n    }\n\n    .view-toggle {\n      position: absolute;\n      top: 10px;\n      right: 10px;\n      z-index: 1000;\n      background-color: rgba(255, 255, 255, 0.9);\n      padding: 10px;\n      border-radius: 4px;\n      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n    }\n\n    .view-toggle button {\n      padding: 5px 10px;\n      border: 1px solid #ccc;\n      background: #fff;\n      cursor: pointer;\n      margin-left: 5px;\n    }\n\n    .view-toggle button.active {\n      background: #4285F4;\n      color: white;\n      border-color: #2b5fb4;\n    }\n    \n    .node {\n      cursor: pointer;\n    }\n    \n    .link {\n      stroke-opacity: 0.6;\n      stroke-width: 1.5px;\n    }\n    \n    .node text {\n      font-size: 12px;\n      pointer-events: none;\n    }\n    \n    .tooltip {\n      position: absolute;\n      background-color: rgba(255, 255, 255, 0.9);\n      border-radius: 4px;\n      padding: 10px;\n      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n      pointer-events: none;\n      display: none;\n    }\n\n    .legend {\n      position: absolute;\n      bottom: 20px;\n      right: 20px;\n      background-color: rgba(255, 255, 255, 0.9);\n      padding: 10px;\n      border-radius: 4px;\n      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n      display: none;\n      z-index: 1000;\n    }\n\n    .legend.show {\n      display: block;\n    }\n\n    .legend-item {\n      display: flex;\n      align-items: center;\n      margin-bottom: 5px;\n    }\n\n    .legend-color {\n      width: 20px;\n      height: 20px;\n      margin-right: 10px;\n      border: 1px solid #ccc;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"controls\">\n    <button id=\"zoom-in\">Zoom In</button>\n    <button id=\"zoom-out\">Zoom Out</button>\n    <button id=\"reset\">Reset</button>\n    <input type=\"text\" id=\"search\" placeholder=\"Search nodes...\">\n  </div>\n\n  <div class=\"view-toggle\">\n    ${viewToggleButtonsHtml}\n  </div>\n\n  <div id=\"graph-container\"></div>\n  <div class=\"tooltip\" id=\"tooltip\"></div>\n\n  <div id=\"duplicate-legend\" class=\"legend\">\n    <h3>Duplicate Score</h3>\n    <div class=\"legend-item\">\n      <div class=\"legend-color\" style=\"background-color: #ffffff;\"></div>\n      <span>Score 1 (Low duplication)</span>\n    </div>\n    <div class=\"legend-item\">\n      <div class=\"legend-color\" style=\"background-color: #ffcccc;\"></div>\n      <span>Score 2</span>\n    </div>\n    <div class=\"legend-item\">\n      <div class=\"legend-color\" style=\"background-color: #ff9999;\"></div>\n      <span>Score 3</span>\n    </div>\n    <div class=\"legend-item\">\n      <div class=\"legend-color\" style=\"background-color: #ff6666;\"></div>\n      <span>Score 4</span>\n    </div>\n    <div class=\"legend-item\">\n      <div class=\"legend-color\" style=\"background-color: #cc0000;\"></div>\n      <span>Score 5 (High duplication)</span>\n    </div>\n  </div>\n  \n  <script>\n    // Graph data\n    const graphData = ${JSON.stringify(graphData)};\n    \n    // Setup\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    \n    // Current view mode\n    let currentView = 'dependency';\n    \n    // Create a color scale based on node type\n    const typeColorMap = {\n      'function': '#4285F4',\n      'class': '#EA4335',\n      'interface': '#FBBC05',\n      'type': '#34A853',\n      'variable': '#8F00FF',\n      'method': '#00ACC1',\n      'enum': '#FF6D00',\n      'other': '#757575'\n    };\n\n    // Create a color scale for duplicate scores\n    const duplicateColorScale = d3.scaleLinear()\n      .domain([1, 5])\n      .range(['#ffffff', '#cc0000'])\n      .clamp(true);\n    \n    // Debug: Log number of nodes with duplicate scores\n    console.log('Nodes with duplicate scores:', graphData.nodes.filter(n => n.duplicateScore !== undefined).length);\n    console.log('Total nodes:', graphData.nodes.length);\n    console.log('Has duplicate analysis:', graphData.hasDuplicateAnalysis);\n    \n    // Create SVG\n    const svg = d3.select('#graph-container')\n      .append('svg')\n      .attr('width', width)\n      .attr('height', height);\n    \n    // Add zoom behavior\n    const zoom = d3.zoom()\n      .scaleExtent([0.1, 4])\n      .on('zoom', (event) => {\n        container.attr('transform', event.transform);\n      });\n    \n    svg.call(zoom);\n    \n    const container = svg.append('g');\n    \n    // Create force simulation\n    const simulation = d3.forceSimulation(graphData.nodes)\n      .force('link', d3.forceLink(graphData.edges)\n        .id(d => d.id)\n        .distance(100))\n      .force('charge', d3.forceManyBody().strength(-300))\n      .force('center', d3.forceCenter(width / 2, height / 2))\n      .force('collision', d3.forceCollide().radius(30));\n    \n    // Create links\n    const link = container.append('g')\n      .selectAll('line')\n      .data(graphData.edges)\n      .enter()\n      .append('line')\n      .attr('class', 'link')\n      .attr('stroke', '#999')\n      .attr('stroke-width', 1);\n    \n    // Create nodes\n    const node = container.append('g')\n      .selectAll('.node')\n      .data(graphData.nodes)\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .call(d3.drag()\n        .on('start', dragstarted)\n        .on('drag', dragged)\n        .on('end', dragended));\n    \n    // Add circles to nodes\n    const circles = node.append('circle')\n      .attr('r', 8)\n      .attr('fill', d => getNodeColor(d, currentView))\n      .on('mouseover', showTooltip)\n      .on('mouseout', hideTooltip);\n    \n    // Add labels to nodes\n    node.append('text')\n      .attr('dx', 12)\n      .attr('dy', '.35em')\n      .text(d => d.label);\n\n    // Function to get node color based on current view\n    function getNodeColor(d, view) {\n      if (view === 'duplicate' && d.duplicateScore !== undefined) {\n        // Debug score to color mapping\n        const color = duplicateColorScale(d.duplicateScore);\n        console.log('Node:', d.label, 'Score:', d.duplicateScore, 'Color:', color);\n        return color;\n      } else {\n        return typeColorMap[d.type] || typeColorMap.other;\n      }\n    }\n    \n    // Tooltip functionality\n    function showTooltip(event, d) {\n      const tooltip = d3.select('#tooltip');\n      let content = \\`\n        <strong>Name:</strong> \\${d.label}<br>\n        <strong>Type:</strong> \\${d.type}<br>\n        <strong>File:</strong> \\${d.filePath}\n      \\`;\n      \n      if (d.duplicateScore !== undefined) {\n        content += \\`<br><strong>Duplicate Score:</strong> \\${d.duplicateScore}\\`;\n      }\n      \n      tooltip.style('display', 'block')\n        .html(content)\n        .style('left', (event.pageX + 10) + 'px')\n        .style('top', (event.pageY + 10) + 'px');\n    }\n    \n    function hideTooltip() {\n      d3.select('#tooltip').style('display', 'none');\n    }\n    \n    // Update positions on simulation tick\n    simulation.on('tick', () => {\n      link\n        .attr('x1', d => d.source.x)\n        .attr('y1', d => d.source.y)\n        .attr('x2', d => d.target.x)\n        .attr('y2', d => d.target.y);\n      \n      node.attr('transform', d => \\`translate(\\${d.x}, \\${d.y})\\`);\n    });\n    \n    // Drag functions\n    function dragstarted(event, d) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      d.fx = d.x;\n      d.fy = d.y;\n    }\n    \n    function dragged(event, d) {\n      d.fx = event.x;\n      d.fy = event.y;\n    }\n    \n    function dragended(event, d) {\n      if (!event.active) simulation.alphaTarget(0);\n      d.fx = null;\n      d.fy = null;\n    }\n    \n    // Controls\n    d3.select('#zoom-in').on('click', () => {\n      svg.transition().call(zoom.scaleBy, 1.2);\n    });\n    \n    d3.select('#zoom-out').on('click', () => {\n      svg.transition().call(zoom.scaleBy, 0.8);\n    });\n    \n    d3.select('#reset').on('click', () => {\n      svg.transition().call(zoom.transform, d3.zoomIdentity);\n    });\n    \n    // View toggle buttons\n    d3.select('#dependency-view').on('click', function() {\n      if (currentView !== 'dependency') {\n        currentView = 'dependency';\n        updateViewMode();\n      }\n    });\n\n    if (graphData.hasDuplicateAnalysis) {\n      d3.select('#duplicate-view').on('click', function() {\n        if (currentView !== 'duplicate') {\n          currentView = 'duplicate';\n          updateViewMode();\n        }\n      });\n    }\n\n    function updateViewMode() {\n      console.log('Updating view mode to:', currentView);\n      \n      // Update button states\n      d3.select('#dependency-view').classed('active', currentView === 'dependency');\n      d3.select('#duplicate-view').classed('active', currentView === 'duplicate');\n      \n      // Update node colors - force reapplication of colors\n      circles.attr('fill', d => getNodeColor(d, currentView));\n      \n      // Show/hide duplicate legend\n      d3.select('#duplicate-legend').classed('show', currentView === 'duplicate');\n    }\n    \n    d3.select('#search').on('input', function() {\n      const term = this.value.toLowerCase();\n      \n      // Reset all nodes and links\n      node.classed('highlight', false)\n        .select('circle')\n        .attr('r', 8)\n        .attr('fill', d => getNodeColor(d, currentView));\n      \n      link.attr('stroke', '#999').attr('stroke-width', 1);\n      \n      if (term) {\n        // Highlight matching nodes\n        const matchingNodes = graphData.nodes.filter(n => \n          n.label.toLowerCase().includes(term) || \n          n.filePath.toLowerCase().includes(term)\n        ).map(n => n.id);\n        \n        node.filter(d => matchingNodes.includes(d.id))\n          .classed('highlight', true)\n          .select('circle')\n          .attr('r', 12)\n          .attr('fill', d => {\n            const baseColor = getNodeColor(d, currentView);\n            return d3.color(baseColor).brighter(0.5);\n          });\n      }\n    });\n    \n    // Resize handler\n    window.addEventListener('resize', () => {\n      svg.attr('width', window.innerWidth).attr('height', window.innerHeight);\n      simulation.force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));\n      simulation.restart();\n    });\n  </script>\n</body>\n</html>\n`;\n  },\n\n  /**\n   * Gets the path to save the generated HTML file\n   * @param rootPath - The workspace root path\n   * @returns The path for the visualization HTML\n   */\n  getVisualizationPath(rootPath: string): string {\n    const dirPath = path.join(rootPath, '.cursortest');\n    return path.join(dirPath, 'dependency-graph.html');\n  },\n\n  /**\n   * Generates and saves the dependency graph visualization\n   * @param rootPath - The workspace root path\n   * @returns Promise that resolves when the visualization is saved\n   */\n  async generateVisualization(rootPath: string): Promise<string> {\n    let graphData: GraphData;\n    \n    // First try to read the merged JSON with scores\n    const mergedJson = await this.readMergedJsonData(rootPath);\n    \n    if (mergedJson) {\n      console.log('Using merged JSON with scores for visualization');\n      graphData = this.createGraphDataFromMergedJson(mergedJson);\n    } else {\n      // Fall back to the original approach\n      console.log('Falling back to original symbol index and duplicate analysis');\n      \n      // Read the symbol index\n      const symbolIndex = await SymbolIndexService.readSymbolIndex(rootPath);\n      \n      if (!symbolIndex) {\n        throw new Error('Symbol index not found. Run \"Build Symbol Index\" command first.');\n      }\n      \n      // Read duplicate analysis data if available\n      const duplicateAnalysisData = await this.readDuplicateAnalysisData(rootPath);\n      \n      // Create graph data\n      graphData = this.createGraphData(symbolIndex, duplicateAnalysisData);\n    }\n    \n    // Add a duplicate view button only if we have duplicate analysis\n    if (graphData.hasDuplicateAnalysis) {\n      console.log('Duplicate analysis data found, adding duplicate view button');\n    }\n    \n    // Generate HTML content\n    const htmlContent = this.createVisualizationHtml(graphData);\n    \n    // Ensure directory exists\n    const visualizationPath = this.getVisualizationPath(rootPath);\n    await fs.ensureDir(path.dirname(visualizationPath));\n    \n    // Write HTML file\n    await fs.writeFile(visualizationPath, htmlContent, 'utf8');\n    \n    return visualizationPath;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "nodes",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 55,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "nodes: GraphNode[] = []",
      "dependents": [
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 32,
          "contextSnippet": " * Interface for graph data\n */\nexport interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 83,
          "contextSnippet": "            node.duplicateScore = duplicateAnalysisData[symbol.filePath];\n          }\n          \n          nodes.push(node);\n        }\n        \n        // Process dependencies"
        }
      ],
      "depends_on": []
    },
    {
      "name": "edges",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 56,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "edges: GraphEdge[] = []",
      "dependents": [
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 33,
          "contextSnippet": " */\nexport interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}\n"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 93,
          "contextSnippet": "          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: nodeId,\n              target: targetId,\n              type: 'dependency'"
        }
      ],
      "depends_on": []
    },
    {
      "name": "nodeIds",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 57,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "nodeIds = new Set<string>()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 68,
          "contextSnippet": "        const nodeId = `${symbol.filePath}:${symbol.name}`;\n        \n        // Add node if it doesn't already exist\n        if (!nodeIds.has(nodeId)) {\n          nodeIds.add(nodeId);\n          \n          const node: GraphNode = {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "edgeMap",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 58,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "edgeMap = new Map<string, boolean>()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 91,
          "contextSnippet": "          const targetId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${nodeId}->${targetId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: nodeId,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "hasDuplicateAnalysis",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 59,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "hasDuplicateAnalysis = !!duplicateAnalysisData && Object.keys(duplicateAnalysisData).length > 0",
      "dependents": [
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 34,
          "contextSnippet": "export interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  hasDuplicateAnalysis: boolean;\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 79,
          "contextSnippet": "          };\n          \n          // Add duplicate score if available\n          if (hasDuplicateAnalysis && duplicateAnalysisData?.[symbol.filePath]) {\n            node.duplicateScore = duplicateAnalysisData[symbol.filePath];\n          }\n          "
        }
      ],
      "depends_on": []
    },
    {
      "name": "nodeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 65,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "nodeId = `${symbol.filePath}:${symbol.name}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 68,
          "contextSnippet": "        const nodeId = `${symbol.filePath}:${symbol.name}`;\n        \n        // Add node if it doesn't already exist\n        if (!nodeIds.has(nodeId)) {\n          nodeIds.add(nodeId);\n          \n          const node: GraphNode = {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "node",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 71,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "node: GraphNode = {\n            id: nodeId,\n            label: symbol.name,\n            type: symbol.type,\n            filePath: symbol.filePath\n          }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 80,
          "contextSnippet": "          \n          // Add duplicate score if available\n          if (hasDuplicateAnalysis && duplicateAnalysisData?.[symbol.filePath]) {\n            node.duplicateScore = duplicateAnalysisData[symbol.filePath];\n          }\n          \n          nodes.push(node);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "targetId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 88,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "targetId = `${dep.filePath}:${dep.name}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 89,
          "contextSnippet": "        // Process dependencies\n        symbol.depends_on.forEach(dep => {\n          const targetId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${nodeId}->${targetId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "edgeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 89,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "edgeId = `${nodeId}->${targetId}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 91,
          "contextSnippet": "          const targetId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${nodeId}->${targetId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);\n            edges.push({\n              source: nodeId,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sourceId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 103,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "sourceId = `${dep.filePath}:${dep.name}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 104,
          "contextSnippet": "        // Process dependents\n        symbol.dependents.forEach(dep => {\n          const sourceId = `${dep.filePath}:${dep.name}`;\n          const edgeId = `${sourceId}->${nodeId}`;\n          \n          if (!edgeMap.has(edgeId)) {\n            edgeMap.set(edgeId, true);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "edgeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 104,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "edgeId = `${sourceId}->${nodeId}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "analysisPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 128,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "analysisPath = path.join(rootPath, '.cursortest', 'duplicate-analysis.json')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 130,
          "contextSnippet": "    try {\n      const analysisPath = path.join(rootPath, '.cursortest', 'duplicate-analysis.json');\n      \n      if (await fs.pathExists(analysisPath)) {\n        const content = await fs.readFile(analysisPath, 'utf8');\n        return JSON.parse(content) as DuplicateAnalysisData;\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 131,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "content = await fs.readFile(analysisPath, 'utf8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 132,
          "contextSnippet": "      \n      if (await fs.pathExists(analysisPath)) {\n        const content = await fs.readFile(analysisPath, 'utf8');\n        return JSON.parse(content) as DuplicateAnalysisData;\n      }\n      \n      return undefined;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedJsonPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 149,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "mergedJsonPath = path.join(rootPath, '.cursortest', 'merged-json-for-viz.json')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 151,
          "contextSnippet": "    try {\n      const mergedJsonPath = path.join(rootPath, '.cursortest', 'merged-json-for-viz.json');\n      \n      if (await fs.pathExists(mergedJsonPath)) {\n        console.log(`Found merged JSON at ${mergedJsonPath}`);\n        const content = await fs.readFile(mergedJsonPath, 'utf8');\n        return JSON.parse(content) as SymbolIndexWithScores;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 153,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "content = await fs.readFile(mergedJsonPath, 'utf8')",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "nodes",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 171,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "nodes: GraphNode[] = []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "edges",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 172,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "edges: GraphEdge[] = []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "nodeIds",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 173,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "nodeIds = new Set<string>()",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "edgeMap",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 174,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "edgeMap = new Map<string, boolean>()",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "hasDuplicateAnalysis",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 175,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "hasDuplicateAnalysis = Object.values(mergedJson).some(fileSymbols => \n      fileSymbols.some(symbol => symbol.scores?.some(score => score.type === 'duplicateAnalysis'))\n    )",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "nodeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 183,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "nodeId = `${symbol.filePath}:${symbol.name}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "node",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 189,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "node: GraphNode = {\n            id: nodeId,\n            label: symbol.name,\n            type: symbol.type,\n            filePath: symbol.filePath\n          }",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "duplicateScore",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 197,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "duplicateScore = symbol.scores?.find(score => score.type === 'duplicateAnalysis')",
      "dependents": [
        {
          "name": "GraphNode",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 16,
          "contextSnippet": "  label: string;\n  type: string;\n  filePath: string;\n  duplicateScore?: number;\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 80,
          "contextSnippet": "          \n          // Add duplicate score if available\n          if (hasDuplicateAnalysis && duplicateAnalysisData?.[symbol.filePath]) {\n            node.duplicateScore = duplicateAnalysisData[symbol.filePath];\n          }\n          \n          nodes.push(node);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "targetId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 207,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "targetId = `${dep.filePath}:${dep.name}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "edgeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 208,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "edgeId = `${nodeId}->${targetId}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "sourceId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 222,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "sourceId = `${dep.filePath}:${dep.name}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "edgeId",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 223,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "edgeId = `${sourceId}->${nodeId}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "viewToggleButtonsHtml",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 247,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "viewToggleButtonsHtml = graphData.hasDuplicateAnalysis \n      ? `\n    <span>View: </span>\n    <button id=\"dependency-view\" class=\"active\">Dependency</button>\n    <button id=\"duplicate-view\">Duplicate</button>\n    `\n      : `\n    <span>View: </span>\n    <button id=\"dependency-view\" class=\"active\">Dependency</button>\n    `",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 381,
          "contextSnippet": "  </div>\n\n  <div class=\"view-toggle\">\n    ${viewToggleButtonsHtml}\n  </div>\n\n  <div id=\"graph-container\"></div>"
        }
      ],
      "depends_on": []
    },
    {
      "name": "dirPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 661,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "dirPath = path.join(rootPath, '.cursortest')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 662,
          "contextSnippet": "   */\n  getVisualizationPath(rootPath: string): string {\n    const dirPath = path.join(rootPath, '.cursortest');\n    return path.join(dirPath, 'dependency-graph.html');\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "graphData",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 671,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "graphData: GraphData",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 247,
          "contextSnippet": "   */\n  createVisualizationHtml(graphData: GraphData): string {\n    // Build the view toggle buttons HTML - only include duplicate view button if we have duplicate analysis data\n    const viewToggleButtonsHtml = graphData.hasDuplicateAnalysis \n      ? `\n    <span>View: </span>\n    <button id=\"dependency-view\" class=\"active\">Dependency</button>"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedJson",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 674,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "mergedJson = await this.readMergedJsonData(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 175,
          "contextSnippet": "    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();\n    const hasDuplicateAnalysis = Object.values(mergedJson).some(fileSymbols => \n      fileSymbols.some(symbol => symbol.scores?.some(score => score.type === 'duplicateAnalysis'))\n    );\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 684,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await SymbolIndexService.readSymbolIndex(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 62,
          "contextSnippet": "    const hasDuplicateAnalysis = !!duplicateAnalysisData && Object.keys(duplicateAnalysisData).length > 0;\n    \n    // Process all symbols in the index\n    Object.values(symbolIndex).forEach(fileSymbols => {\n      fileSymbols.forEach(symbol => {\n        // Create a unique ID for the symbol\n        const nodeId = `${symbol.filePath}:${symbol.name}`;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "duplicateAnalysisData",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 691,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "duplicateAnalysisData = await this.readDuplicateAnalysisData(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 59,
          "contextSnippet": "    const edges: GraphEdge[] = [];\n    const nodeIds = new Set<string>();\n    const edgeMap = new Map<string, boolean>();\n    const hasDuplicateAnalysis = !!duplicateAnalysisData && Object.keys(duplicateAnalysisData).length > 0;\n    \n    // Process all symbols in the index\n    Object.values(symbolIndex).forEach(fileSymbols => {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "htmlContent",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 703,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "htmlContent = this.createVisualizationHtml(graphData)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 710,
          "contextSnippet": "    await fs.ensureDir(path.dirname(visualizationPath));\n    \n    // Write HTML file\n    await fs.writeFile(visualizationPath, htmlContent, 'utf8');\n    \n    return visualizationPath;\n  }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "visualizationPath",
      "type": "variable",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 706,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "visualizationPath = this.getVisualizationPath(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 707,
          "contextSnippet": "    \n    // Ensure directory exists\n    const visualizationPath = this.getVisualizationPath(rootPath);\n    await fs.ensureDir(path.dirname(visualizationPath));\n    \n    // Write HTML file\n    await fs.writeFile(visualizationPath, htmlContent, 'utf8');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "DuplicateAnalysisData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 54
        },
        {
          "name": "GraphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 54
        },
        {
          "name": "GraphNode",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 55
        },
        {
          "name": "GraphEdge",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 56
        },
        {
          "name": "duplicateAnalysisData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 59
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 62
        },
        {
          "name": "nodeIds",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 68
        },
        {
          "name": "nodeId",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 68
        },
        {
          "name": "hasDuplicateAnalysis",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 79
        },
        {
          "name": "node",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 80
        },
        {
          "name": "duplicateScore",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 80
        },
        {
          "name": "nodes",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 83
        },
        {
          "name": "targetId",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 89
        },
        {
          "name": "edgeMap",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 91
        },
        {
          "name": "edgeId",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 91
        },
        {
          "name": "edges",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 93
        },
        {
          "name": "sourceId",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 104
        },
        {
          "name": "analysisPath",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 130
        },
        {
          "name": "content",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 132
        },
        {
          "name": "mergedJsonPath",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 151
        },
        {
          "name": "mergedJson",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 175
        },
        {
          "name": "graphData",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 247
        },
        {
          "name": "viewToggleButtonsHtml",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 381
        },
        {
          "name": "dirPath",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 662
        },
        {
          "name": "visualizationPath",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 707
        },
        {
          "name": "htmlContent",
          "filePath": "src/features/dependency-graph/dependency-graph-service.ts",
          "line": 710
        }
      ]
    }
  ],
  "src/features/docstring-analyzer/codebase-context-generator.ts": [
    {
      "name": "CODEBASE_CONTEXT_FILENAME",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 8,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "CODEBASE_CONTEXT_FILENAME = 'codebase-context.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 56,
          "contextSnippet": "   * @returns The path to the codebase context file\n   */\n  getCodebaseContextPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', CODEBASE_CONTEXT_FILENAME);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "CodebaseContextEntry",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 13,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface CodebaseContextEntry {\n  /**\n   * Name of the symbol\n   */\n  name: string;\n\n  /**\n   * Type of the symbol\n   */\n  type: 'function' | 'class' | 'interface' | 'type' | 'variable' | 'method' | 'enum' | 'other';\n\n  /**\n   * Path to the file containing the symbol\n   */\n  filePath: string;\n\n  /**\n   * Generated docstring for the symbol\n   */\n  docstring: string;\n}",
      "dependents": [
        {
          "name": "CodebaseContext",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 43,
          "contextSnippet": "  /**\n   * Map of file paths to arrays of streamlined symbol entries\n   */\n  [filePath: string]: CodebaseContextEntry[];\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 64,
          "contextSnippet": "   * @param entry - The symbol index entry\n   * @returns The streamlined context entry\n   */\n  convertToContextEntry(entry: SymbolIndexEntry): CodebaseContextEntry {\n    return {\n      name: entry.name,\n      type: entry.type,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "CodebaseContext",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 39,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface CodebaseContext {\n  /**\n   * Map of file paths to arrays of streamlined symbol entries\n   */\n  [filePath: string]: CodebaseContextEntry[];\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 78,
          "contextSnippet": "   * @param symbolIndex - The full symbol index\n   * @returns The streamlined codebase context\n   */\n  convertToCodebaseContext(symbolIndex: SymbolIndex): CodebaseContext {\n    const codebaseContext: CodebaseContext = {};\n    \n    for (const [filePath, entries] of Object.entries(symbolIndex)) {"
        }
      ],
      "depends_on": [
        {
          "name": "CodebaseContextEntry",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 43
        }
      ]
    },
    {
      "name": "CodebaseContextService",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 49,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "CodebaseContextService = {\n  /**\n   * Gets the path to the codebase context file\n   * @param rootPath - The workspace root path\n   * @returns The path to the codebase context file\n   */\n  getCodebaseContextPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', CODEBASE_CONTEXT_FILENAME);\n  },\n\n  /**\n   * Converts a symbol index entry to a streamlined context entry\n   * @param entry - The symbol index entry\n   * @returns The streamlined context entry\n   */\n  convertToContextEntry(entry: SymbolIndexEntry): CodebaseContextEntry {\n    return {\n      name: entry.name,\n      type: entry.type,\n      filePath: entry.filePath,\n      docstring: entry.docstring\n    };\n  },\n\n  /**\n   * Converts a full symbol index to a streamlined codebase context\n   * @param symbolIndex - The full symbol index\n   * @returns The streamlined codebase context\n   */\n  convertToCodebaseContext(symbolIndex: SymbolIndex): CodebaseContext {\n    const codebaseContext: CodebaseContext = {};\n    \n    for (const [filePath, entries] of Object.entries(symbolIndex)) {\n      codebaseContext[filePath] = entries.map(entry => this.convertToContextEntry(entry));\n    }\n    \n    return codebaseContext;\n  },\n\n  /**\n   * Generates the codebase context from the symbol index\n   * @param rootPath - The workspace root path\n   * @returns The streamlined codebase context\n   */\n  async generateCodebaseContext(rootPath: string): Promise<CodebaseContext> {\n    // Read the symbol index\n    const symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath,\n      'Symbol index not found. Please build it first using the \"Build Symbol Index\" command.'\n    );\n    \n    // Convert it to a streamlined context\n    return this.convertToCodebaseContext(symbolIndex);\n  },\n\n  /**\n   * Writes the codebase context to disk\n   * @param rootPath - The workspace root path\n   * @param codebaseContext - The codebase context to write\n   * @returns The path to the written file\n   */\n  async writeCodebaseContext(rootPath: string, codebaseContext: CodebaseContext): Promise<string> {\n    return WorkspaceService.writeCursorTestFile(rootPath, CODEBASE_CONTEXT_FILENAME, codebaseContext);\n  },\n\n  /**\n   * Generates and writes the codebase context\n   * @param rootPath - The workspace root path\n   * @returns The path to the written file\n   */\n  async generateAndWriteCodebaseContext(rootPath: string): Promise<string> {\n    const codebaseContext = await this.generateCodebaseContext(rootPath);\n    return this.writeCodebaseContext(rootPath, codebaseContext);\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "codebaseContext",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 79,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "codebaseContext: CodebaseContext = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 82,
          "contextSnippet": "    const codebaseContext: CodebaseContext = {};\n    \n    for (const [filePath, entries] of Object.entries(symbolIndex)) {\n      codebaseContext[filePath] = entries.map(entry => this.convertToContextEntry(entry));\n    }\n    \n    return codebaseContext;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 95,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath,\n      'Symbol index not found. Please build it first using the \"Build Symbol Index\" command.'\n    )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 81,
          "contextSnippet": "  convertToCodebaseContext(symbolIndex: SymbolIndex): CodebaseContext {\n    const codebaseContext: CodebaseContext = {};\n    \n    for (const [filePath, entries] of Object.entries(symbolIndex)) {\n      codebaseContext[filePath] = entries.map(entry => this.convertToContextEntry(entry));\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "codebaseContext",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 120,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "codebaseContext = await this.generateCodebaseContext(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "CODEBASE_CONTEXT_FILENAME",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 56
        },
        {
          "name": "CodebaseContextEntry",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 64
        },
        {
          "name": "CodebaseContext",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 78
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 81
        },
        {
          "name": "codebaseContext",
          "filePath": "src/features/docstring-analyzer/codebase-context-generator.ts",
          "line": 82
        }
      ]
    }
  ],
  "src/features/docstring-analyzer/duplicate-logic-analyzer.ts": [
    {
      "name": "DUPLICATE_ANALYSIS_FILENAME",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 11,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DUPLICATE_ANALYSIS_FILENAME = 'duplicate-analysis.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 126,
          "contextSnippet": "   * @returns The path to the duplicate analysis file\n   */\n  getDuplicateAnalysisPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', DUPLICATE_ANALYSIS_FILENAME);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DUPLICATE_ANALYSIS_TYPE_FILENAME",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 12,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DUPLICATE_ANALYSIS_TYPE_FILENAME = 'duplicate-analysis-{type}.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 136,
          "contextSnippet": "   * @returns The path to the type-specific duplicate analysis file\n   */\n  getTypeSpecificAnalysisPath(rootPath: string, type: string): string {\n    const filename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', type);\n    return path.join(rootPath, '.cursortest', filename);\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "O3_MINI_MODEL",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 14,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "O3_MINI_MODEL = 'o3-mini'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 264,
          "contextSnippet": "          try {\n            // First try the beta.chat.completions.parse method\n            const completion = await client.beta.chat.completions.parse({\n              model: O3_MINI_MODEL,\n              messages: [\n                { \n                  role: 'system', "
        }
      ],
      "depends_on": []
    },
    {
      "name": "DuplicateLogicResult",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 19,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DuplicateLogicResult {\n  /**\n   * The filepath of the analyzed construct\n   */\n  filePath: string;\n  \n  /**\n   * The name of the analyzed construct\n   */\n  name: string;\n  \n  /**\n   * The type of the analyzed construct\n   */\n  type: string;\n  \n  /**\n   * The duplication score (1-5)\n   * 1 = Very unlikely to be duplicated\n   * 5 = Very likely to be duplicated\n   */\n  score: number;\n  \n  /**\n   * The filepath of the most likely duplicate (if score is 3, 4, or 5)\n   */\n  duplicateFilePath?: string;\n  \n  /**\n   * The name of the most likely duplicate (if score is 3, 4, or 5)\n   */\n  duplicateName?: string;\n}",
      "dependents": [
        {
          "name": "DuplicateLogicOutput",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 60,
          "contextSnippet": "  /**\n   * Array of duplicate logic analysis results\n   */\n  results: DuplicateLogicResult[];\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 357,
          "contextSnippet": "          console.warn('Creating fallback results after exhausting retries');\n          \n          // Generate a basic result for each entry with conservative scores\n          const fallbackResults: DuplicateLogicResult[] = entries.map(entry => ({\n            filePath: entry.filePath,\n            name: entry.name,\n            type: entry.type,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DuplicateLogicOutput",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 56,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DuplicateLogicOutput {\n  /**\n   * Array of duplicate logic analysis results\n   */\n  results: DuplicateLogicResult[];\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 248,
          "contextSnippet": "    prompt: string,\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<DuplicateLogicOutput> {\n    const entryCount = entries.length;\n    \n    // Enhanced retry config with more attempts for larger datasets"
        }
      ],
      "depends_on": [
        {
          "name": "results",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 60
        },
        {
          "name": "DuplicateLogicResult",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 60
        }
      ]
    },
    {
      "name": "DuplicateLogicResultSchema",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 66,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DuplicateLogicResultSchema = z.object({\n  filePath: z.string().describe('The filepath of the analyzed construct'),\n  name: z.string().describe('The name of the analyzed construct'),\n  type: z.string().describe('The type of the analyzed construct'),\n  score: z.number().describe('Duplication score (1-5) where 1 is unlikely and 5 is very likely duplicated'),\n  duplicateFilePath: z.string().optional().describe('The filepath of the most likely duplicate construct'),\n  duplicateName: z.string().optional().describe('The name of the most likely duplicate construct')\n})",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 79,
          "contextSnippet": " * Zod schema for the duplicate logic analysis output\n */\nconst DuplicateLogicOutputSchema = z.object({\n  results: z.array(DuplicateLogicResultSchema).describe('Array of duplicate logic analysis results')\n});\n\n/**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DuplicateLogicOutputSchema",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 78,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DuplicateLogicOutputSchema = z.object({\n  results: z.array(DuplicateLogicResultSchema).describe('Array of duplicate logic analysis results')\n})",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 272,
          "contextSnippet": "                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DuplicateLogicOutputSchema, \"response\"),\n            });\n\n            // Extract the parsed result which is already validated against the schema"
        }
      ],
      "depends_on": []
    },
    {
      "name": "TypeGroupedEntries",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 85,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface TypeGroupedEntries {\n  [type: string]: {\n    filePath: string;\n    name: string;\n    type: string;\n    docstring: string;\n  }[];\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 161,
          "contextSnippet": "   * @param codebaseContext - The codebase context to group\n   * @returns The entries grouped by type\n   */\n  groupEntriesByType(codebaseContext: CodebaseContext): TypeGroupedEntries {\n    const groupedEntries: TypeGroupedEntries = {};\n    \n    for (const [filePath, entries] of Object.entries(codebaseContext)) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "RetryConfig",
      "type": "interface",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 97,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface RetryConfig {\n  maxRetries: number;\n  initialDelayMs: number;\n  backoffFactor: number;\n  maxDelayMs: number;\n  verbose: boolean;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 108,
          "contextSnippet": "/**\n * Default retry configuration\n */\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  backoffFactor: 2,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DEFAULT_RETRY_CONFIG",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 108,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  backoffFactor: 2,\n  maxDelayMs: 10000,\n  verbose: true\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 247,
          "contextSnippet": "    client: OpenAI, \n    prompt: string,\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<DuplicateLogicOutput> {\n    const entryCount = entries.length;\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "DuplicateLogicAnalyzerService",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 119,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "DuplicateLogicAnalyzerService = {\n  /**\n   * Gets the path to the duplicate analysis file\n   * @param rootPath - The workspace root path\n   * @returns The path to the duplicate analysis file\n   */\n  getDuplicateAnalysisPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', DUPLICATE_ANALYSIS_FILENAME);\n  },\n\n  /**\n   * Gets the path to a type-specific duplicate analysis file\n   * @param rootPath - The workspace root path\n   * @param type - The type category (e.g., 'function', 'class')\n   * @returns The path to the type-specific duplicate analysis file\n   */\n  getTypeSpecificAnalysisPath(rootPath: string, type: string): string {\n    const filename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', type);\n    return path.join(rootPath, '.cursortest', filename);\n  },\n\n  /**\n   * Reads the codebase context file\n   * @param rootPath - The workspace root path\n   * @returns The parsed codebase context\n   */\n  async readCodebaseContext(rootPath: string): Promise<CodebaseContext> {\n    const contextPath = path.join(rootPath, '.cursortest', 'codebase-context.json');\n    \n    if (!await fs.pathExists(contextPath)) {\n      throw new Error('Codebase context file not found. Please generate it first using the \"Generate Codebase Context\" command.');\n    }\n    \n    const contextContent = await fs.readFile(contextPath, 'utf-8');\n    return JSON.parse(contextContent) as CodebaseContext;\n  },\n\n  /**\n   * Groups entries by their type for chunked processing\n   * @param codebaseContext - The codebase context to group\n   * @returns The entries grouped by type\n   */\n  groupEntriesByType(codebaseContext: CodebaseContext): TypeGroupedEntries {\n    const groupedEntries: TypeGroupedEntries = {};\n    \n    for (const [filePath, entries] of Object.entries(codebaseContext)) {\n      for (const entry of entries) {\n        if (!groupedEntries[entry.type]) {\n          groupedEntries[entry.type] = [];\n        }\n        \n        groupedEntries[entry.type].push({\n          filePath,\n          name: entry.name,\n          type: entry.type,\n          docstring: entry.docstring\n        });\n      }\n    }\n    \n    return groupedEntries;\n  },\n\n  /**\n   * Formats the code entries for the OpenAI prompt\n   * @param entries - The code entries to format\n   * @returns The formatted entries string\n   */\n  formatEntriesForPrompt(entries: Array<{filePath: string; name: string; type: string; docstring: string}>): string {\n    let formattedEntries = '';\n    \n    for (const entry of entries) {\n      formattedEntries += `\\nFile: ${entry.filePath}\\nName: ${entry.name}\\nType: ${entry.type}\\nDocstring: ${entry.docstring}\\n`;\n    }\n    \n    return formattedEntries;\n  },\n\n  /**\n   * Creates the prompt for the OpenAI model\n   * @param formattedEntries - The formatted code entries\n   * @param typeCategory - The type category being analyzed\n   * @returns The prompt for the OpenAI model\n   */\n  createPrompt(formattedEntries: string, typeCategory: string): string {\n    return `You are tasked with analyzing a codebase for potentially duplicated logic. Below is information about ${typeCategory} in the codebase. Each entry includes the filepath, name, type, and a docstring describing what it does.\n\nYour job is to:\n1. Carefully read and understand each entry\n2. Rate each entry on a scale of 1-5 based on how likely it is to contain logic that is duplicated elsewhere in the codebase:\n   - 1: Very unlikely to be duplicated\n   - 2: Unlikely to be duplicated\n   - 3: Possibly duplicated\n   - 4: Likely duplicated\n   - 5: Very likely duplicated\n3. Identify the name and filepath of the most likely duplicate construct\n\nCODEBASE ${typeCategory.toUpperCase()}:\n${formattedEntries}\n\nIMPORTANT INSTRUCTIONS:\n1. You MUST analyze EVERY single entry provided above. Do not skip any entries.\n2. Return your analysis as a structured JSON output with the \"results\" array containing one object for each entry analyzed.\n3. For each entry, provide:\n   - filePath: The filepath of the analyzed construct (exactly as provided)\n   - name: The name of the analyzed construct (exactly as provided)\n   - type: The type of the analyzed construct (exactly as provided)\n   - score: A number between 1 and 5 (strictly integers, no decimals)\n   - duplicateFilePath: The filepath of the most likely duplicate (include for all entries)\n   - duplicateName: The name of the most likely duplicate (include for all entries)\n   \nIf the score is 1 or 2, you can use empty strings for duplicateFilePath and duplicateName.\n\nThe output format must be a JSON object with a \"results\" array containing EXACTLY one object for EACH entry in the input.`;\n  },\n\n  /**\n   * Safely sends the prompt to the OpenAI API using structured outputs\n   * @param client - The OpenAI client\n   * @param prompt - The prompt to send\n   * @param retryConfig - Configuration for retry behavior\n   * @param entries - The entries being analyzed (for validation)\n   * @returns The parsed structured output\n   */\n  async safeCompletionWithParse(\n    client: OpenAI, \n    prompt: string,\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<DuplicateLogicOutput> {\n    const entryCount = entries.length;\n    \n    // Enhanced retry config with more attempts for larger datasets\n    const enhancedRetryConfig = {\n      ...retryConfig,\n      maxRetries: Math.max(retryConfig.maxRetries, Math.min(5, Math.ceil(entryCount / 20))),\n      verbose: true\n    };\n    \n    try {\n      return await OpenAiService.withRetry(\n        async () => {\n          try {\n            // First try the beta.chat.completions.parse method\n            const completion = await client.beta.chat.completions.parse({\n              model: O3_MINI_MODEL,\n              messages: [\n                { \n                  role: 'system', \n                  content: 'You are an expert code analyzer that identifies potentially duplicated logic in a codebase.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DuplicateLogicOutputSchema, \"response\"),\n            });\n\n            // Extract the parsed result which is already validated against the schema\n            const result = completion.choices[0].message.parsed as DuplicateLogicOutput;\n            \n            // Validate result completeness - check if we have substantially fewer results than entries\n            if (result.results.length < entryCount * 0.9) {\n              console.warn(`Incomplete results detected: Received ${result.results.length} results for ${entryCount} entries`);\n              throw new Error(`Incomplete results: Only ${result.results.length} of ${entryCount} entries were processed`);\n            }\n            \n            return result;\n          } catch (error) {\n            // Handle various error types\n            if (error instanceof Error) {\n              // Check for incomplete results (our custom error)\n              if (error.message.includes('Incomplete results')) {\n                console.warn('Incomplete results detected, retrying with standard completion');\n              }\n              \n              // Check if it's a beta API error\n              else if (\n                error.message.includes('500') || \n                error.message.includes('beta') ||\n                error.message.includes('parse') ||\n                error.message.includes('content_filter')\n              ) {\n                console.warn('Beta API failed, falling back to standard chat completion:', error);\n              } else {\n                // Unexpected error, just log and rethrow\n                console.error('Unexpected error in API call:', error);\n                throw error;\n              }\n              \n              // Try standard completion as fallback\n              const fallbackCompletion = await client.chat.completions.create({\n                model: O3_MINI_MODEL,\n                messages: [\n                  { \n                    role: 'system', \n                    content: 'You are an expert code analyzer that identifies potentially duplicated logic in a codebase. Return ONLY valid JSON matching this schema: ' + JSON.stringify(DuplicateLogicOutputSchema.shape) \n                  },\n                  { role: 'user', content: prompt + '\\n\\nReturn ONLY valid JSON with no explanation.' }\n                ],\n                response_format: { type: \"json_object\" },\n                temperature: 0, // Lower temperature for more consistent results\n              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }\n\n              try {\n                // Parse and validate the JSON response\n                const parsedResult = DuplicateLogicOutputSchema.parse(JSON.parse(content)) as DuplicateLogicOutput;\n                \n                // Validate result completeness\n                if (parsedResult.results.length < entryCount * 0.9) {\n                  console.warn(`Incomplete results from fallback: Received ${parsedResult.results.length} results for ${entryCount} entries`);\n                  throw new Error(`Incomplete results from fallback: Only ${parsedResult.results.length} of ${entryCount} entries were processed`);\n                }\n                \n                return parsedResult;\n              } catch (parseError) {\n                console.error('Failed to parse fallback response:', parseError);\n                throw new Error('Failed to parse response: ' + String(parseError));\n              }\n            }\n            throw error;\n          }\n        },\n        enhancedRetryConfig\n      );\n    } catch (error) {\n      // Check if this error occurred after exhausting retries\n      if (error instanceof Error && (error as any).retriesExhausted) {\n        console.error('All retry attempts failed in safeCompletionWithParse:', error);\n        \n        // Create a fallback with default scores if we absolutely can't get results\n        if (error.message.includes('Incomplete results')) {\n          console.warn('Creating fallback results after exhausting retries');\n          \n          // Generate a basic result for each entry with conservative scores\n          const fallbackResults: DuplicateLogicResult[] = entries.map(entry => ({\n            filePath: entry.filePath,\n            name: entry.name,\n            type: entry.type,\n            score: 1, // Conservative default score\n            // No duplicate info for fallback entries\n          }));\n          \n          return { results: fallbackResults };\n        }\n        \n        // For other errors, just throw\n        const enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`);\n        throw enhancedError;\n      }\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Writes the results to a JSON file\n   * @param rootPath - The workspace root path\n   * @param results - The results to write\n   * @param filename - The filename to use (optional, defaults to DUPLICATE_ANALYSIS_FILENAME)\n   * @returns The path to the written file\n   */\n  async writeResults(rootPath: string, results: DuplicateLogicOutput, filename?: string): Promise<string> {\n    const outputPath = path.join(rootPath, '.cursortest', filename || DUPLICATE_ANALYSIS_FILENAME);\n    \n    // Ensure the directory exists\n    await fs.ensureDir(path.dirname(outputPath));\n    \n    // Write the results as JSON\n    await fs.writeFile(outputPath, JSON.stringify(results, null, 2), 'utf-8');\n    \n    return outputPath;\n  },\n\n  /**\n   * Process a chunk of the codebase (entries of a specific type)\n   * @param client - The OpenAI client\n   * @param entries - The entries to process\n   * @param typeCategory - The type category being processed\n   * @param rootPath - The workspace root path\n   * @param progressCallback - Optional callback for progress reporting\n   * @returns The analysis results for this chunk\n   */\n  async processChunk(\n    client: OpenAI,\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>,\n    typeCategory: string,\n    rootPath: string,\n    progressCallback?: (message: string) => void\n  ): Promise<DuplicateLogicResult[]> {\n    // Format entries for this type\n    const formattedEntries = this.formatEntriesForPrompt(entries);\n    \n    // Create the prompt\n    const prompt = this.createPrompt(formattedEntries, typeCategory);\n    \n    try {\n      // Send to OpenAI with structured output\n      progressCallback?.(`Analyzing ${entries.length} ${typeCategory}s...`);\n      const output = await this.safeCompletionWithParse(client, prompt, entries);\n      \n      // Additional validation of results\n      this.validateResults(output.results, entries);\n      \n      // Write the type-specific results to a separate JSON file\n      const typeSpecificFilename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', typeCategory);\n      const typePath = await this.writeResults(\n        rootPath, \n        output, \n        typeSpecificFilename\n      );\n      \n      progressCallback?.(`Wrote ${output.results.length} ${typeCategory} results to ${typePath}`);\n      \n      return output.results;\n    } catch (error: unknown) {\n      // Log the error\n      console.error(`Error processing ${typeCategory} entries:`, error);\n      progressCallback?.(`Error processing ${typeCategory} entries: ${error instanceof Error ? error.message : String(error)}`);\n      \n      // Create a minimal fallback result for each entry\n      progressCallback?.(`Creating fallback results for ${entries.length} ${typeCategory}s`);\n      const fallbackResults = this.createFallbackResults(entries);\n      \n      // Write the fallback results\n      const typeSpecificFilename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', `${typeCategory}-fallback`);\n      const typePath = await this.writeResults(\n        rootPath, \n        { results: fallbackResults }, \n        typeSpecificFilename\n      );\n      \n      progressCallback?.(`Wrote ${fallbackResults.length} fallback ${typeCategory} results to ${typePath}`);\n      \n      return fallbackResults;\n    }\n  },\n\n  /**\n   * Creates fallback results when API processing fails\n   * @param entries - The entries to create fallback results for\n   * @returns Array of fallback results\n   */\n  createFallbackResults(\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>\n  ): DuplicateLogicResult[] {\n    return entries.map(entry => ({\n      filePath: entry.filePath,\n      name: entry.name,\n      type: entry.type,\n      score: 1, // Conservative default score\n      duplicateFilePath: \"\",\n      duplicateName: \"\",\n    }));\n  },\n\n  /**\n   * Validates the results against the original entries\n   * @param results - The results to validate\n   * @param entries - The original entries\n   * @throws Error if validation fails\n   */\n  validateResults(\n    results: DuplicateLogicResult[],\n    entries: Array<{filePath: string; name: string; type: string; docstring: string}>\n  ): void {\n    // Check if we're missing more than 10% of the entries\n    if (results.length < entries.length * 0.9) {\n      throw new Error(`Incomplete results: Only ${results.length} of ${entries.length} entries were processed`);\n    }\n    \n    // Check for any malformed results\n    const missingFields = results.filter(result => \n      !result.filePath || \n      !result.name || \n      !result.type || \n      typeof result.score !== 'number' ||\n      result.score < 1 || \n      result.score > 5\n    );\n    \n    if (missingFields.length > 0) {\n      console.warn(`Found ${missingFields.length} results with missing or invalid fields`);\n      \n      // Only throw if more than 5% of results are invalid\n      if (missingFields.length > results.length * 0.05) {\n        throw new Error(`Too many malformed results: ${missingFields.length} results have missing or invalid fields`);\n      }\n    }\n  },\n\n  /**\n   * Analyzes the codebase context for duplicate logic, processing by type chunks\n   * @param rootPath - The workspace root path\n   * @param progressCallback - Optional callback for progress reporting\n   * @returns Path to the combined output JSON file\n   */\n  async analyzeDuplicateLogic(\n    rootPath: string, \n    progressCallback?: (message: string) => void\n  ): Promise<string> {\n    // Read the codebase context\n    const codebaseContext = await this.readCodebaseContext(rootPath);\n    \n    // Get environment variables for OpenAI\n    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }\n    \n    // Group entries by type\n    const groupedEntries = this.groupEntriesByType(codebaseContext);\n    \n    // Process each type group\n    progressCallback?.(`Grouped codebase into ${Object.keys(groupedEntries).length} type categories`);\n    \n    const allResults: DuplicateLogicResult[] = [];\n    let processedTypes = 0;\n    \n    for (const [typeCategory, entries] of Object.entries(groupedEntries)) {\n      processedTypes++;\n      progressCallback?.(`Processing ${entries.length} ${typeCategory}s (${processedTypes}/${Object.keys(groupedEntries).length})`);\n      \n      const results = await this.processChunk(client, entries, typeCategory, rootPath, progressCallback);\n      allResults.push(...results);\n      \n      progressCallback?.(`Completed ${typeCategory}s: ${results.length} results`);\n    }\n    \n    // Write the combined results to a file\n    progressCallback?.(`Writing combined results (${allResults.length} entries) to JSON file`);\n    const combinedOutput: DuplicateLogicOutput = { results: allResults };\n    return this.writeResults(rootPath, combinedOutput);\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "filename",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 136,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', type)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 137,
          "contextSnippet": "   */\n  getTypeSpecificAnalysisPath(rootPath: string, type: string): string {\n    const filename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', type);\n    return path.join(rootPath, '.cursortest', filename);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "contextPath",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 146,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "contextPath = path.join(rootPath, '.cursortest', 'codebase-context.json')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 148,
          "contextSnippet": "  async readCodebaseContext(rootPath: string): Promise<CodebaseContext> {\n    const contextPath = path.join(rootPath, '.cursortest', 'codebase-context.json');\n    \n    if (!await fs.pathExists(contextPath)) {\n      throw new Error('Codebase context file not found. Please generate it first using the \"Generate Codebase Context\" command.');\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "contextContent",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 152,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "contextContent = await fs.readFile(contextPath, 'utf-8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 153,
          "contextSnippet": "    }\n    \n    const contextContent = await fs.readFile(contextPath, 'utf-8');\n    return JSON.parse(contextContent) as CodebaseContext;\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "groupedEntries",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 162,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "groupedEntries: TypeGroupedEntries = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 166,
          "contextSnippet": "    \n    for (const [filePath, entries] of Object.entries(codebaseContext)) {\n      for (const entry of entries) {\n        if (!groupedEntries[entry.type]) {\n          groupedEntries[entry.type] = [];\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "formattedEntries",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 188,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "formattedEntries = ''",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 191,
          "contextSnippet": "    let formattedEntries = '';\n    \n    for (const entry of entries) {\n      formattedEntries += `\\nFile: ${entry.filePath}\\nName: ${entry.name}\\nType: ${entry.type}\\nDocstring: ${entry.docstring}\\n`;\n    }\n    \n    return formattedEntries;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "entryCount",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 249,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "entryCount = entries.length",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 254,
          "contextSnippet": "    // Enhanced retry config with more attempts for larger datasets\n    const enhancedRetryConfig = {\n      ...retryConfig,\n      maxRetries: Math.max(retryConfig.maxRetries, Math.min(5, Math.ceil(entryCount / 20))),\n      verbose: true\n    };\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "enhancedRetryConfig",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 252,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "enhancedRetryConfig = {\n      ...retryConfig,\n      maxRetries: Math.max(retryConfig.maxRetries, Math.min(5, Math.ceil(entryCount / 20))),\n      verbose: true\n    }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 345,
          "contextSnippet": "            throw error;\n          }\n        },\n        enhancedRetryConfig\n      );\n    } catch (error) {\n      // Check if this error occurred after exhausting retries"
        }
      ],
      "depends_on": []
    },
    {
      "name": "completion",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 263,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "completion = await client.beta.chat.completions.parse({\n              model: O3_MINI_MODEL,\n              messages: [\n                { \n                  role: 'system', \n                  content: 'You are an expert code analyzer that identifies potentially duplicated logic in a codebase.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DuplicateLogicOutputSchema, \"response\"),\n            })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 276,
          "contextSnippet": "            });\n\n            // Extract the parsed result which is already validated against the schema\n            const result = completion.choices[0].message.parsed as DuplicateLogicOutput;\n            \n            // Validate result completeness - check if we have substantially fewer results than entries\n            if (result.results.length < entryCount * 0.9) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 276,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "result = completion.choices[0].message.parsed as DuplicateLogicOutput",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 279,
          "contextSnippet": "            const result = completion.choices[0].message.parsed as DuplicateLogicOutput;\n            \n            // Validate result completeness - check if we have substantially fewer results than entries\n            if (result.results.length < entryCount * 0.9) {\n              console.warn(`Incomplete results detected: Received ${result.results.length} results for ${entryCount} entries`);\n              throw new Error(`Incomplete results: Only ${result.results.length} of ${entryCount} entries were processed`);\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fallbackCompletion",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 308,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "fallbackCompletion = await client.chat.completions.create({\n                model: O3_MINI_MODEL,\n                messages: [\n                  { \n                    role: 'system', \n                    content: 'You are an expert code analyzer that identifies potentially duplicated logic in a codebase. Return ONLY valid JSON matching this schema: ' + JSON.stringify(DuplicateLogicOutputSchema.shape) \n                  },\n                  { role: 'user', content: prompt + '\\n\\nReturn ONLY valid JSON with no explanation.' }\n                ],\n                response_format: { type: \"json_object\" },\n                temperature: 0, // Lower temperature for more consistent results\n              })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 321,
          "contextSnippet": "                temperature: 0, // Lower temperature for more consistent results\n              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 321,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "content = fallbackCompletion.choices[0].message.content",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 322,
          "contextSnippet": "              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "parsedResult",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 328,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "parsedResult = DuplicateLogicOutputSchema.parse(JSON.parse(content)) as DuplicateLogicOutput",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 331,
          "contextSnippet": "                const parsedResult = DuplicateLogicOutputSchema.parse(JSON.parse(content)) as DuplicateLogicOutput;\n                \n                // Validate result completeness\n                if (parsedResult.results.length < entryCount * 0.9) {\n                  console.warn(`Incomplete results from fallback: Received ${parsedResult.results.length} results for ${entryCount} entries`);\n                  throw new Error(`Incomplete results from fallback: Only ${parsedResult.results.length} of ${entryCount} entries were processed`);\n                }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fallbackResults",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 357,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "fallbackResults: DuplicateLogicResult[] = entries.map(entry => ({\n            filePath: entry.filePath,\n            name: entry.name,\n            type: entry.type,\n            score: 1, // Conservative default score\n            // No duplicate info for fallback entries\n          }))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 365,
          "contextSnippet": "            // No duplicate info for fallback entries\n          }));\n          \n          return { results: fallbackResults };\n        }\n        \n        // For other errors, just throw"
        }
      ],
      "depends_on": []
    },
    {
      "name": "enhancedError",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 369,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 370,
          "contextSnippet": "        \n        // For other errors, just throw\n        const enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`);\n        throw enhancedError;\n      }\n      \n      throw error;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "outputPath",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 385,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "outputPath = path.join(rootPath, '.cursortest', filename || DUPLICATE_ANALYSIS_FILENAME)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 388,
          "contextSnippet": "    const outputPath = path.join(rootPath, '.cursortest', filename || DUPLICATE_ANALYSIS_FILENAME);\n    \n    // Ensure the directory exists\n    await fs.ensureDir(path.dirname(outputPath));\n    \n    // Write the results as JSON\n    await fs.writeFile(outputPath, JSON.stringify(results, null, 2), 'utf-8');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "formattedEntries",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 413,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "formattedEntries = this.formatEntriesForPrompt(entries)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "prompt",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 416,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "prompt = this.createPrompt(formattedEntries, typeCategory)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 270,
          "contextSnippet": "                  role: 'system', \n                  content: 'You are an expert code analyzer that identifies potentially duplicated logic in a codebase.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DuplicateLogicOutputSchema, \"response\"),\n            });"
        }
      ],
      "depends_on": []
    },
    {
      "name": "output",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 421,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "output = await this.safeCompletionWithParse(client, prompt, entries)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 424,
          "contextSnippet": "      const output = await this.safeCompletionWithParse(client, prompt, entries);\n      \n      // Additional validation of results\n      this.validateResults(output.results, entries);\n      \n      // Write the type-specific results to a separate JSON file\n      const typeSpecificFilename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', typeCategory);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "typeSpecificFilename",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 427,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "typeSpecificFilename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', typeCategory)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 431,
          "contextSnippet": "      const typePath = await this.writeResults(\n        rootPath, \n        output, \n        typeSpecificFilename\n      );\n      \n      progressCallback?.(`Wrote ${output.results.length} ${typeCategory} results to ${typePath}`);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "typePath",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 428,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "typePath = await this.writeResults(\n        rootPath, \n        output, \n        typeSpecificFilename\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 434,
          "contextSnippet": "        typeSpecificFilename\n      );\n      \n      progressCallback?.(`Wrote ${output.results.length} ${typeCategory} results to ${typePath}`);\n      \n      return output.results;\n    } catch (error: unknown) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fallbackResults",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 444,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fallbackResults = this.createFallbackResults(entries)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "typeSpecificFilename",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 447,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "typeSpecificFilename = DUPLICATE_ANALYSIS_TYPE_FILENAME.replace('{type}', `${typeCategory}-fallback`)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "typePath",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 448,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "typePath = await this.writeResults(\n        rootPath, \n        { results: fallbackResults }, \n        typeSpecificFilename\n      )",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "missingFields",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 494,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "missingFields = results.filter(result => \n      !result.filePath || \n      !result.name || \n      !result.type || \n      typeof result.score !== 'number' ||\n      result.score < 1 || \n      result.score > 5\n    )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 503,
          "contextSnippet": "      result.score > 5\n    );\n    \n    if (missingFields.length > 0) {\n      console.warn(`Found ${missingFields.length} results with missing or invalid fields`);\n      \n      // Only throw if more than 5% of results are invalid"
        }
      ],
      "depends_on": []
    },
    {
      "name": "codebaseContext",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 524,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "codebaseContext = await this.readCodebaseContext(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 164,
          "contextSnippet": "  groupEntriesByType(codebaseContext: CodebaseContext): TypeGroupedEntries {\n    const groupedEntries: TypeGroupedEntries = {};\n    \n    for (const [filePath, entries] of Object.entries(codebaseContext)) {\n      for (const entry of entries) {\n        if (!groupedEntries[entry.type]) {\n          groupedEntries[entry.type] = [];"
        }
      ],
      "depends_on": []
    },
    {
      "name": "envVars",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 527,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "envVars = OpenAiService.loadEnvironmentVars(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 530,
          "contextSnippet": "    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "client",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 530,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 263,
          "contextSnippet": "        async () => {\n          try {\n            // First try the beta.chat.completions.parse method\n            const completion = await client.beta.chat.completions.parse({\n              model: O3_MINI_MODEL,\n              messages: [\n                { "
        }
      ],
      "depends_on": []
    },
    {
      "name": "groupedEntries",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 536,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "groupedEntries = this.groupEntriesByType(codebaseContext)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "allResults",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 541,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "allResults: DuplicateLogicResult[] = []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 549,
          "contextSnippet": "      progressCallback?.(`Processing ${entries.length} ${typeCategory}s (${processedTypes}/${Object.keys(groupedEntries).length})`);\n      \n      const results = await this.processChunk(client, entries, typeCategory, rootPath, progressCallback);\n      allResults.push(...results);\n      \n      progressCallback?.(`Completed ${typeCategory}s: ${results.length} results`);\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "processedTypes",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 542,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "processedTypes = 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 545,
          "contextSnippet": "    let processedTypes = 0;\n    \n    for (const [typeCategory, entries] of Object.entries(groupedEntries)) {\n      processedTypes++;\n      progressCallback?.(`Processing ${entries.length} ${typeCategory}s (${processedTypes}/${Object.keys(groupedEntries).length})`);\n      \n      const results = await this.processChunk(client, entries, typeCategory, rootPath, progressCallback);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "results",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 548,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "results = await this.processChunk(client, entries, typeCategory, rootPath, progressCallback)",
      "dependents": [
        {
          "name": "DuplicateLogicOutput",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 60,
          "contextSnippet": "  /**\n   * Array of duplicate logic analysis results\n   */\n  results: DuplicateLogicResult[];\n}\n\n/**"
        },
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 279,
          "contextSnippet": "            const result = completion.choices[0].message.parsed as DuplicateLogicOutput;\n            \n            // Validate result completeness - check if we have substantially fewer results than entries\n            if (result.results.length < entryCount * 0.9) {\n              console.warn(`Incomplete results detected: Received ${result.results.length} results for ${entryCount} entries`);\n              throw new Error(`Incomplete results: Only ${result.results.length} of ${entryCount} entries were processed`);\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "combinedOutput",
      "type": "variable",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 556,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "combinedOutput: DuplicateLogicOutput = { results: allResults }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 557,
          "contextSnippet": "    // Write the combined results to a file\n    progressCallback?.(`Writing combined results (${allResults.length} entries) to JSON file`);\n    const combinedOutput: DuplicateLogicOutput = { results: allResults };\n    return this.writeResults(rootPath, combinedOutput);\n  }\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "DuplicateLogicResultSchema",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 79
        },
        {
          "name": "RetryConfig",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 108
        },
        {
          "name": "DUPLICATE_ANALYSIS_FILENAME",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 126
        },
        {
          "name": "DUPLICATE_ANALYSIS_TYPE_FILENAME",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 136
        },
        {
          "name": "filename",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 137
        },
        {
          "name": "contextPath",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 148
        },
        {
          "name": "contextContent",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 153
        },
        {
          "name": "TypeGroupedEntries",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 161
        },
        {
          "name": "codebaseContext",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 164
        },
        {
          "name": "groupedEntries",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 166
        },
        {
          "name": "formattedEntries",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 191
        },
        {
          "name": "DEFAULT_RETRY_CONFIG",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 247
        },
        {
          "name": "DuplicateLogicOutput",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 248
        },
        {
          "name": "entryCount",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 254
        },
        {
          "name": "client",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 263
        },
        {
          "name": "O3_MINI_MODEL",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 264
        },
        {
          "name": "prompt",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 270
        },
        {
          "name": "DuplicateLogicOutputSchema",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 272
        },
        {
          "name": "completion",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 276
        },
        {
          "name": "result",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 279
        },
        {
          "name": "results",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 279
        },
        {
          "name": "fallbackCompletion",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 321
        },
        {
          "name": "content",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 322
        },
        {
          "name": "parsedResult",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 331
        },
        {
          "name": "enhancedRetryConfig",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 345
        },
        {
          "name": "DuplicateLogicResult",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 357
        },
        {
          "name": "fallbackResults",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 365
        },
        {
          "name": "enhancedError",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 370
        },
        {
          "name": "outputPath",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 388
        },
        {
          "name": "output",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 424
        },
        {
          "name": "typeSpecificFilename",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 431
        },
        {
          "name": "typePath",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 434
        },
        {
          "name": "missingFields",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 503
        },
        {
          "name": "envVars",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 530
        },
        {
          "name": "processedTypes",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 545
        },
        {
          "name": "allResults",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 549
        },
        {
          "name": "combinedOutput",
          "filePath": "src/features/docstring-analyzer/duplicate-logic-analyzer.ts",
          "line": 557
        }
      ]
    }
  ],
  "src/features/file-watcher/file-watcher.ts": [
    {
      "name": "setupFileWatcher",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 14,
        "character": 13
      },
      "docstring": "/**\n * Sets up a file system watcher to automatically update project analysis when files change\n * @param context - The extension context for registration\n */",
      "snippet": "setupFileWatcher = (context: vscode.ExtensionContext): void => {\n    const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n    if (!workspaceFolder) {\n        return;\n    }\n\n    const watcher = vscode.workspace.createFileSystemWatcher('**/*', false, false, false);\n    \n    // Shared symbol index state for incremental updates\n    let symbolIndexCache: SymbolIndex | undefined = undefined;\n    \n    // Initialize symbolIndexCache from on-disk file if available\n    const initializeSymbolIndexCache = async () => {\n        try {\n            const onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder);\n            if (onDiskIndex) {\n                symbolIndexCache = onDiskIndex;\n                console.log('Initialized symbol index cache from on-disk file');\n            }\n        } catch (error) {\n            console.error('Error initializing symbol index cache:', error);\n        }\n    };\n    \n    // Debounce to avoid too many updates\n    let debounceTimer: NodeJS.Timeout | null = null;\n    const updateProjectAnalysis = async (changedFile?: string) => {\n        if (debounceTimer) {\n            clearTimeout(debounceTimer);\n        }\n        \n        debounceTimer = setTimeout(async () => {\n            try {\n                // Ensure we have the latest on-disk version before updating when a file changes\n                if (changedFile && !symbolIndexCache) {\n                    await initializeSymbolIndexCache();\n                }\n                \n                // Use the refactored project analysis workflow\n                const result = await ensureProjectAnalysis(workspaceFolder, {\n                    generateDocstrings: false,\n                    showMessages: false,\n                    incremental: !!changedFile && !!symbolIndexCache,\n                    changedFile,\n                    symbolIndexCache\n                });\n                \n                // Update the symbol index cache if successful\n                if (result.success && result.symbolIndex) {\n                    symbolIndexCache = result.symbolIndex;\n                }\n                \n                console.log('Project analysis updated automatically.');\n            } catch (error) {\n                console.error('Error updating project analysis:', error);\n            }\n        }, 1000); // Wait 1 second after the last change\n    };\n    \n    // Watch for file changes\n    watcher.onDidCreate((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidChange((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidDelete((uri) => updateProjectAnalysis(uri.fsPath));\n    \n    // Initialize cache from disk and then generate analysis on startup\n    initializeSymbolIndexCache().then(() => {\n        updateProjectAnalysis();\n    });\n    \n    context.subscriptions.push(watcher);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 16
        },
        {
          "name": "watcher",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 74
        },
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 74
        },
        {
          "name": "initializeSymbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 79
        }
      ]
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 15,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "setupFileWatcher",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 16,
          "contextSnippet": " */\nexport const setupFileWatcher = (context: vscode.ExtensionContext): void => {\n    const workspaceFolder = WorkspaceService.getWorkspaceFolder();\n    if (!workspaceFolder) {\n        return;\n    }\n"
        },
        {
          "name": "initializeSymbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 28,
          "contextSnippet": "    // Initialize symbolIndexCache from on-disk file if available\n    const initializeSymbolIndexCache = async () => {\n        try {\n            const onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder);\n            if (onDiskIndex) {\n                symbolIndexCache = onDiskIndex;\n                console.log('Initialized symbol index cache from on-disk file');"
        },
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 53,
          "contextSnippet": "                }\n                \n                // Use the refactored project analysis workflow\n                const result = await ensureProjectAnalysis(workspaceFolder, {\n                    generateDocstrings: false,\n                    showMessages: false,\n                    incremental: !!changedFile && !!symbolIndexCache,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "watcher",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 20,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "watcher = vscode.workspace.createFileSystemWatcher('**/*', false, false, false)",
      "dependents": [
        {
          "name": "setupFileWatcher",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 74,
          "contextSnippet": "    };\n    \n    // Watch for file changes\n    watcher.onDidCreate((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidChange((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidDelete((uri) => updateProjectAnalysis(uri.fsPath));\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndexCache",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 23,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "symbolIndexCache: SymbolIndex | undefined = undefined",
      "dependents": [
        {
          "name": "initializeSymbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 30,
          "contextSnippet": "        try {\n            const onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder);\n            if (onDiskIndex) {\n                symbolIndexCache = onDiskIndex;\n                console.log('Initialized symbol index cache from on-disk file');\n            }\n        } catch (error) {"
        },
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 48,
          "contextSnippet": "        debounceTimer = setTimeout(async () => {\n            try {\n                // Ensure we have the latest on-disk version before updating when a file changes\n                if (changedFile && !symbolIndexCache) {\n                    await initializeSymbolIndexCache();\n                }\n                "
        }
      ],
      "depends_on": []
    },
    {
      "name": "initializeSymbolIndexCache",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 26,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "initializeSymbolIndexCache = async () => {\n        try {\n            const onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder);\n            if (onDiskIndex) {\n                symbolIndexCache = onDiskIndex;\n                console.log('Initialized symbol index cache from on-disk file');\n            }\n        } catch (error) {\n            console.error('Error initializing symbol index cache:', error);\n        }\n    }",
      "dependents": [
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 49,
          "contextSnippet": "            try {\n                // Ensure we have the latest on-disk version before updating when a file changes\n                if (changedFile && !symbolIndexCache) {\n                    await initializeSymbolIndexCache();\n                }\n                \n                // Use the refactored project analysis workflow"
        },
        {
          "name": "setupFileWatcher",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 79,
          "contextSnippet": "    watcher.onDidDelete((uri) => updateProjectAnalysis(uri.fsPath));\n    \n    // Initialize cache from disk and then generate analysis on startup\n    initializeSymbolIndexCache().then(() => {\n        updateProjectAnalysis();\n    });\n    "
        }
      ],
      "depends_on": [
        {
          "name": "workspaceFolder",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 28
        },
        {
          "name": "onDiskIndex",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 29
        },
        {
          "name": "symbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 30
        }
      ]
    },
    {
      "name": "onDiskIndex",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 28,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder)",
      "dependents": [
        {
          "name": "initializeSymbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 29,
          "contextSnippet": "    const initializeSymbolIndexCache = async () => {\n        try {\n            const onDiskIndex = await SymbolIndexService.readSymbolIndex(workspaceFolder);\n            if (onDiskIndex) {\n                symbolIndexCache = onDiskIndex;\n                console.log('Initialized symbol index cache from on-disk file');\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "debounceTimer",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 39,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "debounceTimer: NodeJS.Timeout | null = null",
      "dependents": [
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 41,
          "contextSnippet": "    // Debounce to avoid too many updates\n    let debounceTimer: NodeJS.Timeout | null = null;\n    const updateProjectAnalysis = async (changedFile?: string) => {\n        if (debounceTimer) {\n            clearTimeout(debounceTimer);\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "updateProjectAnalysis",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 40,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "updateProjectAnalysis = async (changedFile?: string) => {\n        if (debounceTimer) {\n            clearTimeout(debounceTimer);\n        }\n        \n        debounceTimer = setTimeout(async () => {\n            try {\n                // Ensure we have the latest on-disk version before updating when a file changes\n                if (changedFile && !symbolIndexCache) {\n                    await initializeSymbolIndexCache();\n                }\n                \n                // Use the refactored project analysis workflow\n                const result = await ensureProjectAnalysis(workspaceFolder, {\n                    generateDocstrings: false,\n                    showMessages: false,\n                    incremental: !!changedFile && !!symbolIndexCache,\n                    changedFile,\n                    symbolIndexCache\n                });\n                \n                // Update the symbol index cache if successful\n                if (result.success && result.symbolIndex) {\n                    symbolIndexCache = result.symbolIndex;\n                }\n                \n                console.log('Project analysis updated automatically.');\n            } catch (error) {\n                console.error('Error updating project analysis:', error);\n            }\n        }, 1000); // Wait 1 second after the last change\n    }",
      "dependents": [
        {
          "name": "setupFileWatcher",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 74,
          "contextSnippet": "    };\n    \n    // Watch for file changes\n    watcher.onDidCreate((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidChange((uri) => updateProjectAnalysis(uri.fsPath));\n    watcher.onDidDelete((uri) => updateProjectAnalysis(uri.fsPath));\n    "
        }
      ],
      "depends_on": [
        {
          "name": "debounceTimer",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 41
        },
        {
          "name": "symbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 48
        },
        {
          "name": "initializeSymbolIndexCache",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 49
        },
        {
          "name": "workspaceFolder",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 53
        },
        {
          "name": "result",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 62
        }
      ]
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/features/file-watcher/file-watcher.ts",
      "location": {
        "line": 53,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "result = await ensureProjectAnalysis(workspaceFolder, {\n                    generateDocstrings: false,\n                    showMessages: false,\n                    incremental: !!changedFile && !!symbolIndexCache,\n                    changedFile,\n                    symbolIndexCache\n                })",
      "dependents": [
        {
          "name": "updateProjectAnalysis",
          "filePath": "src/features/file-watcher/file-watcher.ts",
          "line": 62,
          "contextSnippet": "                });\n                \n                // Update the symbol index cache if successful\n                if (result.success && result.symbolIndex) {\n                    symbolIndexCache = result.symbolIndex;\n                }\n                "
        }
      ],
      "depends_on": []
    }
  ],
  "src/features/generate-docstring/docstring-generation-service.ts": [
    {
      "name": "DocstringGenerationService",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 8,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "DocstringGenerationService = {\n  /**\n   * Determines if a docstring is empty or missing\n   * @param docstring - The docstring to check\n   * @returns True if the docstring is empty or missing\n   */\n  isEmptyDocstring: (docstring?: string): boolean => {\n    // If docstring is undefined or null, it's empty\n    if (!docstring) {\n      return true;\n    }\n    \n    const trimmed = docstring.trim();\n    \n    // Check for various empty docstring patterns\n    if (trimmed === '' || \n        trimmed === '/**/' || \n        trimmed === '/** */' || \n        trimmed === '/**\\n*/' ||\n        trimmed === '/**\\n */' ||\n        trimmed === '/**\\n\\n*/' ||\n        trimmed === '/** */') {\n      return true;\n    }\n    \n    // Check for simple placeholder docstrings that only contain the symbol name\n    if (trimmed.startsWith('/**') && trimmed.endsWith('*/')) {\n      const content = trimmed.substring(3, trimmed.length - 2).trim();\n      // If the docstring just contains the name or is very short, consider it empty\n      if (content === '' || content === '*' || content.length < 3) {\n        return true;\n      }\n    }\n    \n    return false;\n  },\n\n  /**\n   * Pure function to process symbols and generate docstrings using the OpenAI API\n   * @param params - Object containing file content, symbols to process, and OpenAI client\n   * @returns Promise resolving to array of symbols with updated docstrings\n   */\n  generateDocstringsForSymbols: async ({\n    fileContent,\n    symbols,\n    client\n  }: {\n    fileContent: string;\n    symbols: SymbolIndexEntry[];\n    client: OpenAI;\n  }): Promise<SymbolIndexEntry[]> => {\n    try {\n      // Extract node information to pass to the model\n      const nodeInfos = symbols.map(symbol => ({\n        name: symbol.name,\n        // Map 'method' and 'enum' to 'function' and 'other' for compatibility with OpenAI's expected input\n        type: (symbol.type === 'method' ? 'function' : \n               symbol.type === 'enum' ? 'other' : \n               symbol.type) as 'function' | 'class' | 'interface' | 'type' | 'variable' | 'other',\n        location: symbol.location,\n        snippet: symbol.snippet,\n      }));\n      \n      // Generate docstrings using the structured approach\n      const output = await OpenAiService.generateDocstringsStructured(client, fileContent, nodeInfos);\n      \n      // Map the generated docstrings back to the original symbols\n      const updatedSymbols = [...symbols];\n      \n      for (const generatedDocstring of output.docstrings) {\n        // Find matching symbol by name and type\n        const symbolIndex = updatedSymbols.findIndex(\n          s => s.name === generatedDocstring.name && \n               (s.type === generatedDocstring.type || \n                (s.type === 'method' && generatedDocstring.type === 'function') ||\n                (s.type === 'enum' && generatedDocstring.type === 'other'))\n        );\n        \n        if (symbolIndex !== -1) {\n          updatedSymbols[symbolIndex] = {\n            ...updatedSymbols[symbolIndex],\n            docstring: generatedDocstring.docstring\n          };\n        }\n      }\n      \n      return updatedSymbols;\n    } catch (error) {\n      console.error('Error generating docstrings:', error);\n      \n      // Create an enhanced error that includes cancellation information\n      const enhancedError = error instanceof Error \n        ? error \n        : new Error('Unknown error during docstring generation');\n      \n      // Add a property to indicate this error persisted after retries\n      if (error instanceof Error && \n         (error.message.includes('after retry') || \n          error.message.includes('All retry attempts failed'))) {\n        (enhancedError as any).shouldCancelGeneration = true;\n      }\n      \n      // Add a property for server errors that might need cancellation\n      if (error instanceof Error && \n         (error.message.includes('500 ') || \n          error.message.includes('502 ') ||\n          error.message.includes('503 ') ||\n          error.message.includes('504 '))) {\n        (enhancedError as any).isServerError = true;\n      }\n      \n      throw enhancedError;\n    }\n  },\n\n  /**\n   * Validates the symbol index, counting filled and empty docstrings\n   * @param symbolIndex - The symbol index to validate\n   * @returns Validation results with counts\n   */\n  validateSymbolIndex: (symbolIndex: { [filePath: string]: SymbolIndexEntry[] }): { \n    totalSymbols: number; \n    filledDocstrings: number; \n    emptyDocstrings: number \n  } => {\n    let totalSymbols = 0;\n    let filledDocstrings = 0;\n    let emptyDocstrings = 0;\n    \n    // Process each file in the index\n    for (const filePath in symbolIndex) {\n      const fileSymbols = symbolIndex[filePath];\n      totalSymbols += fileSymbols.length;\n      \n      // Check each symbol\n      for (const symbol of fileSymbols) {\n        if (DocstringGenerationService.isEmptyDocstring(symbol.docstring)) {\n          emptyDocstrings++;\n        } else {\n          filledDocstrings++;\n        }\n      }\n    }\n    \n    return {\n      totalSymbols,\n      filledDocstrings,\n      emptyDocstrings\n    };\n  }\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 144,
          "contextSnippet": "      \n      // Check each symbol\n      for (const symbol of fileSymbols) {\n        if (DocstringGenerationService.isEmptyDocstring(symbol.docstring)) {\n          emptyDocstrings++;\n        } else {\n          filledDocstrings++;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "trimmed",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 20,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "trimmed = docstring.trim()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 23,
          "contextSnippet": "    const trimmed = docstring.trim();\n    \n    // Check for various empty docstring patterns\n    if (trimmed === '' || \n        trimmed === '/**/' || \n        trimmed === '/** */' || \n        trimmed === '/**\\n*/' ||"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 35,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "content = trimmed.substring(3, trimmed.length - 2).trim()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 37,
          "contextSnippet": "    if (trimmed.startsWith('/**') && trimmed.endsWith('*/')) {\n      const content = trimmed.substring(3, trimmed.length - 2).trim();\n      // If the docstring just contains the name or is very short, consider it empty\n      if (content === '' || content === '*' || content.length < 3) {\n        return true;\n      }\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "nodeInfos",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 61,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "nodeInfos = symbols.map(symbol => ({\n        name: symbol.name,\n        // Map 'method' and 'enum' to 'function' and 'other' for compatibility with OpenAI's expected input\n        type: (symbol.type === 'method' ? 'function' : \n               symbol.type === 'enum' ? 'other' : \n               symbol.type) as 'function' | 'class' | 'interface' | 'type' | 'variable' | 'other',\n        location: symbol.location,\n        snippet: symbol.snippet,\n      }))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 72,
          "contextSnippet": "      }));\n      \n      // Generate docstrings using the structured approach\n      const output = await OpenAiService.generateDocstringsStructured(client, fileContent, nodeInfos);\n      \n      // Map the generated docstrings back to the original symbols\n      const updatedSymbols = [...symbols];"
        }
      ],
      "depends_on": []
    },
    {
      "name": "output",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 72,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "output = await OpenAiService.generateDocstringsStructured(client, fileContent, nodeInfos)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 77,
          "contextSnippet": "      // Map the generated docstrings back to the original symbols\n      const updatedSymbols = [...symbols];\n      \n      for (const generatedDocstring of output.docstrings) {\n        // Find matching symbol by name and type\n        const symbolIndex = updatedSymbols.findIndex(\n          s => s.name === generatedDocstring.name && "
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 75,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "updatedSymbols = [...symbols]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 79,
          "contextSnippet": "      \n      for (const generatedDocstring of output.docstrings) {\n        // Find matching symbol by name and type\n        const symbolIndex = updatedSymbols.findIndex(\n          s => s.name === generatedDocstring.name && \n               (s.type === generatedDocstring.type || \n                (s.type === 'method' && generatedDocstring.type === 'function') ||"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 79,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = updatedSymbols.findIndex(\n          s => s.name === generatedDocstring.name && \n               (s.type === generatedDocstring.type || \n                (s.type === 'method' && generatedDocstring.type === 'function') ||\n                (s.type === 'enum' && generatedDocstring.type === 'other'))\n        )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 86,
          "contextSnippet": "                (s.type === 'enum' && generatedDocstring.type === 'other'))\n        );\n        \n        if (symbolIndex !== -1) {\n          updatedSymbols[symbolIndex] = {\n            ...updatedSymbols[symbolIndex],\n            docstring: generatedDocstring.docstring"
        }
      ],
      "depends_on": []
    },
    {
      "name": "enhancedError",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 99,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "enhancedError = error instanceof Error \n        ? error \n        : new Error('Unknown error during docstring generation')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 107,
          "contextSnippet": "      if (error instanceof Error && \n         (error.message.includes('after retry') || \n          error.message.includes('All retry attempts failed'))) {\n        (enhancedError as any).shouldCancelGeneration = true;\n      }\n      \n      // Add a property for server errors that might need cancellation"
        }
      ],
      "depends_on": []
    },
    {
      "name": "totalSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 133,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "totalSymbols = 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 129,
          "contextSnippet": "   * @returns Validation results with counts\n   */\n  validateSymbolIndex: (symbolIndex: { [filePath: string]: SymbolIndexEntry[] }): { \n    totalSymbols: number; \n    filledDocstrings: number; \n    emptyDocstrings: number \n  } => {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filledDocstrings",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 134,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "filledDocstrings = 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 130,
          "contextSnippet": "   */\n  validateSymbolIndex: (symbolIndex: { [filePath: string]: SymbolIndexEntry[] }): { \n    totalSymbols: number; \n    filledDocstrings: number; \n    emptyDocstrings: number \n  } => {\n    let totalSymbols = 0;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "emptyDocstrings",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 135,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "emptyDocstrings = 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 131,
          "contextSnippet": "  validateSymbolIndex: (symbolIndex: { [filePath: string]: SymbolIndexEntry[] }): { \n    totalSymbols: number; \n    filledDocstrings: number; \n    emptyDocstrings: number \n  } => {\n    let totalSymbols = 0;\n    let filledDocstrings = 0;"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 287,
          "contextSnippet": "      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {\n        await FileIoService.writeSymbolsNeedingDocstrings(\n          rootPath, \n          symbolIndex, "
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 234,
          "contextSnippet": "      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {\n        await FileIoService.writeSymbolsNeedingDocstrings(\n          rootPath, \n          symbolIndex, "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 139,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[filePath]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 140,
          "contextSnippet": "    // Process each file in the index\n    for (const filePath in symbolIndex) {\n      const fileSymbols = symbolIndex[filePath];\n      totalSymbols += fileSymbols.length;\n      \n      // Check each symbol\n      for (const symbol of fileSymbols) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "trimmed",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 23
        },
        {
          "name": "content",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 37
        },
        {
          "name": "nodeInfos",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 72
        },
        {
          "name": "output",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 77
        },
        {
          "name": "updatedSymbols",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 79
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 86
        },
        {
          "name": "enhancedError",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 107
        },
        {
          "name": "totalSymbols",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 129
        },
        {
          "name": "filledDocstrings",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 130
        },
        {
          "name": "emptyDocstrings",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 131
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 140
        },
        {
          "name": "DocstringGenerationService",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 144
        }
      ]
    }
  ],
  "src/features/generate-docstring/file-io-service.ts": [
    {
      "name": "OUTPUT_DIR",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 7,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "OUTPUT_DIR = '.cursortest'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 50,
          "contextSnippet": "      }\n      \n      // Write to a debug file\n      const debugFilePath = path.join(rootPath, OUTPUT_DIR, 'symbols-needing-docstrings.json');\n      await fs.writeFile(debugFilePath, JSON.stringify(symbolsNeedingDocstrings, null, 2), 'utf8');\n      \n      console.log(`Wrote list of ${symbolsNeedingDocstrings.length} symbols needing docstrings to ${debugFilePath}`);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "OUTPUT_FILE",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 8,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "OUTPUT_FILE = 'symbol-index.json'",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "FileIoService",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 13,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "FileIoService = {\n  /**\n   * Writes a debug file with the list of symbols that need docstrings\n   * @param rootPath - Project root path\n   * @param symbolIndex - Symbol index to analyze\n   * @param isEmptyDocstring - Function to determine if a docstring is empty\n   */\n  writeSymbolsNeedingDocstrings: async (\n    rootPath: string,\n    symbolIndex: SymbolIndex,\n    isEmptyDocstring: (docstring?: string) => boolean\n  ): Promise<void> => {\n    try {\n      const symbolsNeedingDocstrings: Array<{\n        filePath: string;\n        name: string;\n        type: string;\n        docstring: string | undefined;\n      }> = [];\n      \n      // Gather all symbols needing docstrings\n      for (const filePath in symbolIndex) {\n        const fileSymbols = symbolIndex[filePath];\n        \n        for (const symbol of fileSymbols) {\n          if (isEmptyDocstring(symbol.docstring)) {\n            symbolsNeedingDocstrings.push({\n              filePath,\n              name: symbol.name,\n              type: symbol.type,\n              docstring: symbol.docstring\n            });\n          }\n        }\n      }\n      \n      // Write to a debug file\n      const debugFilePath = path.join(rootPath, OUTPUT_DIR, 'symbols-needing-docstrings.json');\n      await fs.writeFile(debugFilePath, JSON.stringify(symbolsNeedingDocstrings, null, 2), 'utf8');\n      \n      console.log(`Wrote list of ${symbolsNeedingDocstrings.length} symbols needing docstrings to ${debugFilePath}`);\n    } catch (error) {\n      console.error('Error writing debug file:', error);\n    }\n  },\n\n  /**\n   * Reads a file's content from disk\n   * @param filePath - Path to the file to read\n   * @returns The file content as a string\n   */\n  readFileContent: async (filePath: string): Promise<string> => {\n    try {\n      return await fs.readFile(filePath, 'utf8');\n    } catch (error) {\n      console.error(`Error reading file ${filePath}:`, error);\n      throw error;\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbolsNeedingDocstrings",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 26,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolsNeedingDocstrings: Array<{\n        filePath: string;\n        name: string;\n        type: string;\n        docstring: string | undefined;\n      }> = []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 39,
          "contextSnippet": "        \n        for (const symbol of fileSymbols) {\n          if (isEmptyDocstring(symbol.docstring)) {\n            symbolsNeedingDocstrings.push({\n              filePath,\n              name: symbol.name,\n              type: symbol.type,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 35,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[filePath]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 37,
          "contextSnippet": "      for (const filePath in symbolIndex) {\n        const fileSymbols = symbolIndex[filePath];\n        \n        for (const symbol of fileSymbols) {\n          if (isEmptyDocstring(symbol.docstring)) {\n            symbolsNeedingDocstrings.push({\n              filePath,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "debugFilePath",
      "type": "variable",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 50,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "debugFilePath = path.join(rootPath, OUTPUT_DIR, 'symbols-needing-docstrings.json')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 51,
          "contextSnippet": "      \n      // Write to a debug file\n      const debugFilePath = path.join(rootPath, OUTPUT_DIR, 'symbols-needing-docstrings.json');\n      await fs.writeFile(debugFilePath, JSON.stringify(symbolsNeedingDocstrings, null, 2), 'utf8');\n      \n      console.log(`Wrote list of ${symbolsNeedingDocstrings.length} symbols needing docstrings to ${debugFilePath}`);\n    } catch (error) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/generate-docstring/file-io-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 37
        },
        {
          "name": "symbolsNeedingDocstrings",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 39
        },
        {
          "name": "OUTPUT_DIR",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 50
        },
        {
          "name": "debugFilePath",
          "filePath": "src/features/generate-docstring/file-io-service.ts",
          "line": 51
        }
      ]
    }
  ],
  "src/features/generate-docstring/generate-docstring-parallel.ts": [
    {
      "name": "FileBatchParams",
      "type": "interface",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 18,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface FileBatchParams {\n  filePath: string;\n  symbols: SymbolIndexEntry[];\n  fullFilePath: string;\n  fileContent: string;\n  client: OpenAI;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n  totalFiles: number;\n  fileIndex: number;\n}",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 45,
          "contextSnippet": "  mode,\n  totalFiles,\n  fileIndex\n}: FileBatchParams): Promise<SymbolIndexEntry[]> => {\n  try {\n    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;\n    "
        }
      ],
      "depends_on": [
        {
          "name": "fullFilePath",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 21
        },
        {
          "name": "fileContent",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 22
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 23
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 26
        },
        {
          "name": "fileIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 27
        }
      ]
    },
    {
      "name": "processFileDocstrings",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 35,
        "character": 6
      },
      "docstring": "/**\n * Processes a single file to generate docstrings\n * @param params - Parameters for processing a file\n * @returns Updated symbols for the file\n */",
      "snippet": "processFileDocstrings = async ({\n  filePath,\n  symbols,\n  fullFilePath,\n  fileContent,\n  client,\n  progress,\n  mode,\n  totalFiles,\n  fileIndex\n}: FileBatchParams): Promise<SymbolIndexEntry[]> => {\n  try {\n    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;\n    \n    // Filter symbols based on the generation mode\n    const symbolsToProcess = skipExisting\n      ? symbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring))\n      : symbols;\n    \n    // Skip file if no symbols need processing\n    if (symbolsToProcess.length === 0) {\n      return symbols;\n    }\n    \n    // Update progress for this file\n    const progressMessage = skipExisting\n      ? `[${fileIndex}/${totalFiles}] Generating missing docstrings for: ${filePath} (${symbolsToProcess.length} symbols)`\n      : `[${fileIndex}/${totalFiles}] Generating docstrings for: ${filePath}`;\n    \n    progress?.report({ message: progressMessage });\n    \n    // Generate docstrings using the dedicated service\n    const updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({\n      fileContent,\n      symbols: symbolsToProcess,\n      client\n    });\n    \n    // Check for cancellation after processing symbols\n    if (progress?.isCancelled?.()) {\n      progress?.report({ message: 'Docstring generation cancelled.' });\n      return symbols;\n    }\n    \n    // Return the merged results (updated symbols + any existing symbols that weren't processed)\n    return symbols.map(originalSymbol => {\n      const updatedSymbol = updatedSymbols.find(\n        s => s.name === originalSymbol.name && s.type === originalSymbol.type\n      );\n      \n      return updatedSymbol || originalSymbol;\n    });\n  } catch (error) {\n    console.error(`Error processing docstrings for file ${filePath}:`, error);\n    \n    // If this is a critical error that should stop processing, rethrow it\n    if (error instanceof Error && \n       ((error as any).shouldCancelGeneration === true || \n        (error as any).isServerError === true)) {\n      throw error;\n    }\n    \n    // Otherwise, return the original symbols (skip this file but continue with others)\n    return symbols;\n  }\n}",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 150,
          "contextSnippet": "    const fileContent = await FileIoService.readFileContent(fullFilePath);\n    \n    // Process the file to generate docstrings\n    const updatedSymbols = await processFileDocstrings({\n      filePath,\n      symbols: fileSymbols,\n      fullFilePath,"
        }
      ],
      "depends_on": [
        {
          "name": "fullFilePath",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 38
        },
        {
          "name": "fileContent",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 39
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 40
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 43
        },
        {
          "name": "fileIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 44
        },
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 45
        },
        {
          "name": "skipExisting",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 50
        },
        {
          "name": "symbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 55
        },
        {
          "name": "progressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 64
        },
        {
          "name": "updatedSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 81
        },
        {
          "name": "updatedSymbol",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 85
        }
      ]
    },
    {
      "name": "skipExisting",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 47,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 50,
          "contextSnippet": "    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;\n    \n    // Filter symbols based on the generation mode\n    const symbolsToProcess = skipExisting\n      ? symbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring))\n      : symbols;\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolsToProcess",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 50,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolsToProcess = skipExisting\n      ? symbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring))\n      : symbols",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 55,
          "contextSnippet": "      : symbols;\n    \n    // Skip file if no symbols need processing\n    if (symbolsToProcess.length === 0) {\n      return symbols;\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "progressMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 60,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "progressMessage = skipExisting\n      ? `[${fileIndex}/${totalFiles}] Generating missing docstrings for: ${filePath} (${symbolsToProcess.length} symbols)`\n      : `[${fileIndex}/${totalFiles}] Generating docstrings for: ${filePath}`",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 64,
          "contextSnippet": "      ? `[${fileIndex}/${totalFiles}] Generating missing docstrings for: ${filePath} (${symbolsToProcess.length} symbols)`\n      : `[${fileIndex}/${totalFiles}] Generating docstrings for: ${filePath}`;\n    \n    progress?.report({ message: progressMessage });\n    \n    // Generate docstrings using the dedicated service\n    const updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 67,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({\n      fileContent,\n      symbols: symbolsToProcess,\n      client\n    })",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 81,
          "contextSnippet": "    \n    // Return the merged results (updated symbols + any existing symbols that weren't processed)\n    return symbols.map(originalSymbol => {\n      const updatedSymbol = updatedSymbols.find(\n        s => s.name === originalSymbol.name && s.type === originalSymbol.type\n      );\n      "
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 163,
          "contextSnippet": "    });\n    \n    // Count processed symbols for statistics\n    const fileProcessedCount = updatedSymbols.filter((symbol, index) => \n      !DocstringGenerationService.isEmptyDocstring(symbol.docstring) && \n      (mode === DocstringGenerationMode.GENERATE_ALL || \n       DocstringGenerationService.isEmptyDocstring(fileSymbols[index].docstring))"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedSymbol",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 81,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "updatedSymbol = updatedSymbols.find(\n        s => s.name === originalSymbol.name && s.type === originalSymbol.type\n      )",
      "dependents": [
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 85,
          "contextSnippet": "        s => s.name === originalSymbol.name && s.type === originalSymbol.type\n      );\n      \n      return updatedSymbol || originalSymbol;\n    });\n  } catch (error) {\n    console.error(`Error processing docstrings for file ${filePath}:`, error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "processFileBatch",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 116,
        "character": 6
      },
      "docstring": "/**\n * Processes a batch of files in parallel\n * @param fileBatch - Array of files to process\n * @param symbolIndex - The symbol index\n * @param projectFiles - All project files\n * @param rootPath - Root path of the project\n * @param client - OpenAI client\n * @param progress - Progress reporter\n * @param token - Cancellation token\n * @param mode - Docstring generation mode\n * @param totalFiles - Total number of files\n * @param startIndex - Starting index for this batch\n * @returns Updated symbol counts\n */",
      "snippet": "processFileBatch = async (\n  fileBatch: string[],\n  symbolIndex: SymbolIndex,\n  projectFiles: string[],\n  rootPath: string,\n  client: OpenAI,\n  progress?: ProgressReporter,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL,\n  totalFiles: number = 0,\n  startIndex: number = 0\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let processedCount = 0;\n  \n  // Process each file in the batch concurrently\n  const filePromises = fileBatch.map(async (filePath, batchIndex) => {\n    // Check for cancellation\n    if (token?.isCancellationRequested) {\n      return { filePath, processedCount: 0, updatedSymbols: symbolIndex[filePath] };\n    }\n    \n    const fileIndex = startIndex + batchIndex + 1;\n    const fileSymbols = symbolIndex[filePath];\n    \n    // Find the full file path\n    const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n    if (!fullFilePath) {\n      return { filePath, processedCount: 0, updatedSymbols: fileSymbols };\n    }\n    \n    // Read the file content\n    const fileContent = await FileIoService.readFileContent(fullFilePath);\n    \n    // Process the file to generate docstrings\n    const updatedSymbols = await processFileDocstrings({\n      filePath,\n      symbols: fileSymbols,\n      fullFilePath,\n      fileContent,\n      client,\n      progress,\n      mode,\n      totalFiles,\n      fileIndex\n    });\n    \n    // Count processed symbols for statistics\n    const fileProcessedCount = updatedSymbols.filter((symbol, index) => \n      !DocstringGenerationService.isEmptyDocstring(symbol.docstring) && \n      (mode === DocstringGenerationMode.GENERATE_ALL || \n       DocstringGenerationService.isEmptyDocstring(fileSymbols[index].docstring))\n    ).length;\n    \n    return { filePath, processedCount: fileProcessedCount, updatedSymbols };\n  });\n  \n  // Wait for all files in the batch to complete\n  const results = await Promise.all(filePromises);\n  \n  // Update the symbol index and count processed symbols\n  for (const result of results) {\n    if (token?.isCancellationRequested) {\n      break;\n    }\n    symbolIndex[result.filePath] = result.updatedSymbols;\n    processedCount += result.processedCount;\n  }\n  \n  return { processedCount, updatedIndex: symbolIndex };\n}",
      "dependents": [
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 226,
          "contextSnippet": "    const batch = files.slice(i, i + batchSize);\n    \n    // Process this batch\n    const { processedCount, updatedIndex: newIndex } = await processFileBatch(\n      batch,\n      updatedIndex,\n      projectFiles,"
        }
      ],
      "depends_on": [
        {
          "name": "processedCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 127
        },
        {
          "name": "updatedIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 127
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 134
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 141
        },
        {
          "name": "fullFilePath",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 142
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 143
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 150
        },
        {
          "name": "fileContent",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 154
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 155
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 158
        },
        {
          "name": "fileIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 159
        },
        {
          "name": "updatedSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 163
        },
        {
          "name": "fileProcessedCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 169
        },
        {
          "name": "filePromises",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 173
        },
        {
          "name": "results",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 176
        }
      ]
    },
    {
      "name": "processedCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 128,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "processedCount = 0",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 127,
          "contextSnippet": "  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL,\n  totalFiles: number = 0,\n  startIndex: number = 0\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let processedCount = 0;\n  \n  // Process each file in the batch concurrently"
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 210,
          "contextSnippet": "  progress?: ProgressReporter,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let totalProcessedCount = 0;\n  const totalFiles = files.length;\n  let updatedIndex = { ...symbolIndex };"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342,
          "contextSnippet": "    \n    try {\n      // Process all files in batches\n      const { processedCount, updatedIndex } = await processFilesInBatches(\n        filesToProcess, \n        concurrency, \n        symbolIndex, "
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePromises",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 131,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "filePromises = fileBatch.map(async (filePath, batchIndex) => {\n    // Check for cancellation\n    if (token?.isCancellationRequested) {\n      return { filePath, processedCount: 0, updatedSymbols: symbolIndex[filePath] };\n    }\n    \n    const fileIndex = startIndex + batchIndex + 1;\n    const fileSymbols = symbolIndex[filePath];\n    \n    // Find the full file path\n    const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n    if (!fullFilePath) {\n      return { filePath, processedCount: 0, updatedSymbols: fileSymbols };\n    }\n    \n    // Read the file content\n    const fileContent = await FileIoService.readFileContent(fullFilePath);\n    \n    // Process the file to generate docstrings\n    const updatedSymbols = await processFileDocstrings({\n      filePath,\n      symbols: fileSymbols,\n      fullFilePath,\n      fileContent,\n      client,\n      progress,\n      mode,\n      totalFiles,\n      fileIndex\n    });\n    \n    // Count processed symbols for statistics\n    const fileProcessedCount = updatedSymbols.filter((symbol, index) => \n      !DocstringGenerationService.isEmptyDocstring(symbol.docstring) && \n      (mode === DocstringGenerationMode.GENERATE_ALL || \n       DocstringGenerationService.isEmptyDocstring(fileSymbols[index].docstring))\n    ).length;\n    \n    return { filePath, processedCount: fileProcessedCount, updatedSymbols };\n  })",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 173,
          "contextSnippet": "  });\n  \n  // Wait for all files in the batch to complete\n  const results = await Promise.all(filePromises);\n  \n  // Update the symbol index and count processed symbols\n  for (const result of results) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 137,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fileIndex = startIndex + batchIndex + 1",
      "dependents": [
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 27,
          "contextSnippet": "  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n  totalFiles: number;\n  fileIndex: number;\n}\n\n/**"
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 44,
          "contextSnippet": "  progress,\n  mode,\n  totalFiles,\n  fileIndex\n}: FileBatchParams): Promise<SymbolIndexEntry[]> => {\n  try {\n    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;"
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 159,
          "contextSnippet": "      progress,\n      mode,\n      totalFiles,\n      fileIndex\n    });\n    \n    // Count processed symbols for statistics"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 138,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[filePath]",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 143,
          "contextSnippet": "    // Find the full file path\n    const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n    if (!fullFilePath) {\n      return { filePath, processedCount: 0, updatedSymbols: fileSymbols };\n    }\n    \n    // Read the file content"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 332,
          "contextSnippet": "    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      for (const filePath in symbolIndex) {\n        const fileSymbols = symbolIndex[filePath];\n        for (const symbol of fileSymbols) {\n          if (!DocstringGenerationService.isEmptyDocstring(symbol.docstring)) {\n            skippedSymbolCount++;\n          }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fullFilePath",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 141,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath)",
      "dependents": [
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 21,
          "contextSnippet": "interface FileBatchParams {\n  filePath: string;\n  symbols: SymbolIndexEntry[];\n  fullFilePath: string;\n  fileContent: string;\n  client: OpenAI;\n  progress?: ProgressReporter;"
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 38,
          "contextSnippet": "const processFileDocstrings = async ({\n  filePath,\n  symbols,\n  fullFilePath,\n  fileContent,\n  client,\n  progress,"
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 142,
          "contextSnippet": "    \n    // Find the full file path\n    const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n    if (!fullFilePath) {\n      return { filePath, processedCount: 0, updatedSymbols: fileSymbols };\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileContent",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 147,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fileContent = await FileIoService.readFileContent(fullFilePath)",
      "dependents": [
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 22,
          "contextSnippet": "  filePath: string;\n  symbols: SymbolIndexEntry[];\n  fullFilePath: string;\n  fileContent: string;\n  client: OpenAI;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;"
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 39,
          "contextSnippet": "  filePath,\n  symbols,\n  fullFilePath,\n  fileContent,\n  client,\n  progress,\n  mode,"
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 154,
          "contextSnippet": "      filePath,\n      symbols: fileSymbols,\n      fullFilePath,\n      fileContent,\n      client,\n      progress,\n      mode,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 150,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "updatedSymbols = await processFileDocstrings({\n      filePath,\n      symbols: fileSymbols,\n      fullFilePath,\n      fileContent,\n      client,\n      progress,\n      mode,\n      totalFiles,\n      fileIndex\n    })",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "fileProcessedCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 163,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "fileProcessedCount = updatedSymbols.filter((symbol, index) => \n      !DocstringGenerationService.isEmptyDocstring(symbol.docstring) && \n      (mode === DocstringGenerationMode.GENERATE_ALL || \n       DocstringGenerationService.isEmptyDocstring(fileSymbols[index].docstring))\n    ).length",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 169,
          "contextSnippet": "       DocstringGenerationService.isEmptyDocstring(fileSymbols[index].docstring))\n    ).length;\n    \n    return { filePath, processedCount: fileProcessedCount, updatedSymbols };\n  });\n  \n  // Wait for all files in the batch to complete"
        }
      ],
      "depends_on": []
    },
    {
      "name": "results",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 173,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "results = await Promise.all(filePromises)",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 176,
          "contextSnippet": "  const results = await Promise.all(filePromises);\n  \n  // Update the symbol index and count processed symbols\n  for (const result of results) {\n    if (token?.isCancellationRequested) {\n      break;\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "processFilesInBatches",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 200,
        "character": 6
      },
      "docstring": "/**\n * Processes all files in batches to manage concurrency\n * @param files - Array of files to process\n * @param batchSize - Maximum number of files to process concurrently\n * @param symbolIndex - The symbol index\n * @param projectFiles - All project files\n * @param rootPath - Root path of the project\n * @param client - OpenAI client\n * @param progress - Progress reporter\n * @param token - Cancellation token\n * @param mode - Docstring generation mode\n * @returns Total processed symbols count\n */",
      "snippet": "processFilesInBatches = async (\n  files: string[],\n  batchSize: number,\n  symbolIndex: SymbolIndex,\n  projectFiles: string[],\n  rootPath: string,\n  client: OpenAI,\n  progress?: ProgressReporter,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let totalProcessedCount = 0;\n  const totalFiles = files.length;\n  let updatedIndex = { ...symbolIndex };\n  \n  // Process files in batches\n  for (let i = 0; i < files.length; i += batchSize) {\n    // Check for cancellation\n    if (token?.isCancellationRequested) {\n      break;\n    }\n    \n    // Get the current batch of files\n    const batch = files.slice(i, i + batchSize);\n    \n    // Process this batch\n    const { processedCount, updatedIndex: newIndex } = await processFileBatch(\n      batch,\n      updatedIndex,\n      projectFiles,\n      rootPath,\n      client,\n      progress,\n      token,\n      mode,\n      totalFiles,\n      i\n    );\n    \n    // Update counts and index\n    totalProcessedCount += processedCount;\n    updatedIndex = newIndex;\n    \n    // Save progress periodically\n    if ((i + batchSize) % (batchSize * 2) === 0 || (i + batchSize) >= files.length) {\n      progress?.report({ message: `Saving progress... (${i + batch.length}/${totalFiles} files processed)` });\n      await SymbolIndexService.writeSymbolIndex(rootPath, updatedIndex);\n    }\n  }\n  \n  return { processedCount: totalProcessedCount, updatedIndex };\n}",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342,
          "contextSnippet": "    \n    try {\n      // Process all files in batches\n      const { processedCount, updatedIndex } = await processFilesInBatches(\n        filesToProcess, \n        concurrency, \n        symbolIndex, "
        }
      ],
      "depends_on": [
        {
          "name": "processedCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 210
        },
        {
          "name": "updatedIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 210
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 213
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 226
        },
        {
          "name": "batch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 227
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 229
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 231
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 235
        },
        {
          "name": "totalProcessedCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 240
        }
      ]
    },
    {
      "name": "totalProcessedCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 211,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "totalProcessedCount = 0",
      "dependents": [
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 240,
          "contextSnippet": "    );\n    \n    // Update counts and index\n    totalProcessedCount += processedCount;\n    updatedIndex = newIndex;\n    \n    // Save progress periodically"
        }
      ],
      "depends_on": []
    },
    {
      "name": "totalFiles",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 212,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "totalFiles = files.length",
      "dependents": [
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 26,
          "contextSnippet": "  client: OpenAI;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n  totalFiles: number;\n  fileIndex: number;\n}\n"
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 43,
          "contextSnippet": "  client,\n  progress,\n  mode,\n  totalFiles,\n  fileIndex\n}: FileBatchParams): Promise<SymbolIndexEntry[]> => {\n  try {"
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 158,
          "contextSnippet": "      client,\n      progress,\n      mode,\n      totalFiles,\n      fileIndex\n    });\n    "
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 235,
          "contextSnippet": "      progress,\n      token,\n      mode,\n      totalFiles,\n      i\n    );\n    "
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 322,
          "contextSnippet": "    const totalFiles = filesToProcess.length;\n    \n    progress?.report({ \n      message: `Processing ${totalFiles} files with maximum concurrency of ${concurrency}...`\n    });\n    \n    // Track stats for reporting"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 213,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "updatedIndex = { ...symbolIndex }",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 127,
          "contextSnippet": "  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL,\n  totalFiles: number = 0,\n  startIndex: number = 0\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let processedCount = 0;\n  \n  // Process each file in the batch concurrently"
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 210,
          "contextSnippet": "  progress?: ProgressReporter,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let totalProcessedCount = 0;\n  const totalFiles = files.length;\n  let updatedIndex = { ...symbolIndex };"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342,
          "contextSnippet": "    \n    try {\n      // Process all files in batches\n      const { processedCount, updatedIndex } = await processFilesInBatches(\n        filesToProcess, \n        concurrency, \n        symbolIndex, "
        }
      ],
      "depends_on": []
    },
    {
      "name": "batch",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 223,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "batch = files.slice(i, i + batchSize)",
      "dependents": [
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 227,
          "contextSnippet": "    \n    // Process this batch\n    const { processedCount, updatedIndex: newIndex } = await processFileBatch(\n      batch,\n      updatedIndex,\n      projectFiles,\n      rootPath,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateDocstringsParallel",
      "type": "function",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 263,
        "character": 0
      },
      "docstring": "/**\n * Generates docstrings in parallel for symbols in the index\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore\n * @param progress - Optional progress reporter\n * @param token - Optional cancellation token\n * @param concurrency - Maximum number of files to process concurrently\n * @param mode - Docstring generation mode (defaults to GENERATE_ALL)\n * @returns Whether the operation was successful\n */",
      "snippet": "export async function generateDocstringsParallel(\n  rootPath: string,\n  ignoredPatterns: string[] = [],\n  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken,\n  concurrency: number = 5,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<boolean> {\n  try {\n    // Ensure .cursortest directory exists\n    await WorkspaceService.ensureCursorTestDir(rootPath);\n    \n    // Check if symbol-index.json exists and load it\n    const symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath, \n      'Symbol index not found. Please build the symbol index first.'\n    );\n    \n    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {\n        await FileIoService.writeSymbolsNeedingDocstrings(\n          rootPath, \n          symbolIndex, \n          DocstringGenerationService.isEmptyDocstring\n        );\n      }\n      \n      progress?.report({ \n        message: `Preparing to generate missing docstrings in parallel (${validation.emptyDocstrings} symbols need processing)...` \n      });\n    } else {\n      progress?.report({ message: 'Preparing to generate all docstrings in parallel...' });\n    }\n    \n    // Get environment variables for OpenAI\n    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }\n    \n    // Get project files\n    const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n    \n    // Set up progress reporting\n    const progressAdapter = progress ? adaptVSCodeProgress(progress, token) : undefined;\n    \n    // Get files with symbols that need processing\n    const filesToProcess = Object.keys(symbolIndex);\n    const totalFiles = filesToProcess.length;\n    \n    progress?.report({ \n      message: `Processing ${totalFiles} files with maximum concurrency of ${concurrency}...`\n    });\n    \n    // Track stats for reporting\n    let skippedSymbolCount = 0;\n    \n    // If mode is GENERATE_MISSING, count the number of skipped symbols\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      for (const filePath in symbolIndex) {\n        const fileSymbols = symbolIndex[filePath];\n        for (const symbol of fileSymbols) {\n          if (!DocstringGenerationService.isEmptyDocstring(symbol.docstring)) {\n            skippedSymbolCount++;\n          }\n        }\n      }\n    }\n    \n    try {\n      // Process all files in batches\n      const { processedCount, updatedIndex } = await processFilesInBatches(\n        filesToProcess, \n        concurrency, \n        symbolIndex, \n        projectFiles, \n        rootPath, \n        client, \n        progressAdapter, \n        token, \n        mode\n      );\n      \n      // Check for cancellation\n      if (token?.isCancellationRequested) {\n        progress?.report({ message: 'Parallel docstring generation cancelled.' });\n        return false;\n      }\n      \n      // Write the final updated symbol index to file\n      await SymbolIndexService.writeSymbolIndex(rootPath, updatedIndex);\n      \n      // Report completion statistics\n      const completionMessage = mode === DocstringGenerationMode.GENERATE_MISSING\n        ? `Parallel docstring generation complete. Generated ${processedCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`\n        : `Parallel docstring generation complete. Generated/updated ${processedCount} docstrings.`;\n      \n      progress?.report({ message: completionMessage });\n      return true;\n    } catch (error) {\n      console.error('Error during parallel docstring generation:', error);\n      \n      // Try to save work done so far\n      await SymbolIndexService.writeSymbolIndex(rootPath, symbolIndex);\n      \n      throw error;\n    }\n  } catch (error) {\n    console.error('Error generating docstrings in parallel:', error);\n    \n    // Handle different error types with user-friendly messages\n    let errorMessage = 'An error occurred during parallel docstring generation.';\n    \n    if (error instanceof Error) {\n      if (error.message.includes('500')) {\n        errorMessage = 'OpenAI server error (500). The service is temporarily unavailable. Please try again later.';\n      } else if (error.message.includes('401') || error.message.includes('API key')) {\n        errorMessage = 'Invalid or missing OpenAI API key. Please check your API key configuration.';\n      } else if (error.message.includes('429') || error.message.includes('rate limit')) {\n        errorMessage = 'OpenAI API rate limit exceeded. Consider reducing the concurrency setting and try again.';\n      } else if (error.message.includes('timeout')) {\n        errorMessage = 'Request to OpenAI API timed out. Please check your network connection and try again.';\n      } else if (error.message.includes('retry') || (error as any).shouldCancelGeneration === true) {\n        errorMessage = 'Docstring generation failed after multiple retry attempts. Please try again later.';\n      } else if ((error as any).isServerError === true) {\n        errorMessage = 'OpenAI service is experiencing issues. Docstring generation has been cancelled. Please try again later.';\n      } else {\n        // For other errors, include the actual error message\n        errorMessage = `Error generating docstrings in parallel: ${error.message}`;\n      }\n    }\n    \n    vscode.window.showErrorMessage(errorMessage);\n    return false;\n  }\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 283
        },
        {
          "name": "validation",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 284
        },
        {
          "name": "emptyDocstrings",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 287
        },
        {
          "name": "envVars",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 306
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 307
        },
        {
          "name": "filesToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 319
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 322
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 332
        },
        {
          "name": "skippedSymbolCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 334
        },
        {
          "name": "processedCount",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342
        },
        {
          "name": "updatedIndex",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 342
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 346
        },
        {
          "name": "progressAdapter",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 349
        },
        {
          "name": "completionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 368
        },
        {
          "name": "errorMessage",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 386
        }
      ]
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 276,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath, \n      'Symbol index not found. Please build the symbol index first.'\n    )",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 134,
          "contextSnippet": "  const filePromises = fileBatch.map(async (filePath, batchIndex) => {\n    // Check for cancellation\n    if (token?.isCancellationRequested) {\n      return { filePath, processedCount: 0, updatedSymbols: symbolIndex[filePath] };\n    }\n    \n    const fileIndex = startIndex + batchIndex + 1;"
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 213,
          "contextSnippet": "): Promise<{ processedCount: number; updatedIndex: SymbolIndex }> => {\n  let totalProcessedCount = 0;\n  const totalFiles = files.length;\n  let updatedIndex = { ...symbolIndex };\n  \n  // Process files in batches\n  for (let i = 0; i < files.length; i += batchSize) {"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 283,
          "contextSnippet": "    \n    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings"
        }
      ],
      "depends_on": []
    },
    {
      "name": "validation",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 283,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "validation = DocstringGenerationService.validateSymbolIndex(symbolIndex)",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 284,
          "contextSnippet": "    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "envVars",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 303,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "envVars = OpenAiService.loadEnvironmentVars(rootPath)",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 306,
          "contextSnippet": "    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "client",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 306,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY)",
      "dependents": [
        {
          "name": "FileBatchParams",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 23,
          "contextSnippet": "  symbols: SymbolIndexEntry[];\n  fullFilePath: string;\n  fileContent: string;\n  client: OpenAI;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n  totalFiles: number;"
        },
        {
          "name": "processFileDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 40,
          "contextSnippet": "  symbols,\n  fullFilePath,\n  fileContent,\n  client,\n  progress,\n  mode,\n  totalFiles,"
        },
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 155,
          "contextSnippet": "      symbols: fileSymbols,\n      fullFilePath,\n      fileContent,\n      client,\n      progress,\n      mode,\n      totalFiles,"
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 231,
          "contextSnippet": "      updatedIndex,\n      projectFiles,\n      rootPath,\n      client,\n      progress,\n      token,\n      mode,"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 307,
          "contextSnippet": "    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "projectFiles",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 312,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "processFileBatch",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 141,
          "contextSnippet": "    const fileSymbols = symbolIndex[filePath];\n    \n    // Find the full file path\n    const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n    if (!fullFilePath) {\n      return { filePath, processedCount: 0, updatedSymbols: fileSymbols };\n    }"
        },
        {
          "name": "processFilesInBatches",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 229,
          "contextSnippet": "    const { processedCount, updatedIndex: newIndex } = await processFileBatch(\n      batch,\n      updatedIndex,\n      projectFiles,\n      rootPath,\n      client,\n      progress,"
        },
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 346,
          "contextSnippet": "        filesToProcess, \n        concurrency, \n        symbolIndex, \n        projectFiles, \n        rootPath, \n        client, \n        progressAdapter, "
        }
      ],
      "depends_on": []
    },
    {
      "name": "progressAdapter",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 315,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "progressAdapter = progress ? adaptVSCodeProgress(progress, token) : undefined",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 349,
          "contextSnippet": "        projectFiles, \n        rootPath, \n        client, \n        progressAdapter, \n        token, \n        mode\n      );"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filesToProcess",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 318,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filesToProcess = Object.keys(symbolIndex)",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 319,
          "contextSnippet": "    \n    // Get files with symbols that need processing\n    const filesToProcess = Object.keys(symbolIndex);\n    const totalFiles = filesToProcess.length;\n    \n    progress?.report({ \n      message: `Processing ${totalFiles} files with maximum concurrency of ${concurrency}...`"
        }
      ],
      "depends_on": []
    },
    {
      "name": "totalFiles",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 319,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "totalFiles = filesToProcess.length",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "skippedSymbolCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 326,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "skippedSymbolCount = 0",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 334,
          "contextSnippet": "        const fileSymbols = symbolIndex[filePath];\n        for (const symbol of fileSymbols) {\n          if (!DocstringGenerationService.isEmptyDocstring(symbol.docstring)) {\n            skippedSymbolCount++;\n          }\n        }\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 331,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[filePath]",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "completionMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 364,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "completionMessage = mode === DocstringGenerationMode.GENERATE_MISSING\n        ? `Parallel docstring generation complete. Generated ${processedCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`\n        : `Parallel docstring generation complete. Generated/updated ${processedCount} docstrings.`",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 368,
          "contextSnippet": "        ? `Parallel docstring generation complete. Generated ${processedCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`\n        : `Parallel docstring generation complete. Generated/updated ${processedCount} docstrings.`;\n      \n      progress?.report({ message: completionMessage });\n      return true;\n    } catch (error) {\n      console.error('Error during parallel docstring generation:', error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "errorMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
      "location": {
        "line": 382,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "errorMessage = 'An error occurred during parallel docstring generation.'",
      "dependents": [
        {
          "name": "generateDocstringsParallel",
          "filePath": "src/features/generate-docstring/generate-docstring-parallel.ts",
          "line": 386,
          "contextSnippet": "    \n    if (error instanceof Error) {\n      if (error.message.includes('500')) {\n        errorMessage = 'OpenAI server error (500). The service is temporarily unavailable. Please try again later.';\n      } else if (error.message.includes('401') || error.message.includes('API key')) {\n        errorMessage = 'Invalid or missing OpenAI API key. Please check your API key configuration.';\n      } else if (error.message.includes('429') || error.message.includes('rate limit')) {"
        }
      ],
      "depends_on": []
    }
  ],
  "src/features/generate-docstring/generate-docstring.ts": [
    {
      "name": "OUTPUT_DIR",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 17,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "OUTPUT_DIR = '.cursortest'",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "OUTPUT_FILE",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 18,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "OUTPUT_FILE = 'symbol-index.json'",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "DocstringGenerationMode",
      "type": "enum",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 23,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export enum DocstringGenerationMode {\n  /** Generate docstrings for all symbols, regardless of existing docstrings */\n  GENERATE_ALL = 'generate_all',\n  /** Only generate docstrings for symbols with empty or missing docstrings */\n  GENERATE_MISSING = 'generate_missing'\n}",
      "dependents": [
        {
          "name": "DocstringGenerationParams",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 39,
          "contextSnippet": "  projectFiles: string[];\n  rootPath: string;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n}\n\n/**"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 64,
          "contextSnippet": "    let consecutiveErrorCount = 0;\n    const MAX_CONSECUTIVE_ERRORS = 3; // Maximum number of consecutive errors before cancelling\n    \n    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;\n    \n    // Process files one by one\n    for (const filePath in symbolIndex) {"
        },
        {
          "name": "getSymbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 81,
          "contextSnippet": "      \n      // Filter symbols based on the generation mode\n      const getSymbolsToProcess = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return fileSymbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring));\n        }\n        return fileSymbols;"
        },
        {
          "name": "getProgressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 102,
          "contextSnippet": "      \n      // Update progress for each file\n      const getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;"
        },
        {
          "name": "getCompletionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 191,
          "contextSnippet": "    }\n    \n    const getCompletionMessage = () => {\n      if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n        return `Docstring generation complete. Generated ${processedSymbolCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`;\n      }\n      return 'Docstring generation complete.';"
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 216,
          "contextSnippet": "  ignoredPatterns: string[] = [],\n  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<void> => {\n  try {\n    // Ensure .cursortest directory exists"
        },
        {
          "name": "generateDocstringIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 326,
          "contextSnippet": "    ignoredPatterns,\n    progress,\n    token,\n    DocstringGenerationMode.GENERATE_ALL\n  );\n};\n"
        },
        {
          "name": "resumeDocstringGeneration",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 348,
          "contextSnippet": "    ignoredPatterns,\n    progress,\n    token,\n    DocstringGenerationMode.GENERATE_MISSING\n  );\n};\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DocstringGenerationParams",
      "type": "interface",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 33,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface DocstringGenerationParams {\n  symbolIndex: SymbolIndex;\n  client: OpenAI;\n  projectFiles: string[];\n  rootPath: string;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;\n}",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 54,
          "contextSnippet": "  rootPath,\n  progress,\n  mode\n}: DocstringGenerationParams): Promise<void> => {\n  try {\n    // Get total number of files to process for progress reporting\n    const totalFiles = Object.keys(symbolIndex).length;"
        }
      ],
      "depends_on": [
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 34
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 35
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 36
        },
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 39
        }
      ]
    },
    {
      "name": "generateDocstrings",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 47,
        "character": 13
      },
      "docstring": "/**\n * Generates docstrings for symbols in the index\n * @param params - Parameters for docstring generation\n * @returns Promise that resolves when docstrings are generated\n */",
      "snippet": "generateDocstrings = async ({\n  symbolIndex,\n  client,\n  projectFiles,\n  rootPath,\n  progress,\n  mode\n}: DocstringGenerationParams): Promise<void> => {\n  try {\n    // Get total number of files to process for progress reporting\n    const totalFiles = Object.keys(symbolIndex).length;\n    let fileCount = 0;\n    let processedSymbolCount = 0;\n    let skippedSymbolCount = 0;\n    let consecutiveErrorCount = 0;\n    const MAX_CONSECUTIVE_ERRORS = 3; // Maximum number of consecutive errors before cancelling\n    \n    const skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING;\n    \n    // Process files one by one\n    for (const filePath in symbolIndex) {\n      // Check for cancellation before processing each file\n      if (progress?.isCancelled?.()) {\n        progress?.report({ message: 'Docstring generation cancelled.' });\n        return;\n      }\n      \n      fileCount++;\n      \n      // Get symbols for this file\n      const fileSymbols = symbolIndex[filePath];\n      \n      // Filter symbols based on the generation mode\n      const getSymbolsToProcess = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return fileSymbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring));\n        }\n        return fileSymbols;\n      };\n      \n      const symbolsToProcess = getSymbolsToProcess();\n      \n      // Log some diagnostics in debug mode\n      console.log(`File: ${filePath}, Total symbols: ${fileSymbols.length}, Symbols to process: ${symbolsToProcess.length}`);\n      \n      // Skip file if no symbols need processing\n      if (symbolsToProcess.length === 0) {\n        if (skipExisting) {\n          skippedSymbolCount += fileSymbols.length;\n        }\n        continue;\n      }\n      \n      // Update progress for each file\n      const getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      };\n      \n      progress?.report({ message: getProgressMessage() });\n      \n      // Find the full file path\n      const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n      if (!fullFilePath) {\n        continue;\n      }\n      \n      // Read the file content\n      const fileContent = await FileIoService.readFileContent(fullFilePath);\n      \n      try {\n        // Generate docstrings using the dedicated service\n        const updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({\n          fileContent,\n          symbols: symbolsToProcess,\n          client\n        });\n        \n        // Reset consecutive error count on success\n        consecutiveErrorCount = 0;\n        \n        // Check for cancellation after processing symbols\n        if (progress?.isCancelled?.()) {\n          progress?.report({ message: 'Docstring generation cancelled.' });\n          return;\n        }\n        \n        // Update the symbol index with generated docstrings\n        for (const updatedSymbol of updatedSymbols) {\n          // Find the actual symbol in the fileSymbols array\n          const actualSymbolIndex = fileSymbols.findIndex(\n            s => s.name === updatedSymbol.name && s.type === updatedSymbol.type\n          );\n          \n          if (actualSymbolIndex !== -1) {\n            fileSymbols[actualSymbolIndex].docstring = updatedSymbol.docstring;\n            processedSymbolCount++;\n            console.log(`Generated docstring for ${updatedSymbol.name}`);\n          }\n        }\n        \n        // Write the updated symbol index to file after each file is processed\n        await SymbolIndexService.writeSymbolIndex(rootPath, symbolIndex);\n        \n        // Small delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 500));\n      } catch (error) {\n        console.error(`Error generating docstrings for ${filePath}:`, error);\n        \n        // Check if this is an error that persisted after retries\n        if (error instanceof Error) {\n          // Increment consecutive error counter\n          consecutiveErrorCount++;\n          \n          // Check properties added by our enhanced error handling\n          const shouldCancel = (error as any).shouldCancelGeneration === true || \n                              (error as any).isServerError === true ||\n                              consecutiveErrorCount >= MAX_CONSECUTIVE_ERRORS;\n          \n          if (shouldCancel) {\n            // Show cancellation message\n            const errorMessage = 'Docstring generation cancelled due to persistent errors. Please try again later.';\n            vscode.window.showErrorMessage(errorMessage);\n            progress?.report({ message: errorMessage });\n            \n            // Save work done so far\n            await SymbolIndexService.writeSymbolIndex(rootPath, symbolIndex);\n            \n            console.error('Docstring generation cancelled due to persistent errors:', error);\n            return; // Exit the function\n          }\n        }\n      }\n    }\n    \n    // Check for cancellation before final reporting\n    if (progress?.isCancelled?.()) {\n      progress?.report({ message: 'Docstring generation cancelled.' });\n      return;\n    }\n    \n    const getCompletionMessage = () => {\n      if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n        return `Docstring generation complete. Generated ${processedSymbolCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`;\n      }\n      return 'Docstring generation complete.';\n    };\n    \n    progress?.report({ message: getCompletionMessage() });\n  } catch (error) {\n    console.error('Error generating docstrings:', error);\n  }\n}",
      "dependents": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 262,
          "contextSnippet": "    const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n    \n    // Generate docstrings using the unified function\n    await generateDocstrings({\n      symbolIndex,\n      client,\n      projectFiles,"
        }
      ],
      "depends_on": [
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 48
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 49
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 50
        },
        {
          "name": "DocstringGenerationParams",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 54
        },
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 64
        },
        {
          "name": "fileCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 74
        },
        {
          "name": "getSymbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 87
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 90
        },
        {
          "name": "symbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 90
        },
        {
          "name": "skipExisting",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 94
        },
        {
          "name": "skippedSymbolCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 95
        },
        {
          "name": "getProgressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 108
        },
        {
          "name": "fullFilePath",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 112
        },
        {
          "name": "fileContent",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 122
        },
        {
          "name": "consecutiveErrorCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 128
        },
        {
          "name": "updatedSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 137
        },
        {
          "name": "actualSymbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 143
        },
        {
          "name": "processedSymbolCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 145
        },
        {
          "name": "MAX_CONSECUTIVE_ERRORS",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 166
        },
        {
          "name": "shouldCancel",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 168
        },
        {
          "name": "errorMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 171
        },
        {
          "name": "getCompletionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 197
        }
      ]
    },
    {
      "name": "totalFiles",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 57,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "totalFiles = Object.keys(symbolIndex).length",
      "dependents": [
        {
          "name": "getProgressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103,
          "contextSnippet": "      // Update progress for each file\n      const getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 58,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "fileCount = 0",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 74,
          "contextSnippet": "        return;\n      }\n      \n      fileCount++;\n      \n      // Get symbols for this file\n      const fileSymbols = symbolIndex[filePath];"
        },
        {
          "name": "getProgressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103,
          "contextSnippet": "      // Update progress for each file\n      const getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "processedSymbolCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 59,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "processedSymbolCount = 0",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 145,
          "contextSnippet": "          \n          if (actualSymbolIndex !== -1) {\n            fileSymbols[actualSymbolIndex].docstring = updatedSymbol.docstring;\n            processedSymbolCount++;\n            console.log(`Generated docstring for ${updatedSymbol.name}`);\n          }\n        }"
        },
        {
          "name": "getCompletionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 192,
          "contextSnippet": "    \n    const getCompletionMessage = () => {\n      if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n        return `Docstring generation complete. Generated ${processedSymbolCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`;\n      }\n      return 'Docstring generation complete.';\n    };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "skippedSymbolCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 60,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "skippedSymbolCount = 0",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 95,
          "contextSnippet": "      // Skip file if no symbols need processing\n      if (symbolsToProcess.length === 0) {\n        if (skipExisting) {\n          skippedSymbolCount += fileSymbols.length;\n        }\n        continue;\n      }"
        },
        {
          "name": "getCompletionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 192,
          "contextSnippet": "    \n    const getCompletionMessage = () => {\n      if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n        return `Docstring generation complete. Generated ${processedSymbolCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`;\n      }\n      return 'Docstring generation complete.';\n    };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "consecutiveErrorCount",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 61,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "consecutiveErrorCount = 0",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 128,
          "contextSnippet": "        });\n        \n        // Reset consecutive error count on success\n        consecutiveErrorCount = 0;\n        \n        // Check for cancellation after processing symbols\n        if (progress?.isCancelled?.()) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "MAX_CONSECUTIVE_ERRORS",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 62,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "MAX_CONSECUTIVE_ERRORS = 3",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 166,
          "contextSnippet": "          // Check properties added by our enhanced error handling\n          const shouldCancel = (error as any).shouldCancelGeneration === true || \n                              (error as any).isServerError === true ||\n                              consecutiveErrorCount >= MAX_CONSECUTIVE_ERRORS;\n          \n          if (shouldCancel) {\n            // Show cancellation message"
        }
      ],
      "depends_on": []
    },
    {
      "name": "skipExisting",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 64,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "skipExisting = mode === DocstringGenerationMode.GENERATE_MISSING",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 94,
          "contextSnippet": "      \n      // Skip file if no symbols need processing\n      if (symbolsToProcess.length === 0) {\n        if (skipExisting) {\n          skippedSymbolCount += fileSymbols.length;\n        }\n        continue;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 77,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[filePath]",
      "dependents": [
        {
          "name": "getSymbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 82,
          "contextSnippet": "      // Filter symbols based on the generation mode\n      const getSymbolsToProcess = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return fileSymbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring));\n        }\n        return fileSymbols;\n      };"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 90,
          "contextSnippet": "      const symbolsToProcess = getSymbolsToProcess();\n      \n      // Log some diagnostics in debug mode\n      console.log(`File: ${filePath}, Total symbols: ${fileSymbols.length}, Symbols to process: ${symbolsToProcess.length}`);\n      \n      // Skip file if no symbols need processing\n      if (symbolsToProcess.length === 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "getSymbolsToProcess",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 80,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "getSymbolsToProcess = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return fileSymbols.filter(symbol => DocstringGenerationService.isEmptyDocstring(symbol.docstring));\n        }\n        return fileSymbols;\n      }",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 87,
          "contextSnippet": "        return fileSymbols;\n      };\n      \n      const symbolsToProcess = getSymbolsToProcess();\n      \n      // Log some diagnostics in debug mode\n      console.log(`File: ${filePath}, Total symbols: ${fileSymbols.length}, Symbols to process: ${symbolsToProcess.length}`);"
        }
      ],
      "depends_on": [
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 81
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 82
        }
      ]
    },
    {
      "name": "symbolsToProcess",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 87,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolsToProcess = getSymbolsToProcess()",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 90,
          "contextSnippet": "      const symbolsToProcess = getSymbolsToProcess();\n      \n      // Log some diagnostics in debug mode\n      console.log(`File: ${filePath}, Total symbols: ${fileSymbols.length}, Symbols to process: ${symbolsToProcess.length}`);\n      \n      // Skip file if no symbols need processing\n      if (symbolsToProcess.length === 0) {"
        },
        {
          "name": "getProgressMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103,
          "contextSnippet": "      // Update progress for each file\n      const getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "getProgressMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 101,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "getProgressMessage = () => {\n        if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n          return `Generating missing docstrings for file ${fileCount}/${totalFiles}: ${filePath} (${symbolsToProcess.length} symbols)`;\n        }\n        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      }",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 108,
          "contextSnippet": "        return `Generating docstrings for file ${fileCount}/${totalFiles}: ${filePath}`;\n      };\n      \n      progress?.report({ message: getProgressMessage() });\n      \n      // Find the full file path\n      const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);"
        }
      ],
      "depends_on": [
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 102
        },
        {
          "name": "fileCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103
        },
        {
          "name": "totalFiles",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103
        },
        {
          "name": "symbolsToProcess",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 103
        }
      ]
    },
    {
      "name": "fullFilePath",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 111,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath)",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 112,
          "contextSnippet": "      \n      // Find the full file path\n      const fullFilePath = projectFiles.find(p => FileSystemService.normalizeFilePath(p, rootPath) === filePath);\n      if (!fullFilePath) {\n        continue;\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileContent",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 117,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileContent = await FileIoService.readFileContent(fullFilePath)",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 122,
          "contextSnippet": "      try {\n        // Generate docstrings using the dedicated service\n        const updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({\n          fileContent,\n          symbols: symbolsToProcess,\n          client\n        });"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedSymbols",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 121,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "updatedSymbols = await DocstringGenerationService.generateDocstringsForSymbols({\n          fileContent,\n          symbols: symbolsToProcess,\n          client\n        })",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 137,
          "contextSnippet": "        }\n        \n        // Update the symbol index with generated docstrings\n        for (const updatedSymbol of updatedSymbols) {\n          // Find the actual symbol in the fileSymbols array\n          const actualSymbolIndex = fileSymbols.findIndex(\n            s => s.name === updatedSymbol.name && s.type === updatedSymbol.type"
        }
      ],
      "depends_on": []
    },
    {
      "name": "actualSymbolIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 139,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "actualSymbolIndex = fileSymbols.findIndex(\n            s => s.name === updatedSymbol.name && s.type === updatedSymbol.type\n          )",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 143,
          "contextSnippet": "            s => s.name === updatedSymbol.name && s.type === updatedSymbol.type\n          );\n          \n          if (actualSymbolIndex !== -1) {\n            fileSymbols[actualSymbolIndex].docstring = updatedSymbol.docstring;\n            processedSymbolCount++;\n            console.log(`Generated docstring for ${updatedSymbol.name}`);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "shouldCancel",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 164,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "shouldCancel = (error as any).shouldCancelGeneration === true || \n                              (error as any).isServerError === true ||\n                              consecutiveErrorCount >= MAX_CONSECUTIVE_ERRORS",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 168,
          "contextSnippet": "                              (error as any).isServerError === true ||\n                              consecutiveErrorCount >= MAX_CONSECUTIVE_ERRORS;\n          \n          if (shouldCancel) {\n            // Show cancellation message\n            const errorMessage = 'Docstring generation cancelled due to persistent errors. Please try again later.';\n            vscode.window.showErrorMessage(errorMessage);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "errorMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 170,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "errorMessage = 'Docstring generation cancelled due to persistent errors. Please try again later.'",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 171,
          "contextSnippet": "          if (shouldCancel) {\n            // Show cancellation message\n            const errorMessage = 'Docstring generation cancelled due to persistent errors. Please try again later.';\n            vscode.window.showErrorMessage(errorMessage);\n            progress?.report({ message: errorMessage });\n            \n            // Save work done so far"
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 284,
          "contextSnippet": "    \n    if (error instanceof Error) {\n      if (error.message.includes('500')) {\n        errorMessage = 'OpenAI server error (500). The service is temporarily unavailable. Please try again later.';\n      } else if (error.message.includes('401') || error.message.includes('API key')) {\n        errorMessage = 'Invalid or missing OpenAI API key. Please check your API key configuration.';\n      } else if (error.message.includes('429') || error.message.includes('rate limit')) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "getCompletionMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 190,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "getCompletionMessage = () => {\n      if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n        return `Docstring generation complete. Generated ${processedSymbolCount} docstrings, skipped ${skippedSymbolCount} existing docstrings.`;\n      }\n      return 'Docstring generation complete.';\n    }",
      "dependents": [
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 197,
          "contextSnippet": "      return 'Docstring generation complete.';\n    };\n    \n    progress?.report({ message: getCompletionMessage() });\n  } catch (error) {\n    console.error('Error generating docstrings:', error);\n  }"
        }
      ],
      "depends_on": [
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 191
        },
        {
          "name": "processedSymbolCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 192
        },
        {
          "name": "skippedSymbolCount",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 192
        }
      ]
    },
    {
      "name": "generateDocstringsUnified",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 211,
        "character": 13
      },
      "docstring": "/**\n * Unified function for generating docstrings with different modes\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore during file processing\n * @param progress - Optional progress reporter\n * @param token - Optional cancellation token\n * @param mode - Docstring generation mode\n */",
      "snippet": "generateDocstringsUnified = async (\n  rootPath: string,\n  ignoredPatterns: string[] = [],\n  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken,\n  mode: DocstringGenerationMode = DocstringGenerationMode.GENERATE_ALL\n): Promise<void> => {\n  try {\n    // Ensure .cursortest directory exists\n    await WorkspaceService.ensureCursorTestDir(rootPath);\n    \n    // Check if symbol-index.json exists and load it\n    const symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath, \n      'Symbol index not found. Please build the symbol index first.'\n    );\n    \n    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {\n        await FileIoService.writeSymbolsNeedingDocstrings(\n          rootPath, \n          symbolIndex, \n          DocstringGenerationService.isEmptyDocstring\n        );\n      }\n      \n      progress?.report({ \n        message: `Preparing to generate missing docstrings (${validation.emptyDocstrings} symbols need processing)...` \n      });\n    } else {\n      progress?.report({ message: 'Preparing to generate all docstrings...' });\n    }\n    \n    // Get environment variables for OpenAI\n    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }\n    \n    // Get project files\n    const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n    \n    // Generate docstrings using the unified function\n    await generateDocstrings({\n      symbolIndex,\n      client,\n      projectFiles,\n      rootPath,\n      progress: progress ? adaptVSCodeProgress(progress, token) : undefined,\n      mode\n    });\n    \n    const completionMessage = mode === DocstringGenerationMode.GENERATE_MISSING\n      ? 'Missing docstring generation completed successfully.'\n      : 'Docstring generation completed successfully.';\n    \n    progress?.report({ message: completionMessage });\n  } catch (error) {\n    console.error('Error generating docstrings:', error);\n    \n    // Handle different error types with user-friendly messages\n    let errorMessage = 'An error occurred during docstring generation.';\n    \n    if (error instanceof Error) {\n      if (error.message.includes('500')) {\n        errorMessage = 'OpenAI server error (500). The service is temporarily unavailable. Please try again later.';\n      } else if (error.message.includes('401') || error.message.includes('API key')) {\n        errorMessage = 'Invalid or missing OpenAI API key. Please check your API key configuration.';\n      } else if (error.message.includes('429') || error.message.includes('rate limit')) {\n        errorMessage = 'OpenAI API rate limit exceeded. Please wait a few moments and try again.';\n      } else if (error.message.includes('timeout')) {\n        errorMessage = 'Request to OpenAI API timed out. Please check your network connection and try again.';\n      } else if (error.message.includes('retry') || (error as any).shouldCancelGeneration === true) {\n        errorMessage = 'Docstring generation failed after multiple retry attempts. Please try again later.';\n      } else if ((error as any).isServerError === true) {\n        errorMessage = 'OpenAI service is experiencing issues. Docstring generation has been cancelled. Please try again later.';\n      } else {\n        // For other errors, include the actual error message\n        errorMessage = `Error generating docstrings: ${error.message}`;\n      }\n    }\n    \n    vscode.window.showErrorMessage(errorMessage);\n    \n    // Throw a standard error with the friendly message\n    throw new Error(errorMessage);\n  }\n}",
      "dependents": [
        {
          "name": "generateDocstringIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 321,
          "contextSnippet": "  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken\n): Promise<void> => {\n  return generateDocstringsUnified(\n    rootPath,\n    ignoredPatterns,\n    progress,"
        },
        {
          "name": "resumeDocstringGeneration",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 343,
          "contextSnippet": "  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken\n): Promise<void> => {\n  return generateDocstringsUnified(\n    rootPath,\n    ignoredPatterns,\n    progress,"
        }
      ],
      "depends_on": [
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 216
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 230
        },
        {
          "name": "validation",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 231
        },
        {
          "name": "emptyDocstrings",
          "filePath": "src/features/generate-docstring/docstring-generation-service.ts",
          "line": 234
        },
        {
          "name": "envVars",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 253
        },
        {
          "name": "client",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 254
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 262
        },
        {
          "name": "projectFiles",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 265
        },
        {
          "name": "completionMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 275
        },
        {
          "name": "errorMessage",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 284
        }
      ]
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 223,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await SymbolIndexService.getSymbolIndexOrThrow(\n      rootPath, \n      'Symbol index not found. Please build the symbol index first.'\n    )",
      "dependents": [
        {
          "name": "DocstringGenerationParams",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 34,
          "contextSnippet": " * Interface for docstring generation parameters\n */\ninterface DocstringGenerationParams {\n  symbolIndex: SymbolIndex;\n  client: OpenAI;\n  projectFiles: string[];\n  rootPath: string;"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 48,
          "contextSnippet": " * @returns Promise that resolves when docstrings are generated\n */\nexport const generateDocstrings = async ({\n  symbolIndex,\n  client,\n  projectFiles,\n  rootPath,"
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 230,
          "contextSnippet": "    \n    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings"
        }
      ],
      "depends_on": []
    },
    {
      "name": "validation",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 230,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "validation = DocstringGenerationService.validateSymbolIndex(symbolIndex)",
      "dependents": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 231,
          "contextSnippet": "    // If generating only missing docstrings, validate and report stats\n    if (mode === DocstringGenerationMode.GENERATE_MISSING) {\n      const validation = DocstringGenerationService.validateSymbolIndex(symbolIndex);\n      console.log('Symbol index validation:', validation);\n      \n      // Debug: Write a file with the symbols that need docstrings\n      if (validation.emptyDocstrings > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "envVars",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 250,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "envVars = OpenAiService.loadEnvironmentVars(rootPath)",
      "dependents": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 253,
          "contextSnippet": "    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "client",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 253,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY)",
      "dependents": [
        {
          "name": "DocstringGenerationParams",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 35,
          "contextSnippet": " */\ninterface DocstringGenerationParams {\n  symbolIndex: SymbolIndex;\n  client: OpenAI;\n  projectFiles: string[];\n  rootPath: string;\n  progress?: ProgressReporter;"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 49,
          "contextSnippet": " */\nexport const generateDocstrings = async ({\n  symbolIndex,\n  client,\n  projectFiles,\n  rootPath,\n  progress,"
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 254,
          "contextSnippet": "    \n    // Create OpenAI client for docstring generation\n    const client = OpenAiService.createOpenAIClient(envVars.OPENAI_API_KEY);\n    if (!client) {\n      throw new Error('OpenAI client not created. Check your API key configuration.');\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "projectFiles",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 259,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "DocstringGenerationParams",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 36,
          "contextSnippet": "interface DocstringGenerationParams {\n  symbolIndex: SymbolIndex;\n  client: OpenAI;\n  projectFiles: string[];\n  rootPath: string;\n  progress?: ProgressReporter;\n  mode: DocstringGenerationMode;"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 50,
          "contextSnippet": "export const generateDocstrings = async ({\n  symbolIndex,\n  client,\n  projectFiles,\n  rootPath,\n  progress,\n  mode"
        },
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 265,
          "contextSnippet": "    await generateDocstrings({\n      symbolIndex,\n      client,\n      projectFiles,\n      rootPath,\n      progress: progress ? adaptVSCodeProgress(progress, token) : undefined,\n      mode"
        }
      ],
      "depends_on": []
    },
    {
      "name": "completionMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 271,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "completionMessage = mode === DocstringGenerationMode.GENERATE_MISSING\n      ? 'Missing docstring generation completed successfully.'\n      : 'Docstring generation completed successfully.'",
      "dependents": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 275,
          "contextSnippet": "      ? 'Missing docstring generation completed successfully.'\n      : 'Docstring generation completed successfully.';\n    \n    progress?.report({ message: completionMessage });\n  } catch (error) {\n    console.error('Error generating docstrings:', error);\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "errorMessage",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 280,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "errorMessage = 'An error occurred during docstring generation.'",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "generateDocstringIndex",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 315,
        "character": 13
      },
      "docstring": "/**\n * Generates docstrings for an existing symbol index\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore during file processing\n * @param progress - Optional progress reporter\n * @param token - Optional cancellation token\n */",
      "snippet": "generateDocstringIndex = async (\n  rootPath: string,\n  ignoredPatterns: string[] = [],\n  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken\n): Promise<void> => {\n  return generateDocstringsUnified(\n    rootPath,\n    ignoredPatterns,\n    progress,\n    token,\n    DocstringGenerationMode.GENERATE_ALL\n  );\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 321
        },
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 326
        }
      ]
    },
    {
      "name": "resumeDocstringGeneration",
      "type": "variable",
      "filePath": "src/features/generate-docstring/generate-docstring.ts",
      "location": {
        "line": 337,
        "character": 13
      },
      "docstring": "/**\n * Resumes docstring generation for symbols that don't have docstrings\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore during file processing\n * @param progress - Optional progress reporter\n * @param token - Optional cancellation token\n */",
      "snippet": "resumeDocstringGeneration = async (\n  rootPath: string,\n  ignoredPatterns: string[] = [],\n  progress?: vscode.Progress<{ message?: string }>,\n  token?: vscode.CancellationToken\n): Promise<void> => {\n  return generateDocstringsUnified(\n    rootPath,\n    ignoredPatterns,\n    progress,\n    token,\n    DocstringGenerationMode.GENERATE_MISSING\n  );\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "generateDocstringsUnified",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 343
        },
        {
          "name": "DocstringGenerationMode",
          "filePath": "src/features/generate-docstring/generate-docstring.ts",
          "line": 348
        }
      ]
    }
  ],
  "src/features/merge-json/merge-json-command.ts": [
    {
      "name": "mergeJsonForVisualizationCommand",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 10,
        "character": 13
      },
      "docstring": "/**\n * Handles execution of the merge JSON for visualization command\n * @returns A function that handles the command\n */",
      "snippet": "mergeJsonForVisualizationCommand = (): vscode.Disposable => {\n  return vscode.commands.registerCommand('cursorcrawl.mergeJsonForVisualization', async () => {\n    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }\n      \n      // Show progress indicator\n      await vscode.window.withProgress(\n        {\n          location: vscode.ProgressLocation.Notification,\n          title: 'Merging JSON files...',\n          cancellable: false\n        },\n        async (progress) => {\n          progress.report({ message: 'Processing files...' });\n          \n          try {\n            // Check if required files exist\n            const { symbolIndexPath, duplicateAnalysisPath } = MergeJsonService.getFilePaths(rootPath);\n            \n            const symbolIndexExists = await fs.pathExists(symbolIndexPath);\n            const duplicateAnalysisExists = await fs.pathExists(duplicateAnalysisPath);\n            \n            if (!symbolIndexExists) {\n              throw new Error('Symbol index file not found. Please run \"Build Symbol Index\" command first.');\n            }\n            \n            if (!duplicateAnalysisExists) {\n              throw new Error('Duplicate analysis file not found. Please run \"Analyze Duplicate Logic\" command first.');\n            }\n            \n            try {\n              progress.report({ message: 'Reading input files...' });\n              \n              // Preview the file sizes and basic structure\n              const symbolIndexStats = await fs.stat(symbolIndexPath);\n              const duplicateAnalysisStats = await fs.stat(duplicateAnalysisPath);\n              \n              console.log(`Symbol index file size: ${symbolIndexStats.size} bytes`);\n              console.log(`Duplicate analysis file size: ${duplicateAnalysisStats.size} bytes`);\n              \n              // Merge the files\n              progress.report({ message: 'Merging data...' });\n              const mergedJsonPath = await MergeJsonService.mergeJsonFiles(rootPath);\n              \n              vscode.window.showInformationMessage(\n                `Successfully merged JSON files. Output saved to ${mergedJsonPath}`,\n                'Open File'\n              ).then(selection => {\n                if (selection === 'Open File') {\n                  vscode.commands.executeCommand('vscode.open', vscode.Uri.file(mergedJsonPath));\n                }\n              });\n            } catch (mergeError) {\n              console.error('Error during merge operation:', mergeError);\n              \n              // Check if the error is due to file format issues\n              if (mergeError instanceof Error && \n                  (mergeError.message.includes('not a function') || \n                   mergeError.message.includes('is not iterable') ||\n                   mergeError.message.includes('JSON'))) {\n                \n                vscode.window.showErrorMessage(\n                  `Failed to merge JSON files: The format of the duplicate analysis file is not as expected. ` +\n                  `Error: ${mergeError.message}`,\n                  'View File'\n                ).then(selection => {\n                  if (selection === 'View File') {\n                    vscode.commands.executeCommand('vscode.open', vscode.Uri.file(duplicateAnalysisPath));\n                  }\n                });\n              } else {\n                throw mergeError; // Re-throw for general error handling\n              }\n            }\n          } catch (error) {\n            console.error('Error in merge JSON command:', error);\n            vscode.window.showErrorMessage(`Failed to merge JSON files: ${error instanceof Error ? error.message : String(error)}`);\n          }\n        }\n      );\n    } catch (error) {\n      console.error('Error in merge JSON command (outer):', error);\n      vscode.window.showErrorMessage(`Error merging JSON files: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  });\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "rootPath",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 15
        },
        {
          "name": "symbolIndexExists",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 37
        },
        {
          "name": "duplicateAnalysisExists",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 41
        },
        {
          "name": "symbolIndexStats",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 52
        },
        {
          "name": "duplicateAnalysisStats",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 53
        },
        {
          "name": "mergedJsonPath",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 60
        }
      ]
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 13,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "rootPath = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 15,
          "contextSnippet": "    try {\n      const rootPath = WorkspaceService.getWorkspaceFolder();\n      \n      if (!rootPath) {\n        vscode.window.showErrorMessage('No workspace folder found.');\n        return;\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndexExists",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 34,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "symbolIndexExists = await fs.pathExists(symbolIndexPath)",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 37,
          "contextSnippet": "            const symbolIndexExists = await fs.pathExists(symbolIndexPath);\n            const duplicateAnalysisExists = await fs.pathExists(duplicateAnalysisPath);\n            \n            if (!symbolIndexExists) {\n              throw new Error('Symbol index file not found. Please run \"Build Symbol Index\" command first.');\n            }\n            "
        }
      ],
      "depends_on": []
    },
    {
      "name": "duplicateAnalysisExists",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 35,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "duplicateAnalysisExists = await fs.pathExists(duplicateAnalysisPath)",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 41,
          "contextSnippet": "              throw new Error('Symbol index file not found. Please run \"Build Symbol Index\" command first.');\n            }\n            \n            if (!duplicateAnalysisExists) {\n              throw new Error('Duplicate analysis file not found. Please run \"Analyze Duplicate Logic\" command first.');\n            }\n            "
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndexStats",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 49,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "symbolIndexStats = await fs.stat(symbolIndexPath)",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 52,
          "contextSnippet": "              const symbolIndexStats = await fs.stat(symbolIndexPath);\n              const duplicateAnalysisStats = await fs.stat(duplicateAnalysisPath);\n              \n              console.log(`Symbol index file size: ${symbolIndexStats.size} bytes`);\n              console.log(`Duplicate analysis file size: ${duplicateAnalysisStats.size} bytes`);\n              \n              // Merge the files"
        }
      ],
      "depends_on": []
    },
    {
      "name": "duplicateAnalysisStats",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 50,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "duplicateAnalysisStats = await fs.stat(duplicateAnalysisPath)",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 53,
          "contextSnippet": "              const duplicateAnalysisStats = await fs.stat(duplicateAnalysisPath);\n              \n              console.log(`Symbol index file size: ${symbolIndexStats.size} bytes`);\n              console.log(`Duplicate analysis file size: ${duplicateAnalysisStats.size} bytes`);\n              \n              // Merge the files\n              progress.report({ message: 'Merging data...' });"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedJsonPath",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-command.ts",
      "location": {
        "line": 57,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "mergedJsonPath = await MergeJsonService.mergeJsonFiles(rootPath)",
      "dependents": [
        {
          "name": "mergeJsonForVisualizationCommand",
          "filePath": "src/features/merge-json/merge-json-command.ts",
          "line": 60,
          "contextSnippet": "              const mergedJsonPath = await MergeJsonService.mergeJsonFiles(rootPath);\n              \n              vscode.window.showInformationMessage(\n                `Successfully merged JSON files. Output saved to ${mergedJsonPath}`,\n                'Open File'\n              ).then(selection => {\n                if (selection === 'Open File') {"
        }
      ],
      "depends_on": []
    }
  ],
  "src/features/merge-json/merge-json-service.ts": [
    {
      "name": "SYMBOL_INDEX_FILENAME",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 8,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "SYMBOL_INDEX_FILENAME = 'symbol-index.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 36,
          "contextSnippet": "  getFilePaths(rootPath: string) {\n    const cursorTestDir = WorkspaceService.getCursorTestDir(rootPath);\n    return {\n      symbolIndexPath: path.join(cursorTestDir, SYMBOL_INDEX_FILENAME),\n      duplicateAnalysisPath: path.join(cursorTestDir, DUPLICATE_ANALYSIS_FILENAME),\n      mergedJsonPath: path.join(cursorTestDir, MERGED_JSON_FILENAME)\n    };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DUPLICATE_ANALYSIS_FILENAME",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 9,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DUPLICATE_ANALYSIS_FILENAME = 'duplicate-analysis.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 37,
          "contextSnippet": "    const cursorTestDir = WorkspaceService.getCursorTestDir(rootPath);\n    return {\n      symbolIndexPath: path.join(cursorTestDir, SYMBOL_INDEX_FILENAME),\n      duplicateAnalysisPath: path.join(cursorTestDir, DUPLICATE_ANALYSIS_FILENAME),\n      mergedJsonPath: path.join(cursorTestDir, MERGED_JSON_FILENAME)\n    };\n  },"
        }
      ],
      "depends_on": []
    },
    {
      "name": "MERGED_JSON_FILENAME",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 10,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "MERGED_JSON_FILENAME = 'merged-json-for-viz.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 38,
          "contextSnippet": "    return {\n      symbolIndexPath: path.join(cursorTestDir, SYMBOL_INDEX_FILENAME),\n      duplicateAnalysisPath: path.join(cursorTestDir, DUPLICATE_ANALYSIS_FILENAME),\n      mergedJsonPath: path.join(cursorTestDir, MERGED_JSON_FILENAME)\n    };\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DuplicateAnalysisEntry",
      "type": "interface",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 15,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DuplicateAnalysisEntry {\n  filePath: string;\n  name: string;\n  type: string;\n  score: number;\n  duplicateFilePath?: string;\n  duplicateName?: string;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 64,
          "contextSnippet": "   * @param duplicateAnalysisPath - Path to the duplicate analysis file\n   * @returns The duplicate analysis data normalized to an array of entries\n   */\n  async readDuplicateAnalysis(duplicateAnalysisPath: string): Promise<DuplicateAnalysisEntry[]> {\n    try {\n      if (!await fs.pathExists(duplicateAnalysisPath)) {\n        throw new Error(`Duplicate analysis not found at: ${duplicateAnalysisPath}`);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "MergeJsonService",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 27,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "MergeJsonService = {\n  /**\n   * Gets the path to the source files and output file\n   * @param rootPath - The workspace root path\n   * @returns The paths to the source and output files\n   */\n  getFilePaths(rootPath: string) {\n    const cursorTestDir = WorkspaceService.getCursorTestDir(rootPath);\n    return {\n      symbolIndexPath: path.join(cursorTestDir, SYMBOL_INDEX_FILENAME),\n      duplicateAnalysisPath: path.join(cursorTestDir, DUPLICATE_ANALYSIS_FILENAME),\n      mergedJsonPath: path.join(cursorTestDir, MERGED_JSON_FILENAME)\n    };\n  },\n\n  /**\n   * Reads the symbol index from disk\n   * @param symbolIndexPath - Path to the symbol index file\n   * @returns The symbol index\n   */\n  async readSymbolIndex(symbolIndexPath: string): Promise<SymbolIndex> {\n    try {\n      if (!await fs.pathExists(symbolIndexPath)) {\n        throw new Error(`Symbol index not found at: ${symbolIndexPath}`);\n      }\n      return await fs.readJson(symbolIndexPath) as SymbolIndex;\n    } catch (error) {\n      console.error('Error reading symbol index:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Reads the duplicate analysis data from disk\n   * @param duplicateAnalysisPath - Path to the duplicate analysis file\n   * @returns The duplicate analysis data normalized to an array of entries\n   */\n  async readDuplicateAnalysis(duplicateAnalysisPath: string): Promise<DuplicateAnalysisEntry[]> {\n    try {\n      if (!await fs.pathExists(duplicateAnalysisPath)) {\n        throw new Error(`Duplicate analysis not found at: ${duplicateAnalysisPath}`);\n      }\n      \n      // Read the raw data first\n      const rawData = await fs.readJson(duplicateAnalysisPath);\n      \n      // Debug log to see the structure\n      console.log('Duplicate analysis raw data structure:', \n        `Type: ${typeof rawData}, ` +\n        `Is Array: ${Array.isArray(rawData)}, ` + \n        `Keys: ${typeof rawData === 'object' && rawData !== null ? Object.keys(rawData).join(', ') : 'none'}`\n      );\n      \n      // Sample data if available\n      if (typeof rawData === 'object' && rawData !== null) {\n        if (Array.isArray(rawData) && rawData.length > 0) {\n          console.log('Sample array item:', JSON.stringify(rawData[0]).substring(0, 200));\n        } else {\n          const sampleKey = Object.keys(rawData)[0];\n          if (sampleKey) {\n            console.log('Sample object property:', sampleKey, JSON.stringify(rawData[sampleKey]).substring(0, 200));\n          }\n        }\n      }\n      \n      // Normalize the data to an array of entries\n      let normalizedData: DuplicateAnalysisEntry[] = [];\n      \n      // Try different approaches to parse the data based on common structures\n      try {\n        if (Array.isArray(rawData)) {\n          // Data is already an array\n          normalizedData = this.normalizeArrayData(rawData);\n        } else if (typeof rawData === 'object' && rawData !== null) {\n          // Data is an object, try different approaches\n          normalizedData = this.normalizeObjectData(rawData);\n        }\n      } catch (parseError) {\n        console.error('Error parsing duplicate analysis data:', parseError);\n        // Continue with empty array if parsing fails\n      }\n      \n      console.log(`Normalized duplicate analysis data: ${normalizedData.length} entries`);\n      if (normalizedData.length > 0) {\n        console.log('First normalized entry:', JSON.stringify(normalizedData[0]));\n      }\n      \n      return normalizedData;\n    } catch (error) {\n      console.error('Error reading duplicate analysis:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Normalizes array data to the expected format\n   * @param data - The raw array data\n   * @returns Normalized array of DuplicateAnalysisEntry objects\n   */\n  normalizeArrayData(data: any[]): DuplicateAnalysisEntry[] {\n    return data\n      .filter(item => item && typeof item === 'object')\n      .map(item => {\n        // Create a proper entry with required fields\n        const entry: DuplicateAnalysisEntry = {\n          name: this.getStringProperty(item, 'name', ''),\n          filePath: this.getStringProperty(item, 'filePath', ''),\n          type: this.getStringProperty(item, 'type', 'function'),\n          score: this.getNumberProperty(item, 'score', 0)\n        };\n        \n        // Add optional fields if present\n        if ('duplicateFilePath' in item) {\n          entry.duplicateFilePath = this.getStringProperty(item, 'duplicateFilePath', '');\n        }\n        \n        if ('duplicateName' in item) {\n          entry.duplicateName = this.getStringProperty(item, 'duplicateName', '');\n        }\n        \n        return entry;\n      })\n      // Filter out entries without required fields\n      .filter(entry => entry.name && entry.filePath);\n  },\n  \n  /**\n   * Normalizes object data to the expected format\n   * @param data - The raw object data\n   * @returns Normalized array of DuplicateAnalysisEntry objects\n   */\n  normalizeObjectData(data: Record<string, any>): DuplicateAnalysisEntry[] {\n    const result: DuplicateAnalysisEntry[] = [];\n    \n    // Case 1: Object with 'entries' property that is an array\n    if ('entries' in data && Array.isArray(data.entries)) {\n      return this.normalizeArrayData(data.entries);\n    }\n    \n    // Case 2: Object with results property that is an array\n    if ('results' in data && Array.isArray(data.results)) {\n      return this.normalizeArrayData(data.results);\n    }\n    \n    // Case 3: Object where keys might be filePaths and values are entries or arrays of entries\n    Object.entries(data).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        // Value is an array of entries\n        result.push(...this.normalizeArrayData(value));\n      } else if (value && typeof value === 'object') {\n        // Value is a single entry or an object with entries\n        if ('name' in value && 'score' in value) {\n          // It's likely a single entry\n          const entry: DuplicateAnalysisEntry = {\n            name: this.getStringProperty(value, 'name', ''),\n            filePath: this.getStringProperty(value, 'filePath', key), // Use key as filePath if not present\n            type: this.getStringProperty(value, 'type', 'function'),\n            score: this.getNumberProperty(value, 'score', 0)\n          };\n          \n          if (entry.name && entry.filePath) {\n            result.push(entry);\n          }\n        } else {\n          // It might be an object with entries as properties\n          Object.entries(value).forEach(([subKey, subValue]) => {\n            if (subValue && typeof subValue === 'object' && 'name' in subValue && 'score' in subValue) {\n              const entry: DuplicateAnalysisEntry = {\n                name: this.getStringProperty(subValue, 'name', subKey),\n                filePath: this.getStringProperty(subValue, 'filePath', key),\n                type: this.getStringProperty(subValue, 'type', 'function'),\n                score: this.getNumberProperty(subValue, 'score', 0)\n              };\n              \n              if (entry.name && entry.filePath) {\n                result.push(entry);\n              }\n            }\n          });\n        }\n      }\n    });\n    \n    return result;\n  },\n  \n  /**\n   * Gets a string property from an object with fallback\n   * @param obj - The object to get property from\n   * @param prop - The property name\n   * @param fallback - Fallback value if property is not a string\n   * @returns The property value as string\n   */\n  getStringProperty(obj: Record<string, any>, prop: string, fallback: string): string {\n    return prop in obj && typeof obj[prop] === 'string' ? obj[prop] : fallback;\n  },\n  \n  /**\n   * Gets a number property from an object with fallback\n   * @param obj - The object to get property from\n   * @param prop - The property name\n   * @param fallback - Fallback value if property is not a number\n   * @returns The property value as number\n   */\n  getNumberProperty(obj: Record<string, any>, prop: string, fallback: number): number {\n    return prop in obj && typeof obj[prop] === 'number' ? obj[prop] : fallback;\n  },\n\n  /**\n   * Merges symbol index with duplicate analysis scores\n   * @param symbolIndex - The symbol index\n   * @param duplicateAnalysis - The duplicate analysis data\n   * @returns The merged symbol index with scores\n   */\n  mergeJsonData(\n    symbolIndex: SymbolIndex, \n    duplicateAnalysis: DuplicateAnalysisEntry[]\n  ): SymbolIndexWithScores {\n    // Check if duplicateAnalysis is valid\n    if (!Array.isArray(duplicateAnalysis)) {\n      console.warn('Duplicate analysis data is not an array, converting to empty array');\n      duplicateAnalysis = [];\n    }\n    \n    // Create lookup map for duplicate analysis data by name, filePath, and type\n    const duplicateMap = new Map<string, DuplicateAnalysisEntry>();\n    \n    duplicateAnalysis.forEach(entry => {\n      if (entry && typeof entry === 'object' && 'name' in entry && 'filePath' in entry) {\n        const key = `${entry.name}|${entry.filePath}|${entry.type || ''}`;\n        duplicateMap.set(key, entry);\n      }\n    });\n    \n    // Create a new object with the merged data\n    const mergedIndex: SymbolIndexWithScores = {};\n    \n    // Process each file in the symbol index\n    Object.entries(symbolIndex).forEach(([filePath, entries]) => {\n      // Create a new array for the merged entries\n      mergedIndex[filePath] = entries.map(entry => {\n        // Look for matching duplicate analysis entry\n        const key = `${entry.name}|${entry.filePath}|${entry.type}`;\n        const duplicateEntry = duplicateMap.get(key);\n        \n        // Create the merged entry\n        const mergedEntry: SymbolIndexEntryWithScores = {\n          ...entry,\n          scores: []\n        };\n        \n        // Add score if available\n        if (duplicateEntry && typeof duplicateEntry.score === 'number') {\n          mergedEntry.scores.push({\n            type: 'duplicateAnalysis',\n            score: duplicateEntry.score\n          });\n        }\n        \n        return mergedEntry;\n      });\n    });\n    \n    return mergedIndex;\n  },\n\n  /**\n   * Writes the merged JSON to disk\n   * @param mergedJsonPath - Path to write the merged JSON\n   * @param mergedJson - The merged JSON data\n   */\n  async writeMergedJson(mergedJsonPath: string, mergedJson: SymbolIndexWithScores): Promise<void> {\n    try {\n      await fs.writeJson(mergedJsonPath, mergedJson, { spaces: 2 });\n      console.log(`Merged JSON written to ${mergedJsonPath}`);\n    } catch (error) {\n      console.error('Error writing merged JSON:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Performs the complete merge operation\n   * @param rootPath - The workspace root path\n   * @returns The path to the merged JSON file\n   */\n  async mergeJsonFiles(rootPath: string): Promise<string> {\n    const { symbolIndexPath, duplicateAnalysisPath, mergedJsonPath } = this.getFilePaths(rootPath);\n    \n    // Read the input files\n    const symbolIndex = await this.readSymbolIndex(symbolIndexPath);\n    const duplicateAnalysis = await this.readDuplicateAnalysis(duplicateAnalysisPath);\n    \n    // Merge the data\n    const mergedJson = this.mergeJsonData(symbolIndex, duplicateAnalysis);\n    \n    // Write the merged result\n    await this.writeMergedJson(mergedJsonPath, mergedJson);\n    \n    return mergedJsonPath;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "cursorTestDir",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 34,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "cursorTestDir = WorkspaceService.getCursorTestDir(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 36,
          "contextSnippet": "  getFilePaths(rootPath: string) {\n    const cursorTestDir = WorkspaceService.getCursorTestDir(rootPath);\n    return {\n      symbolIndexPath: path.join(cursorTestDir, SYMBOL_INDEX_FILENAME),\n      duplicateAnalysisPath: path.join(cursorTestDir, DUPLICATE_ANALYSIS_FILENAME),\n      mergedJsonPath: path.join(cursorTestDir, MERGED_JSON_FILENAME)\n    };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "rawData",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 71,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "rawData = await fs.readJson(duplicateAnalysisPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 75,
          "contextSnippet": "      \n      // Debug log to see the structure\n      console.log('Duplicate analysis raw data structure:', \n        `Type: ${typeof rawData}, ` +\n        `Is Array: ${Array.isArray(rawData)}, ` + \n        `Keys: ${typeof rawData === 'object' && rawData !== null ? Object.keys(rawData).join(', ') : 'none'}`\n      );"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sampleKey",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 85,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "sampleKey = Object.keys(rawData)[0]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 86,
          "contextSnippet": "          console.log('Sample array item:', JSON.stringify(rawData[0]).substring(0, 200));\n        } else {\n          const sampleKey = Object.keys(rawData)[0];\n          if (sampleKey) {\n            console.log('Sample object property:', sampleKey, JSON.stringify(rawData[sampleKey]).substring(0, 200));\n          }\n        }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "normalizedData",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 93,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "normalizedData: DuplicateAnalysisEntry[] = []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 99,
          "contextSnippet": "      try {\n        if (Array.isArray(rawData)) {\n          // Data is already an array\n          normalizedData = this.normalizeArrayData(rawData);\n        } else if (typeof rawData === 'object' && rawData !== null) {\n          // Data is an object, try different approaches\n          normalizedData = this.normalizeObjectData(rawData);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "entry",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 131,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "entry: DuplicateAnalysisEntry = {\n          name: this.getStringProperty(item, 'name', ''),\n          filePath: this.getStringProperty(item, 'filePath', ''),\n          type: this.getStringProperty(item, 'type', 'function'),\n          score: this.getNumberProperty(item, 'score', 0)\n        }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 140,
          "contextSnippet": "        \n        // Add optional fields if present\n        if ('duplicateFilePath' in item) {\n          entry.duplicateFilePath = this.getStringProperty(item, 'duplicateFilePath', '');\n        }\n        \n        if ('duplicateName' in item) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 159,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "result: DuplicateAnalysisEntry[] = []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 175,
          "contextSnippet": "    Object.entries(data).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        // Value is an array of entries\n        result.push(...this.normalizeArrayData(value));\n      } else if (value && typeof value === 'object') {\n        // Value is a single entry or an object with entries\n        if ('name' in value && 'score' in value) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "entry",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 180,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "entry: DuplicateAnalysisEntry = {\n            name: this.getStringProperty(value, 'name', ''),\n            filePath: this.getStringProperty(value, 'filePath', key), // Use key as filePath if not present\n            type: this.getStringProperty(value, 'type', 'function'),\n            score: this.getNumberProperty(value, 'score', 0)\n          }",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "entry",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 194,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "entry: DuplicateAnalysisEntry = {\n                name: this.getStringProperty(subValue, 'name', subKey),\n                filePath: this.getStringProperty(subValue, 'filePath', key),\n                type: this.getStringProperty(subValue, 'type', 'function'),\n                score: this.getNumberProperty(subValue, 'score', 0)\n              }",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "duplicateMap",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 252,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "duplicateMap = new Map<string, DuplicateAnalysisEntry>()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 257,
          "contextSnippet": "    duplicateAnalysis.forEach(entry => {\n      if (entry && typeof entry === 'object' && 'name' in entry && 'filePath' in entry) {\n        const key = `${entry.name}|${entry.filePath}|${entry.type || ''}`;\n        duplicateMap.set(key, entry);\n      }\n    });\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "key",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 256,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "key = `${entry.name}|${entry.filePath}|${entry.type || ''}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 172,
          "contextSnippet": "    }\n    \n    // Case 3: Object where keys might be filePaths and values are entries or arrays of entries\n    Object.entries(data).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        // Value is an array of entries\n        result.push(...this.normalizeArrayData(value));"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedIndex",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 262,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "mergedIndex: SymbolIndexWithScores = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 267,
          "contextSnippet": "    // Process each file in the symbol index\n    Object.entries(symbolIndex).forEach(([filePath, entries]) => {\n      // Create a new array for the merged entries\n      mergedIndex[filePath] = entries.map(entry => {\n        // Look for matching duplicate analysis entry\n        const key = `${entry.name}|${entry.filePath}|${entry.type}`;\n        const duplicateEntry = duplicateMap.get(key);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "key",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 269,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "key = `${entry.name}|${entry.filePath}|${entry.type}`",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "duplicateEntry",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 270,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "duplicateEntry = duplicateMap.get(key)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 279,
          "contextSnippet": "        };\n        \n        // Add score if available\n        if (duplicateEntry && typeof duplicateEntry.score === 'number') {\n          mergedEntry.scores.push({\n            type: 'duplicateAnalysis',\n            score: duplicateEntry.score"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedEntry",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 273,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "mergedEntry: SymbolIndexEntryWithScores = {\n          ...entry,\n          scores: []\n        }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 280,
          "contextSnippet": "        \n        // Add score if available\n        if (duplicateEntry && typeof duplicateEntry.score === 'number') {\n          mergedEntry.scores.push({\n            type: 'duplicateAnalysis',\n            score: duplicateEntry.score\n          });"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 317,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await this.readSymbolIndex(symbolIndexPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 265,
          "contextSnippet": "    const mergedIndex: SymbolIndexWithScores = {};\n    \n    // Process each file in the symbol index\n    Object.entries(symbolIndex).forEach(([filePath, entries]) => {\n      // Create a new array for the merged entries\n      mergedIndex[filePath] = entries.map(entry => {\n        // Look for matching duplicate analysis entry"
        }
      ],
      "depends_on": []
    },
    {
      "name": "duplicateAnalysis",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 318,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "duplicateAnalysis = await this.readDuplicateAnalysis(duplicateAnalysisPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 246,
          "contextSnippet": "    duplicateAnalysis: DuplicateAnalysisEntry[]\n  ): SymbolIndexWithScores {\n    // Check if duplicateAnalysis is valid\n    if (!Array.isArray(duplicateAnalysis)) {\n      console.warn('Duplicate analysis data is not an array, converting to empty array');\n      duplicateAnalysis = [];\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedJson",
      "type": "variable",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 321,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "mergedJson = this.mergeJsonData(symbolIndex, duplicateAnalysis)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 300,
          "contextSnippet": "   */\n  async writeMergedJson(mergedJsonPath: string, mergedJson: SymbolIndexWithScores): Promise<void> {\n    try {\n      await fs.writeJson(mergedJsonPath, mergedJson, { spaces: 2 });\n      console.log(`Merged JSON written to ${mergedJsonPath}`);\n    } catch (error) {\n      console.error('Error writing merged JSON:', error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/merge-json/merge-json-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "cursorTestDir",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 36
        },
        {
          "name": "SYMBOL_INDEX_FILENAME",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 36
        },
        {
          "name": "DUPLICATE_ANALYSIS_FILENAME",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 37
        },
        {
          "name": "MERGED_JSON_FILENAME",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 38
        },
        {
          "name": "DuplicateAnalysisEntry",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 64
        },
        {
          "name": "rawData",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 75
        },
        {
          "name": "sampleKey",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 86
        },
        {
          "name": "normalizedData",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 99
        },
        {
          "name": "entry",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 140
        },
        {
          "name": "key",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 172
        },
        {
          "name": "result",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 175
        },
        {
          "name": "duplicateAnalysis",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 246
        },
        {
          "name": "duplicateMap",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 257
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 265
        },
        {
          "name": "mergedIndex",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 267
        },
        {
          "name": "duplicateEntry",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 279
        },
        {
          "name": "mergedEntry",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 280
        },
        {
          "name": "mergedJson",
          "filePath": "src/features/merge-json/merge-json-service.ts",
          "line": 300
        }
      ]
    }
  ],
  "src/features/symbol-index/dependency-resolver-service.ts": [
    {
      "name": "DependencyResolverService",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 9,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "DependencyResolverService = {\n  /**\n   * Resolves dependencies between symbols in the project\n   * @param symbolIndex - The symbol index\n   * @param projectFiles - List of project files\n   * @param rootPath - Project root path\n   */\n  async resolveDependencies(\n    symbolIndex: SymbolIndex,\n    projectFiles: string[],\n    rootPath: string\n  ): Promise<void> {\n    try {\n      // Create a TypeScript compiler host and program for symbol resolution\n      const compilerOptions: ts.CompilerOptions = {\n        target: ts.ScriptTarget.Latest,\n        module: ts.ModuleKind.CommonJS,\n        allowJs: true,\n        checkJs: false,\n        esModuleInterop: true,\n        moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      };\n\n      // Only include analyzable files in the program\n      const analyzableFiles = projectFiles.filter(file => FileSystemService.isAnalyzableFile(file));\n      \n      // Create program and type checker\n      const program = ts.createProgram(analyzableFiles, compilerOptions);\n      const typeChecker = program.getTypeChecker();\n      \n      // Create a flat map of all symbols for easy lookup (by name and file path)\n      const flatSymbolMap: Record<string, any> = {};\n      \n      // Build the symbol map with compound keys for uniqueness\n      for (const filePath in symbolIndex) {\n        for (const symbol of symbolIndex[filePath]) {\n          const key = `${filePath}:${symbol.name}`;\n          flatSymbolMap[key] = symbol;\n        }\n      }\n      \n      // Excluded identifiers that are built-in or commonly used\n      const excludedIdentifiers = new Set([\n        'console', 'require', 'import', 'export', 'this', 'true', 'false',\n        'null', 'undefined', 'module', 'exports', 'process', 'window',\n        'document', 'Object', 'Array', 'String', 'Number', 'Boolean', 'RegExp',\n        'Map', 'Set', 'Promise', 'JSON', 'Math', 'Date', 'Error'\n      ]);\n      \n      // Process each file to find dependencies\n      for (const filePath of projectFiles) {\n        if (!FileSystemService.isAnalyzableFile(filePath)) {\n          continue;\n        }\n        \n        const normalizedPath = FileSystemService.normalizeFilePath(filePath, rootPath);\n        \n        // Skip if the file isn't in our index\n        if (!symbolIndex[normalizedPath]) {\n          continue;\n        }\n        \n        // Get the source file from the program\n        const sourceFile = program.getSourceFile(filePath);\n        if (!sourceFile) {\n          continue;\n        }\n        \n        // Stack to track nested container symbols\n        const containerStack: any[] = [];\n        \n        // Recursively visit nodes\n        const visit = (node: ts.Node) => {\n          try {\n            // Track the container symbol for various kinds of declarations\n            let enteredNewContainer = false;\n            \n            if (ts.isFunctionDeclaration(node) || \n                ts.isMethodDeclaration(node) || \n                ts.isClassDeclaration(node) ||\n                ts.isInterfaceDeclaration(node) ||\n                ts.isTypeAliasDeclaration(node) ||\n                ts.isEnumDeclaration(node) || \n                ts.isArrowFunction(node) ||\n                ts.isFunctionExpression(node)) {\n              \n              let containerSymbol = null;\n              \n              // Get the container symbol based on the node type\n              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {\n                const className = node.parent.name.text;\n                const methodName = ts.isIdentifier(node.name) ? node.name.text : '';\n                \n                if (methodName) {\n                  const fullName = `${className}.${methodName}`;\n                  const symbols = symbolIndex[normalizedPath] || [];\n                  containerSymbol = symbols.find(s => s.name === fullName) || null;\n                }\n              }\n              else if (ts.isClassDeclaration(node) && node.name) {\n                const className = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === className) || null;\n              }\n              else if (ts.isInterfaceDeclaration(node) && node.name) {\n                const interfaceName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === interfaceName) || null;\n              }\n              else if (ts.isTypeAliasDeclaration(node) && node.name) {\n                const typeName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === typeName) || null;\n              }\n              else if (ts.isEnumDeclaration(node) && node.name) {\n                const enumName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === enumName) || null;\n              }\n              else if ((ts.isArrowFunction(node) || ts.isFunctionExpression(node)) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name)) {\n                const variableName = node.parent.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === variableName) || null;\n              }\n              \n              if (containerSymbol) {\n                containerStack.push(containerSymbol);\n                enteredNewContainer = true;\n              }\n            }\n            \n            // Process identifier references to track dependencies\n            if (ts.isIdentifier(node)) {\n              const identifierName = node.text;\n              \n              // Skip common identifiers, keywords, etc.\n              if (excludedIdentifiers.has(identifierName)) {\n                return;\n              }\n              \n              // Skip if this is a declaration position, not a reference\n              if (this.isDeclarationPosition(node)) {\n                return;\n              }\n              \n              const position = node.getStart(sourceFile);\n              const lineNumber = TsAnalyzerService.getLineNumber(sourceFile, position);\n              const contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3);\n              \n              // Try to resolve the symbol using TypeScript's type checker\n              const symbol = typeChecker.getSymbolAtLocation(node);\n              if (!symbol) {\n                return;\n              }\n              \n              // Get the declaration of the symbol\n              const declarations = symbol.getDeclarations();\n              if (!declarations || declarations.length === 0) {\n                return;\n              }\n              \n              // Find the source file of the declaration\n              const declarationSourceFile = declarations[0].getSourceFile();\n              if (!declarationSourceFile) {\n                return;\n              }\n              \n              // Skip if it's an external library\n              const isNodeModule = declarationSourceFile.fileName.includes('node_modules');\n              if (isNodeModule) {\n                return;\n              }\n              \n              // Get normalized path of the declaration\n              const declarationPath = FileSystemService.normalizeFilePath(declarationSourceFile.fileName, rootPath);\n              \n              // Find the target symbol entry in our index\n              const targetFileSymbols = symbolIndex[declarationPath] || [];\n              const targetSymbol = targetFileSymbols.find(s => s.name === identifierName);\n              \n              if (!targetSymbol) {\n                return;\n              }\n              \n              // Get the current container symbol (closest enclosing declaration)\n              const currentSymbol = containerStack.length > 0 ? containerStack[containerStack.length - 1] : null;\n              \n              if (currentSymbol) {\n                // Skip self-references\n                if (currentSymbol.name === targetSymbol.name && currentSymbol.filePath === targetSymbol.filePath) {\n                  return;\n                }\n                \n                // Add dependency relationship\n                const existingDependency = currentSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                );\n                \n                if (!existingDependency) {\n                  currentSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,\n                    line: lineNumber\n                  });\n                }\n                \n                // Add to target symbol's dependents list\n                const existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === currentSymbol.name && dep.filePath === currentSymbol.filePath\n                );\n                \n                if (!existingDependent) {\n                  targetSymbol.dependents.push({\n                    name: currentSymbol.name,\n                    filePath: currentSymbol.filePath,\n                    line: lineNumber,\n                    contextSnippet\n                  });\n                }\n              } else {\n                // Handle top-level references (outside any container)\n                // These will be recorded as file-level dependencies\n                const fileSymbols = symbolIndex[normalizedPath] || [];\n                \n                // Try to find an existing file-level symbol (representing the module/file)\n                let fileSymbol = fileSymbols.find(s => s.name === '__file__');\n                \n                // Create a file-level symbol if none exists\n                if (!fileSymbol) {\n                  fileSymbol = {\n                    name: '__file__',\n                    type: 'other',\n                    filePath: normalizedPath,\n                    location: { line: 1, character: 0 },\n                    docstring: '/** File-level symbol */',\n                    snippet: '',\n                    dependents: [],\n                    depends_on: []\n                  };\n                  \n                  if (!symbolIndex[normalizedPath]) {\n                    symbolIndex[normalizedPath] = [];\n                  }\n                  \n                  symbolIndex[normalizedPath].push(fileSymbol);\n                }\n                \n                // Add dependency relationship for file-level symbol\n                const existingDependency = fileSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                );\n                \n                if (!existingDependency) {\n                  fileSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,\n                    line: lineNumber\n                  });\n                }\n                \n                // Add to target symbol's dependents list\n                const existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === fileSymbol.name && dep.filePath === fileSymbol.filePath\n                );\n                \n                if (!existingDependent) {\n                  targetSymbol.dependents.push({\n                    name: fileSymbol.name,\n                    filePath: fileSymbol.filePath,\n                    line: lineNumber,\n                    contextSnippet\n                  });\n                }\n              }\n            }\n            \n            // Continue with child nodes\n            ts.forEachChild(node, visit);\n            \n            // Remove the container from the stack if we entered a new one\n            if (enteredNewContainer && containerStack.length > 0) {\n              containerStack.pop();\n            }\n          } catch (error) {\n            console.error(`Error processing node in ${filePath}:`, error);\n          }\n        };\n        \n        // Start the traversal\n        visit(sourceFile);\n      }\n    } catch (error) {\n      console.error(`Error resolving dependencies:`, error);\n    }\n  },\n  \n  /**\n   * Determines if an identifier is in a declaration position\n   * @param node - The identifier node\n   * @returns True if this is a declaration, false if it's a reference\n   */\n  isDeclarationPosition(node: ts.Identifier): boolean {\n    const parent = node.parent;\n    \n    // Various declaration patterns to check\n    if (!parent) {return false;}\n    \n    // Function/method/class/interface/etc. declarations\n    if ((ts.isFunctionDeclaration(parent) || \n         ts.isMethodDeclaration(parent) || \n         ts.isClassDeclaration(parent) || \n         ts.isInterfaceDeclaration(parent) ||\n         ts.isTypeAliasDeclaration(parent) ||\n         ts.isEnumDeclaration(parent)) && \n        parent.name === node) {\n      return true;\n    }\n    \n    // Variable declarations\n    if (ts.isVariableDeclaration(parent) && parent.name === node) {\n      return true;\n    }\n    \n    // Parameter declarations\n    if (ts.isParameter(parent) && parent.name === node) {\n      return true;\n    }\n    \n    // Property declarations\n    if (ts.isPropertyDeclaration(parent) && parent.name === node) {\n      return true;\n    }\n    \n    // Property assignments in object literals (potential declaration)\n    if (ts.isPropertyAssignment(parent) && parent.name === node) {\n      return true;\n    }\n    \n    // Named imports\n    if (ts.isImportSpecifier(parent) && parent.name === node) {\n      return true;\n    }\n    \n    // Default imports\n    if (ts.isImportClause(parent) && parent.name === node) {\n      return true;\n    }\n    \n    return false;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "compilerOptions",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 23,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "compilerOptions: ts.CompilerOptions = {\n        target: ts.ScriptTarget.Latest,\n        module: ts.ModuleKind.CommonJS,\n        allowJs: true,\n        checkJs: false,\n        esModuleInterop: true,\n        moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 36,
          "contextSnippet": "      const analyzableFiles = projectFiles.filter(file => FileSystemService.isAnalyzableFile(file));\n      \n      // Create program and type checker\n      const program = ts.createProgram(analyzableFiles, compilerOptions);\n      const typeChecker = program.getTypeChecker();\n      \n      // Create a flat map of all symbols for easy lookup (by name and file path)"
        }
      ],
      "depends_on": []
    },
    {
      "name": "analyzableFiles",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 33,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "analyzableFiles = projectFiles.filter(file => FileSystemService.isAnalyzableFile(file))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 36,
          "contextSnippet": "      const analyzableFiles = projectFiles.filter(file => FileSystemService.isAnalyzableFile(file));\n      \n      // Create program and type checker\n      const program = ts.createProgram(analyzableFiles, compilerOptions);\n      const typeChecker = program.getTypeChecker();\n      \n      // Create a flat map of all symbols for easy lookup (by name and file path)"
        }
      ],
      "depends_on": []
    },
    {
      "name": "program",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 36,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "program = ts.createProgram(analyzableFiles, compilerOptions)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 37,
          "contextSnippet": "      \n      // Create program and type checker\n      const program = ts.createProgram(analyzableFiles, compilerOptions);\n      const typeChecker = program.getTypeChecker();\n      \n      // Create a flat map of all symbols for easy lookup (by name and file path)\n      const flatSymbolMap: Record<string, any> = {};"
        }
      ],
      "depends_on": []
    },
    {
      "name": "typeChecker",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 37,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "typeChecker = program.getTypeChecker()",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 164,
          "contextSnippet": "              const contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3);\n              \n              // Try to resolve the symbol using TypeScript's type checker\n              const symbol = typeChecker.getSymbolAtLocation(node);\n              if (!symbol) {\n                return;\n              }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "flatSymbolMap",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 40,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "flatSymbolMap: Record<string, any> = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 46,
          "contextSnippet": "      for (const filePath in symbolIndex) {\n        for (const symbol of symbolIndex[filePath]) {\n          const key = `${filePath}:${symbol.name}`;\n          flatSymbolMap[key] = symbol;\n        }\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "key",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 45,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "key = `${filePath}:${symbol.name}`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 46,
          "contextSnippet": "      for (const filePath in symbolIndex) {\n        for (const symbol of symbolIndex[filePath]) {\n          const key = `${filePath}:${symbol.name}`;\n          flatSymbolMap[key] = symbol;\n        }\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "excludedIdentifiers",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 51,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "excludedIdentifiers = new Set([\n        'console', 'require', 'import', 'export', 'this', 'true', 'false',\n        'null', 'undefined', 'module', 'exports', 'process', 'window',\n        'document', 'Object', 'Array', 'String', 'Number', 'Boolean', 'RegExp',\n        'Map', 'Set', 'Promise', 'JSON', 'Math', 'Date', 'Error'\n      ])",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 150,
          "contextSnippet": "              const identifierName = node.text;\n              \n              // Skip common identifiers, keywords, etc.\n              if (excludedIdentifiers.has(identifierName)) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "normalizedPath",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 64,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "normalizedPath = FileSystemService.normalizeFilePath(filePath, rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 67,
          "contextSnippet": "        const normalizedPath = FileSystemService.normalizeFilePath(filePath, rootPath);\n        \n        // Skip if the file isn't in our index\n        if (!symbolIndex[normalizedPath]) {\n          continue;\n        }\n        "
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 100,
          "contextSnippet": "              // Get the container symbol based on the node type\n              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sourceFile",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 72,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "sourceFile = program.getSourceFile(filePath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 73,
          "contextSnippet": "        \n        // Get the source file from the program\n        const sourceFile = program.getSourceFile(filePath);\n        if (!sourceFile) {\n          continue;\n        }\n        "
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 159,
          "contextSnippet": "                return;\n              }\n              \n              const position = node.getStart(sourceFile);\n              const lineNumber = TsAnalyzerService.getLineNumber(sourceFile, position);\n              const contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3);\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "containerStack",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 78,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "containerStack: any[] = []",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 140,
          "contextSnippet": "              }\n              \n              if (containerSymbol) {\n                containerStack.push(containerSymbol);\n                enteredNewContainer = true;\n              }\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "visit",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 81,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "visit = (node: ts.Node) => {\n          try {\n            // Track the container symbol for various kinds of declarations\n            let enteredNewContainer = false;\n            \n            if (ts.isFunctionDeclaration(node) || \n                ts.isMethodDeclaration(node) || \n                ts.isClassDeclaration(node) ||\n                ts.isInterfaceDeclaration(node) ||\n                ts.isTypeAliasDeclaration(node) ||\n                ts.isEnumDeclaration(node) || \n                ts.isArrowFunction(node) ||\n                ts.isFunctionExpression(node)) {\n              \n              let containerSymbol = null;\n              \n              // Get the container symbol based on the node type\n              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {\n                const className = node.parent.name.text;\n                const methodName = ts.isIdentifier(node.name) ? node.name.text : '';\n                \n                if (methodName) {\n                  const fullName = `${className}.${methodName}`;\n                  const symbols = symbolIndex[normalizedPath] || [];\n                  containerSymbol = symbols.find(s => s.name === fullName) || null;\n                }\n              }\n              else if (ts.isClassDeclaration(node) && node.name) {\n                const className = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === className) || null;\n              }\n              else if (ts.isInterfaceDeclaration(node) && node.name) {\n                const interfaceName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === interfaceName) || null;\n              }\n              else if (ts.isTypeAliasDeclaration(node) && node.name) {\n                const typeName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === typeName) || null;\n              }\n              else if (ts.isEnumDeclaration(node) && node.name) {\n                const enumName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === enumName) || null;\n              }\n              else if ((ts.isArrowFunction(node) || ts.isFunctionExpression(node)) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name)) {\n                const variableName = node.parent.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === variableName) || null;\n              }\n              \n              if (containerSymbol) {\n                containerStack.push(containerSymbol);\n                enteredNewContainer = true;\n              }\n            }\n            \n            // Process identifier references to track dependencies\n            if (ts.isIdentifier(node)) {\n              const identifierName = node.text;\n              \n              // Skip common identifiers, keywords, etc.\n              if (excludedIdentifiers.has(identifierName)) {\n                return;\n              }\n              \n              // Skip if this is a declaration position, not a reference\n              if (this.isDeclarationPosition(node)) {\n                return;\n              }\n              \n              const position = node.getStart(sourceFile);\n              const lineNumber = TsAnalyzerService.getLineNumber(sourceFile, position);\n              const contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3);\n              \n              // Try to resolve the symbol using TypeScript's type checker\n              const symbol = typeChecker.getSymbolAtLocation(node);\n              if (!symbol) {\n                return;\n              }\n              \n              // Get the declaration of the symbol\n              const declarations = symbol.getDeclarations();\n              if (!declarations || declarations.length === 0) {\n                return;\n              }\n              \n              // Find the source file of the declaration\n              const declarationSourceFile = declarations[0].getSourceFile();\n              if (!declarationSourceFile) {\n                return;\n              }\n              \n              // Skip if it's an external library\n              const isNodeModule = declarationSourceFile.fileName.includes('node_modules');\n              if (isNodeModule) {\n                return;\n              }\n              \n              // Get normalized path of the declaration\n              const declarationPath = FileSystemService.normalizeFilePath(declarationSourceFile.fileName, rootPath);\n              \n              // Find the target symbol entry in our index\n              const targetFileSymbols = symbolIndex[declarationPath] || [];\n              const targetSymbol = targetFileSymbols.find(s => s.name === identifierName);\n              \n              if (!targetSymbol) {\n                return;\n              }\n              \n              // Get the current container symbol (closest enclosing declaration)\n              const currentSymbol = containerStack.length > 0 ? containerStack[containerStack.length - 1] : null;\n              \n              if (currentSymbol) {\n                // Skip self-references\n                if (currentSymbol.name === targetSymbol.name && currentSymbol.filePath === targetSymbol.filePath) {\n                  return;\n                }\n                \n                // Add dependency relationship\n                const existingDependency = currentSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                );\n                \n                if (!existingDependency) {\n                  currentSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,\n                    line: lineNumber\n                  });\n                }\n                \n                // Add to target symbol's dependents list\n                const existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === currentSymbol.name && dep.filePath === currentSymbol.filePath\n                );\n                \n                if (!existingDependent) {\n                  targetSymbol.dependents.push({\n                    name: currentSymbol.name,\n                    filePath: currentSymbol.filePath,\n                    line: lineNumber,\n                    contextSnippet\n                  });\n                }\n              } else {\n                // Handle top-level references (outside any container)\n                // These will be recorded as file-level dependencies\n                const fileSymbols = symbolIndex[normalizedPath] || [];\n                \n                // Try to find an existing file-level symbol (representing the module/file)\n                let fileSymbol = fileSymbols.find(s => s.name === '__file__');\n                \n                // Create a file-level symbol if none exists\n                if (!fileSymbol) {\n                  fileSymbol = {\n                    name: '__file__',\n                    type: 'other',\n                    filePath: normalizedPath,\n                    location: { line: 1, character: 0 },\n                    docstring: '/** File-level symbol */',\n                    snippet: '',\n                    dependents: [],\n                    depends_on: []\n                  };\n                  \n                  if (!symbolIndex[normalizedPath]) {\n                    symbolIndex[normalizedPath] = [];\n                  }\n                  \n                  symbolIndex[normalizedPath].push(fileSymbol);\n                }\n                \n                // Add dependency relationship for file-level symbol\n                const existingDependency = fileSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                );\n                \n                if (!existingDependency) {\n                  fileSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,\n                    line: lineNumber\n                  });\n                }\n                \n                // Add to target symbol's dependents list\n                const existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === fileSymbol.name && dep.filePath === fileSymbol.filePath\n                );\n                \n                if (!existingDependent) {\n                  targetSymbol.dependents.push({\n                    name: fileSymbol.name,\n                    filePath: fileSymbol.filePath,\n                    line: lineNumber,\n                    contextSnippet\n                  });\n                }\n              }\n            }\n            \n            // Continue with child nodes\n            ts.forEachChild(node, visit);\n            \n            // Remove the container from the stack if we entered a new one\n            if (enteredNewContainer && containerStack.length > 0) {\n              containerStack.pop();\n            }\n          } catch (error) {\n            console.error(`Error processing node in ${filePath}:`, error);\n          }\n        }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 303,
          "contextSnippet": "        };\n        \n        // Start the traversal\n        visit(sourceFile);\n      }\n    } catch (error) {\n      console.error(`Error resolving dependencies:`, error);"
        }
      ],
      "depends_on": [
        {
          "name": "normalizedPath",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 100
        },
        {
          "name": "containerSymbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101
        },
        {
          "name": "symbols",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101
        },
        {
          "name": "functionName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101
        },
        {
          "name": "methodName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 107
        },
        {
          "name": "className",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 108
        },
        {
          "name": "fullName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 110
        },
        {
          "name": "interfaceName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 121
        },
        {
          "name": "typeName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 126
        },
        {
          "name": "enumName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 131
        },
        {
          "name": "variableName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 136
        },
        {
          "name": "containerStack",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 140
        },
        {
          "name": "enteredNewContainer",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 141
        },
        {
          "name": "excludedIdentifiers",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 150
        },
        {
          "name": "identifierName",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 150
        },
        {
          "name": "sourceFile",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 159
        },
        {
          "name": "position",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 160
        },
        {
          "name": "typeChecker",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 164
        },
        {
          "name": "symbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 165
        },
        {
          "name": "declarations",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 171
        },
        {
          "name": "declarationSourceFile",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 177
        },
        {
          "name": "isNodeModule",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 183
        },
        {
          "name": "declarationPath",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 191
        },
        {
          "name": "targetFileSymbols",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 192
        },
        {
          "name": "targetSymbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 194
        },
        {
          "name": "currentSymbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 201
        },
        {
          "name": "existingDependency",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 212
        },
        {
          "name": "lineNumber",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 216
        },
        {
          "name": "existingDependent",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 225
        },
        {
          "name": "contextSnippet",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 230
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 239
        },
        {
          "name": "fileSymbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 242
        }
      ]
    },
    {
      "name": "enteredNewContainer",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 84,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "enteredNewContainer = false",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 141,
          "contextSnippet": "              \n              if (containerSymbol) {\n                containerStack.push(containerSymbol);\n                enteredNewContainer = true;\n              }\n            }\n            "
        }
      ],
      "depends_on": []
    },
    {
      "name": "containerSymbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 95,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "containerSymbol = null",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101,
          "contextSnippet": "              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {\n                const className = node.parent.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "functionName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 99,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "functionName = node.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101,
          "contextSnippet": "              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {\n                const className = node.parent.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 100,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 101,
          "contextSnippet": "              if (ts.isFunctionDeclaration(node) && node.name) {\n                const functionName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === functionName) || null;\n              }\n              else if (ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) && node.parent.name) {\n                const className = node.parent.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "className",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 104,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "className = node.parent.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 108,
          "contextSnippet": "                const methodName = ts.isIdentifier(node.name) ? node.name.text : '';\n                \n                if (methodName) {\n                  const fullName = `${className}.${methodName}`;\n                  const symbols = symbolIndex[normalizedPath] || [];\n                  containerSymbol = symbols.find(s => s.name === fullName) || null;\n                }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "methodName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 105,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "methodName = ts.isIdentifier(node.name) ? node.name.text : ''",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 107,
          "contextSnippet": "                const className = node.parent.name.text;\n                const methodName = ts.isIdentifier(node.name) ? node.name.text : '';\n                \n                if (methodName) {\n                  const fullName = `${className}.${methodName}`;\n                  const symbols = symbolIndex[normalizedPath] || [];\n                  containerSymbol = symbols.find(s => s.name === fullName) || null;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fullName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 108,
        "character": 24
      },
      "docstring": "/** */",
      "snippet": "fullName = `${className}.${methodName}`",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 110,
          "contextSnippet": "                if (methodName) {\n                  const fullName = `${className}.${methodName}`;\n                  const symbols = symbolIndex[normalizedPath] || [];\n                  containerSymbol = symbols.find(s => s.name === fullName) || null;\n                }\n              }\n              else if (ts.isClassDeclaration(node) && node.name) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 109,
        "character": 24
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "className",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 114,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "className = node.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 115,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "interfaceName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 119,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "interfaceName = node.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 121,
          "contextSnippet": "              else if (ts.isInterfaceDeclaration(node) && node.name) {\n                const interfaceName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === interfaceName) || null;\n              }\n              else if (ts.isTypeAliasDeclaration(node) && node.name) {\n                const typeName = node.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 120,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "typeName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 124,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "typeName = node.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 126,
          "contextSnippet": "              else if (ts.isTypeAliasDeclaration(node) && node.name) {\n                const typeName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === typeName) || null;\n              }\n              else if (ts.isEnumDeclaration(node) && node.name) {\n                const enumName = node.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 125,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "enumName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 129,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "enumName = node.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 131,
          "contextSnippet": "              else if (ts.isEnumDeclaration(node) && node.name) {\n                const enumName = node.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === enumName) || null;\n              }\n              else if ((ts.isArrowFunction(node) || ts.isFunctionExpression(node)) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name)) {\n                const variableName = node.parent.name.text;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 130,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "variableName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 134,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "variableName = node.parent.name.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 136,
          "contextSnippet": "              else if ((ts.isArrowFunction(node) || ts.isFunctionExpression(node)) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.name && ts.isIdentifier(node.parent.name)) {\n                const variableName = node.parent.name.text;\n                const symbols = symbolIndex[normalizedPath] || [];\n                containerSymbol = symbols.find(s => s.name === variableName) || null;\n              }\n              \n              if (containerSymbol) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 135,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "symbols = symbolIndex[normalizedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "identifierName",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 147,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "identifierName = node.text",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 150,
          "contextSnippet": "              const identifierName = node.text;\n              \n              // Skip common identifiers, keywords, etc.\n              if (excludedIdentifiers.has(identifierName)) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "position",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 159,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "position = node.getStart(sourceFile)",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 160,
          "contextSnippet": "              }\n              \n              const position = node.getStart(sourceFile);\n              const lineNumber = TsAnalyzerService.getLineNumber(sourceFile, position);\n              const contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3);\n              \n              // Try to resolve the symbol using TypeScript's type checker"
        }
      ],
      "depends_on": []
    },
    {
      "name": "lineNumber",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 160,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "lineNumber = TsAnalyzerService.getLineNumber(sourceFile, position)",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 216,
          "contextSnippet": "                  currentSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,\n                    line: lineNumber\n                  });\n                }\n                "
        }
      ],
      "depends_on": []
    },
    {
      "name": "contextSnippet",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 161,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "contextSnippet = TsAnalyzerService.getContextSnippet(sourceFile, position, 3)",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 230,
          "contextSnippet": "                    name: currentSymbol.name,\n                    filePath: currentSymbol.filePath,\n                    line: lineNumber,\n                    contextSnippet\n                  });\n                }\n              } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 164,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "symbol = typeChecker.getSymbolAtLocation(node)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 45,
          "contextSnippet": "      // Build the symbol map with compound keys for uniqueness\n      for (const filePath in symbolIndex) {\n        for (const symbol of symbolIndex[filePath]) {\n          const key = `${filePath}:${symbol.name}`;\n          flatSymbolMap[key] = symbol;\n        }\n      }"
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 165,
          "contextSnippet": "              \n              // Try to resolve the symbol using TypeScript's type checker\n              const symbol = typeChecker.getSymbolAtLocation(node);\n              if (!symbol) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "declarations",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 170,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "declarations = symbol.getDeclarations()",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 171,
          "contextSnippet": "              \n              // Get the declaration of the symbol\n              const declarations = symbol.getDeclarations();\n              if (!declarations || declarations.length === 0) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "declarationSourceFile",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 176,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "declarationSourceFile = declarations[0].getSourceFile()",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 177,
          "contextSnippet": "              \n              // Find the source file of the declaration\n              const declarationSourceFile = declarations[0].getSourceFile();\n              if (!declarationSourceFile) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "isNodeModule",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 182,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "isNodeModule = declarationSourceFile.fileName.includes('node_modules')",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 183,
          "contextSnippet": "              \n              // Skip if it's an external library\n              const isNodeModule = declarationSourceFile.fileName.includes('node_modules');\n              if (isNodeModule) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "declarationPath",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 188,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "declarationPath = FileSystemService.normalizeFilePath(declarationSourceFile.fileName, rootPath)",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 191,
          "contextSnippet": "              const declarationPath = FileSystemService.normalizeFilePath(declarationSourceFile.fileName, rootPath);\n              \n              // Find the target symbol entry in our index\n              const targetFileSymbols = symbolIndex[declarationPath] || [];\n              const targetSymbol = targetFileSymbols.find(s => s.name === identifierName);\n              \n              if (!targetSymbol) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "targetFileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 191,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "targetFileSymbols = symbolIndex[declarationPath] || []",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 192,
          "contextSnippet": "              \n              // Find the target symbol entry in our index\n              const targetFileSymbols = symbolIndex[declarationPath] || [];\n              const targetSymbol = targetFileSymbols.find(s => s.name === identifierName);\n              \n              if (!targetSymbol) {\n                return;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "targetSymbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 192,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "targetSymbol = targetFileSymbols.find(s => s.name === identifierName)",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 194,
          "contextSnippet": "              const targetFileSymbols = symbolIndex[declarationPath] || [];\n              const targetSymbol = targetFileSymbols.find(s => s.name === identifierName);\n              \n              if (!targetSymbol) {\n                return;\n              }\n              "
        }
      ],
      "depends_on": []
    },
    {
      "name": "currentSymbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 199,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "currentSymbol = containerStack.length > 0 ? containerStack[containerStack.length - 1] : null",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 201,
          "contextSnippet": "              // Get the current container symbol (closest enclosing declaration)\n              const currentSymbol = containerStack.length > 0 ? containerStack[containerStack.length - 1] : null;\n              \n              if (currentSymbol) {\n                // Skip self-references\n                if (currentSymbol.name === targetSymbol.name && currentSymbol.filePath === targetSymbol.filePath) {\n                  return;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingDependency",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 208,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "existingDependency = currentSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                )",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 212,
          "contextSnippet": "                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                );\n                \n                if (!existingDependency) {\n                  currentSymbol.depends_on.push({\n                    name: targetSymbol.name,\n                    filePath: targetSymbol.filePath,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingDependent",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 221,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === currentSymbol.name && dep.filePath === currentSymbol.filePath\n                )",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 225,
          "contextSnippet": "                  (dep: any) => dep.name === currentSymbol.name && dep.filePath === currentSymbol.filePath\n                );\n                \n                if (!existingDependent) {\n                  targetSymbol.dependents.push({\n                    name: currentSymbol.name,\n                    filePath: currentSymbol.filePath,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 236,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = symbolIndex[normalizedPath] || []",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 239,
          "contextSnippet": "                const fileSymbols = symbolIndex[normalizedPath] || [];\n                \n                // Try to find an existing file-level symbol (representing the module/file)\n                let fileSymbol = fileSymbols.find(s => s.name === '__file__');\n                \n                // Create a file-level symbol if none exists\n                if (!fileSymbol) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 239,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "fileSymbol = fileSymbols.find(s => s.name === '__file__')",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 242,
          "contextSnippet": "                let fileSymbol = fileSymbols.find(s => s.name === '__file__');\n                \n                // Create a file-level symbol if none exists\n                if (!fileSymbol) {\n                  fileSymbol = {\n                    name: '__file__',\n                    type: 'other',"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingDependency",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 262,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "existingDependency = fileSymbol.depends_on.find(\n                  (dep: any) => dep.name === targetSymbol.name && dep.filePath === targetSymbol.filePath\n                )",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "existingDependent",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 275,
        "character": 22
      },
      "docstring": "/** */",
      "snippet": "existingDependent = targetSymbol.dependents.find(\n                  (dep: any) => dep.name === fileSymbol.name && dep.filePath === fileSymbol.filePath\n                )",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "parent",
      "type": "variable",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 316,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "parent = node.parent",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 319,
          "contextSnippet": "    const parent = node.parent;\n    \n    // Various declaration patterns to check\n    if (!parent) {return false;}\n    \n    // Function/method/class/interface/etc. declarations\n    if ((ts.isFunctionDeclaration(parent) || "
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "analyzableFiles",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 36
        },
        {
          "name": "compilerOptions",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 36
        },
        {
          "name": "program",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 37
        },
        {
          "name": "symbol",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 45
        },
        {
          "name": "flatSymbolMap",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 46
        },
        {
          "name": "key",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 46
        },
        {
          "name": "normalizedPath",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 67
        },
        {
          "name": "sourceFile",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 73
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 303
        },
        {
          "name": "parent",
          "filePath": "src/features/symbol-index/dependency-resolver-service.ts",
          "line": 319
        }
      ]
    }
  ],
  "src/features/symbol-index/symbol-extraction-service.ts": [
    {
      "name": "SYMBOL_EXTRACTION_CONFIG",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 8,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "SYMBOL_EXTRACTION_CONFIG = {\n  // Identifiers to exclude from symbol extraction\n  excludedIdentifiers: ['console', 'require', 'module', 'exports', 'process'],\n  // Size limit for files to analyze (in bytes)\n  fileSizeLimit: 1000000, // 1MB\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 104,
          "contextSnippet": "    if (!node.name) {return null;}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return null;}\n\n    return this.createSymbolIndexEntry({\n      name,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "SymbolType",
      "type": "type",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 16,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "type SymbolType = 'function' | 'class' | 'interface' | 'type' | 'variable' | 'method' | 'enum' | 'other';",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 68,
          "contextSnippet": "    sourceFile\n  }: {\n    name: string;\n    type: SymbolType;\n    filePath: string;\n    node: ts.Node;\n    sourceFile: ts.SourceFile;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "SymbolExtractionService",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 21,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "SymbolExtractionService = {\n  /**\n   * Extracts JSDoc comment from a node if present\n   * @param node - The TypeScript node\n   * @param sourceFile - The source file\n   * @returns The JSDoc comment text or empty string\n   */\n  extractJSDocComment(node: ts.Node, sourceFile: ts.SourceFile): string {\n    const jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[];\n    \n    if (jsDocComments && jsDocComments.length > 0) {\n      // Get the first JSDoc comment\n      const jsDoc = jsDocComments[0];\n      \n      // Extract the JSDoc text\n      if (jsDoc.getFullText) {\n        return jsDoc.getFullText(sourceFile);\n      }\n    }\n    \n    return '';\n  },\n\n  /**\n   * Gets docstring for a node with fallback to empty JSDoc comment\n   * @param node - The TypeScript node\n   * @param sourceFile - The source file\n   * @returns The docstring with fallback\n   */\n  getDocstringWithFallback(node: ts.Node, sourceFile: ts.SourceFile): string {\n    const hasJSDoc = ts.getJSDocTags(node).length > 0;\n    return hasJSDoc ? this.extractJSDocComment(node, sourceFile) : '/** */';\n  },\n\n  /**\n   * Creates a symbol index entry\n   * @param params - Parameters for creating the entry\n   * @returns A symbol index entry\n   */\n  createSymbolIndexEntry({\n    name,\n    type,\n    filePath,\n    node,\n    sourceFile\n  }: {\n    name: string;\n    type: SymbolType;\n    filePath: string;\n    node: ts.Node;\n    sourceFile: ts.SourceFile;\n  }): SymbolIndexEntry {\n    const location = TsAnalyzerService.getLineAndCharacter(sourceFile, node);\n    const snippet = TsAnalyzerService.extractCodeSnippet(sourceFile, node);\n    const docstring = this.getDocstringWithFallback(node, sourceFile);\n\n    return {\n      name,\n      type,\n      filePath,\n      location,\n      docstring,\n      snippet,\n      dependents: [],\n      depends_on: []\n    };\n  },\n\n  /**\n   * Handles function declarations\n   * @param node - The function declaration node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Symbol index entry or null\n   */\n  handleFunctionDeclaration(\n    node: ts.FunctionDeclaration,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry | null {\n    if (!node.name) {return null;}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return null;}\n\n    return this.createSymbolIndexEntry({\n      name,\n      type: 'function',\n      filePath,\n      node,\n      sourceFile\n    });\n  },\n\n  /**\n   * Handles class declarations\n   * @param node - The class declaration node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Array of symbol index entries\n   */\n  handleClassDeclaration(\n    node: ts.ClassDeclaration,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry[] {\n    if (!node.name) {return [];}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return [];}\n\n    const symbols: SymbolIndexEntry[] = [\n      this.createSymbolIndexEntry({\n        name,\n        type: 'class',\n        filePath,\n        node,\n        sourceFile\n      })\n    ];\n\n    // Process class methods\n    node.members.forEach(member => {\n      if (ts.isMethodDeclaration(member) && member.name) {\n        const methodName = member.name.getText(sourceFile);\n        \n        symbols.push(\n          this.createSymbolIndexEntry({\n            name: `${name}.${methodName}`,\n            type: 'method',\n            filePath,\n            node: member,\n            sourceFile\n          })\n        );\n      }\n    });\n\n    return symbols;\n  },\n\n  /**\n   * Handles interface declarations\n   * @param node - The interface declaration node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Symbol index entry or null\n   */\n  handleInterfaceDeclaration(\n    node: ts.InterfaceDeclaration,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry | null {\n    if (!node.name) {return null;}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return null;}\n\n    return this.createSymbolIndexEntry({\n      name,\n      type: 'interface',\n      filePath,\n      node,\n      sourceFile\n    });\n  },\n\n  /**\n   * Handles type alias declarations\n   * @param node - The type alias declaration node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Symbol index entry or null\n   */\n  handleTypeAliasDeclaration(\n    node: ts.TypeAliasDeclaration,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry | null {\n    if (!node.name) {return null;}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return null;}\n\n    return this.createSymbolIndexEntry({\n      name,\n      type: 'type',\n      filePath,\n      node,\n      sourceFile\n    });\n  },\n\n  /**\n   * Handles enum declarations\n   * @param node - The enum declaration node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Symbol index entry or null\n   */\n  handleEnumDeclaration(\n    node: ts.EnumDeclaration,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry | null {\n    if (!node.name) {return null;}\n    \n    const name = node.name.text;\n    if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return null;}\n\n    return this.createSymbolIndexEntry({\n      name,\n      type: 'enum',\n      filePath,\n      node,\n      sourceFile\n    });\n  },\n\n  /**\n   * Handles variable statements\n   * @param node - The variable statement node\n   * @param sourceFile - The source file\n   * @param filePath - Normalized file path\n   * @returns Array of symbol index entries\n   */\n  handleVariableStatement(\n    node: ts.VariableStatement,\n    sourceFile: ts.SourceFile,\n    filePath: string\n  ): SymbolIndexEntry[] {\n    const symbols: SymbolIndexEntry[] = [];\n\n    node.declarationList.declarations.forEach(declaration => {\n      if (ts.isIdentifier(declaration.name)) {\n        const name = declaration.name.text;\n        \n        if (SYMBOL_EXTRACTION_CONFIG.excludedIdentifiers.includes(name)) {return;}\n\n        symbols.push(\n          this.createSymbolIndexEntry({\n            name,\n            type: 'variable',\n            filePath,\n            node: declaration,\n            sourceFile\n          })\n        );\n      }\n    });\n\n    return symbols;\n  },\n\n  /**\n   * Extracts symbols from a file\n   * @param filePath - Path to the file\n   * @param normalizedPath - Normalized file path relative to project root\n   * @param rootPath - Project root path\n   * @returns Array of symbol entries\n   */\n  async extractSymbols(\n    filePath: string,\n    normalizedPath: string,\n    rootPath: string\n  ): Promise<SymbolIndexEntry[]> {\n    try {\n      // Skip non-analyzable files\n      if (!FileSystemService.isAnalyzableFile(filePath)) {\n        return [];\n      }\n      \n      // Read the file content\n      const fileContent = await fs.readFile(filePath, 'utf8');\n      \n      // Skip files that are too large\n      if (fileContent.length > SYMBOL_EXTRACTION_CONFIG.fileSizeLimit) {\n        console.log(`Skipping large file: ${filePath} (${Math.round(fileContent.length/1024)}KB)`);\n        return [];\n      }\n      \n      // Create a TypeScript source file\n      const sourceFile = ts.createSourceFile(\n        filePath,\n        fileContent,\n        ts.ScriptTarget.Latest,\n        true\n      );\n      \n      const symbols: SymbolIndexEntry[] = [];\n      \n      // Recursively visit nodes to extract symbols\n      const visit = (node: ts.Node) => {\n        try {\n          let nodeSymbols: SymbolIndexEntry | SymbolIndexEntry[] | null = null;\n          \n          // Dispatch to appropriate handler based on node kind\n          if (ts.isFunctionDeclaration(node)) {\n            nodeSymbols = this.handleFunctionDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isClassDeclaration(node)) {\n            nodeSymbols = this.handleClassDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isInterfaceDeclaration(node)) {\n            nodeSymbols = this.handleInterfaceDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isTypeAliasDeclaration(node)) {\n            nodeSymbols = this.handleTypeAliasDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isEnumDeclaration(node)) {\n            nodeSymbols = this.handleEnumDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isVariableStatement(node)) {\n            nodeSymbols = this.handleVariableStatement(node, sourceFile, normalizedPath);\n          }\n          \n          // Add the extracted symbols to the result\n          if (nodeSymbols) {\n            if (Array.isArray(nodeSymbols)) {\n              symbols.push(...nodeSymbols);\n            } else {\n              symbols.push(nodeSymbols);\n            }\n          }\n          \n          // Process child nodes\n          ts.forEachChild(node, visit);\n        } catch (error) {\n          console.error(`Error processing node in ${filePath}:`, error);\n        }\n      };\n      \n      // Start the traversal\n      visit(sourceFile);\n      \n      return symbols;\n    } catch (error) {\n      console.error(`Error extracting symbols from ${filePath}:`, error);\n      return [];\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "jsDocComments",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 29,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 31,
          "contextSnippet": "  extractJSDocComment(node: ts.Node, sourceFile: ts.SourceFile): string {\n    const jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[];\n    \n    if (jsDocComments && jsDocComments.length > 0) {\n      // Get the first JSDoc comment\n      const jsDoc = jsDocComments[0];\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "jsDoc",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 33,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "jsDoc = jsDocComments[0]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 36,
          "contextSnippet": "      const jsDoc = jsDocComments[0];\n      \n      // Extract the JSDoc text\n      if (jsDoc.getFullText) {\n        return jsDoc.getFullText(sourceFile);\n      }\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "hasJSDoc",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 51,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "hasJSDoc = ts.getJSDocTags(node).length > 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 52,
          "contextSnippet": "   */\n  getDocstringWithFallback(node: ts.Node, sourceFile: ts.SourceFile): string {\n    const hasJSDoc = ts.getJSDocTags(node).length > 0;\n    return hasJSDoc ? this.extractJSDocComment(node, sourceFile) : '/** */';\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "location",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 73,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "location = TsAnalyzerService.getLineAndCharacter(sourceFile, node)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 81,
          "contextSnippet": "      name,\n      type,\n      filePath,\n      location,\n      docstring,\n      snippet,\n      dependents: [],"
        }
      ],
      "depends_on": []
    },
    {
      "name": "snippet",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 74,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "snippet = TsAnalyzerService.extractCodeSnippet(sourceFile, node)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 83,
          "contextSnippet": "      filePath,\n      location,\n      docstring,\n      snippet,\n      dependents: [],\n      depends_on: []\n    };"
        }
      ],
      "depends_on": []
    },
    {
      "name": "docstring",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 75,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "docstring = this.getDocstringWithFallback(node, sourceFile)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 82,
          "contextSnippet": "      type,\n      filePath,\n      location,\n      docstring,\n      snippet,\n      dependents: [],\n      depends_on: []"
        }
      ],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 103,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "name = node.name.text",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 61,
          "contextSnippet": "   * @returns A symbol index entry\n   */\n  createSymbolIndexEntry({\n    name,\n    type,\n    filePath,\n    node,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 129,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "name = node.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 132,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbols: SymbolIndexEntry[] = [\n      this.createSymbolIndexEntry({\n        name,\n        type: 'class',\n        filePath,\n        node,\n        sourceFile\n      })\n    ]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 147,
          "contextSnippet": "      if (ts.isMethodDeclaration(member) && member.name) {\n        const methodName = member.name.getText(sourceFile);\n        \n        symbols.push(\n          this.createSymbolIndexEntry({\n            name: `${name}.${methodName}`,\n            type: 'method',"
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 335,
          "contextSnippet": "          // Add the extracted symbols to the result\n          if (nodeSymbols) {\n            if (Array.isArray(nodeSymbols)) {\n              symbols.push(...nodeSymbols);\n            } else {\n              symbols.push(nodeSymbols);\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "methodName",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 145,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "methodName = member.name.getText(sourceFile)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 149,
          "contextSnippet": "        \n        symbols.push(\n          this.createSymbolIndexEntry({\n            name: `${name}.${methodName}`,\n            type: 'method',\n            filePath,\n            node: member,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 176,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "name = node.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 202,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "name = node.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 228,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "name = node.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 252,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbols: SymbolIndexEntry[] = []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "name",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 256,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "name = declaration.name.text",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "fileContent",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 294,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileContent = await fs.readFile(filePath, 'utf8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 297,
          "contextSnippet": "      const fileContent = await fs.readFile(filePath, 'utf8');\n      \n      // Skip files that are too large\n      if (fileContent.length > SYMBOL_EXTRACTION_CONFIG.fileSizeLimit) {\n        console.log(`Skipping large file: ${filePath} (${Math.round(fileContent.length/1024)}KB)`);\n        return [];\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sourceFile",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 303,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "sourceFile = ts.createSourceFile(\n        filePath,\n        fileContent,\n        ts.ScriptTarget.Latest,\n        true\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 37,
          "contextSnippet": "      \n      // Extract the JSDoc text\n      if (jsDoc.getFullText) {\n        return jsDoc.getFullText(sourceFile);\n      }\n    }\n    "
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 319,
          "contextSnippet": "          \n          // Dispatch to appropriate handler based on node kind\n          if (ts.isFunctionDeclaration(node)) {\n            nodeSymbols = this.handleFunctionDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isClassDeclaration(node)) {\n            nodeSymbols = this.handleClassDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isInterfaceDeclaration(node)) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 310,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbols: SymbolIndexEntry[] = []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "visit",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 313,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "visit = (node: ts.Node) => {\n        try {\n          let nodeSymbols: SymbolIndexEntry | SymbolIndexEntry[] | null = null;\n          \n          // Dispatch to appropriate handler based on node kind\n          if (ts.isFunctionDeclaration(node)) {\n            nodeSymbols = this.handleFunctionDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isClassDeclaration(node)) {\n            nodeSymbols = this.handleClassDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isInterfaceDeclaration(node)) {\n            nodeSymbols = this.handleInterfaceDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isTypeAliasDeclaration(node)) {\n            nodeSymbols = this.handleTypeAliasDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isEnumDeclaration(node)) {\n            nodeSymbols = this.handleEnumDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isVariableStatement(node)) {\n            nodeSymbols = this.handleVariableStatement(node, sourceFile, normalizedPath);\n          }\n          \n          // Add the extracted symbols to the result\n          if (nodeSymbols) {\n            if (Array.isArray(nodeSymbols)) {\n              symbols.push(...nodeSymbols);\n            } else {\n              symbols.push(nodeSymbols);\n            }\n          }\n          \n          // Process child nodes\n          ts.forEachChild(node, visit);\n        } catch (error) {\n          console.error(`Error processing node in ${filePath}:`, error);\n        }\n      }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 349,
          "contextSnippet": "      };\n      \n      // Start the traversal\n      visit(sourceFile);\n      \n      return symbols;\n    } catch (error) {"
        }
      ],
      "depends_on": [
        {
          "name": "nodeSymbols",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 319
        },
        {
          "name": "sourceFile",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 319
        },
        {
          "name": "symbols",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 335
        }
      ]
    },
    {
      "name": "nodeSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 315,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "nodeSymbols: SymbolIndexEntry | SymbolIndexEntry[] | null = null",
      "dependents": [
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 319,
          "contextSnippet": "          \n          // Dispatch to appropriate handler based on node kind\n          if (ts.isFunctionDeclaration(node)) {\n            nodeSymbols = this.handleFunctionDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isClassDeclaration(node)) {\n            nodeSymbols = this.handleClassDeclaration(node, sourceFile, normalizedPath);\n          } else if (ts.isInterfaceDeclaration(node)) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "jsDocComments",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 31
        },
        {
          "name": "jsDoc",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 36
        },
        {
          "name": "sourceFile",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 37
        },
        {
          "name": "hasJSDoc",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 52
        },
        {
          "name": "name",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 61
        },
        {
          "name": "SymbolType",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 68
        },
        {
          "name": "location",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 81
        },
        {
          "name": "docstring",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 82
        },
        {
          "name": "snippet",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 83
        },
        {
          "name": "SYMBOL_EXTRACTION_CONFIG",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 104
        },
        {
          "name": "symbols",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 147
        },
        {
          "name": "methodName",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 149
        },
        {
          "name": "fileContent",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 297
        },
        {
          "name": "visit",
          "filePath": "src/features/symbol-index/symbol-extraction-service.ts",
          "line": 349
        }
      ]
    }
  ],
  "src/features/symbol-index/symbol-index-orchestrator.ts": [
    {
      "name": "SymbolIndexOrchestrator",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 11,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "SymbolIndexOrchestrator = {\n  /**\n   * Creates a complete symbol index for a project\n   * @param rootPath - Path to the project root\n   * @param ignoredPatterns - Patterns to ignore during file processing\n   * @param progress - Optional progress reporter\n   * @returns The complete symbol index\n   */\n  async createSymbolIndex(\n    rootPath: string,\n    ignoredPatterns: string[] = [],\n    progress?: { report: (info: { message: string }) => void }\n  ): Promise<SymbolIndex> {\n    try {\n      progress?.report({ message: 'Analyzing project structure...' });\n      \n      // Get all project files\n      const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n      \n      // Safety check - limit number of files to process\n      if (projectFiles.length > MAX_FILES_TO_PROCESS) {\n        console.warn(`Project contains ${projectFiles.length} files, which exceeds the limit of ${MAX_FILES_TO_PROCESS}. Only processing the first ${MAX_FILES_TO_PROCESS} files.`);\n        projectFiles.length = MAX_FILES_TO_PROCESS;\n      }\n      \n      // First check if there's an existing symbol index to preserve docstrings\n      const existingSymbolIndex = await SymbolIndexService.readSymbolIndex(rootPath);\n      \n      // Initialize the symbol index with file-based organization\n      const symbolIndex: SymbolIndex = {};\n      \n      // First pass: Extract all symbols and their basic information\n      progress?.report({ message: 'Extracting symbols from files...' });\n      for (let i = 0; i < projectFiles.length; i++) {\n        const filePath = projectFiles[i];\n        \n        // Skip files we shouldn't analyze\n        if (!FileSystemService.isAnalyzableFile(filePath)) {\n          continue;\n        }\n        \n        progress?.report({ \n          message: `Processing file ${i + 1}/${projectFiles.length}: ${path.basename(filePath)}` \n        });\n        \n        const normalizedPath = FileSystemService.normalizeFilePath(filePath, rootPath);\n        \n        // Extract symbols from the file\n        const symbols = await SymbolExtractionService.extractSymbols(\n          filePath, \n          normalizedPath, \n          rootPath\n        );\n        \n        // Preserve docstrings from existing symbol index if available\n        const existingFileSymbols = existingSymbolIndex?.[normalizedPath] || [];\n        const mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols);\n        \n        // Initialize file entry in the index\n        if (mergedSymbols.length > 0) {\n          symbolIndex[normalizedPath] = mergedSymbols;\n        }\n      }\n      \n      // Complete the indexing with shared post-processing\n      return this.finishIndexCreation(symbolIndex, projectFiles, rootPath, progress);\n    } catch (error) {\n      console.error('Error creating symbol index:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Updates the symbol index for a changed file\n   * @param rootPath - Project root path\n   * @param existingIndex - Existing symbol index\n   * @param changedFilePath - Path to the changed file\n   * @param ignoredPatterns - Patterns to ignore\n   * @returns Updated symbol index\n   */\n  async updateSymbolIndex(\n    rootPath: string,\n    existingIndex: SymbolIndex,\n    changedFilePath: string,\n    ignoredPatterns: string[] = []\n  ): Promise<SymbolIndex> {\n    try {\n      // Read the on-disk symbol index to preserve any manually added docstrings\n      const onDiskSymbolIndex = await SymbolIndexService.readSymbolIndex(rootPath);\n      \n      // Create a deep copy of the existing index to avoid modifying the original,\n      // but prioritize the on-disk index if available to preserve manual edits\n      const updatedIndex: SymbolIndex = onDiskSymbolIndex \n        ? JSON.parse(JSON.stringify(onDiskSymbolIndex)) \n        : JSON.parse(JSON.stringify(existingIndex));\n      \n      // Normalize the changed file path\n      const normalizedChangedPath = FileSystemService.normalizeFilePath(changedFilePath, rootPath);\n      \n      // Skip if not a file we should analyze\n      if (!FileSystemService.isAnalyzableFile(changedFilePath)) {\n        return updatedIndex;\n      }\n      \n      // Handle file deletion\n      const fileExists = await FileSystemService.fileExists(changedFilePath);\n      if (!fileExists) {\n        return this.handleDeletedFile(updatedIndex, normalizedChangedPath, rootPath);\n      }\n      \n      // Store existing symbols from both the in-memory cache and the on-disk file \n      const existingFileSymbols = updatedIndex[normalizedChangedPath] || [];\n      const inMemoryFileSymbols = existingIndex[normalizedChangedPath] || [];\n      \n      // Combine docstrings from both sources, prioritizing on-disk version\n      const combinedExistingSymbols = this.mergeExistingSymbols(\n        existingFileSymbols,\n        inMemoryFileSymbols\n      );\n      \n      // Remove the changed file from the index\n      delete updatedIndex[normalizedChangedPath];\n      \n      // Remove references to the changed file from the index\n      this.pruneSymbolReferences(updatedIndex, normalizedChangedPath);\n      \n      // Extract new symbols from the changed file\n      const newSymbols = await SymbolExtractionService.extractSymbols(\n        changedFilePath, \n        normalizedChangedPath, \n        rootPath\n      );\n      \n      // Merge docstrings from existing symbols to new symbols\n      const mergedSymbols = this.mergeDocstrings(combinedExistingSymbols, newSymbols);\n      \n      // Add merged symbols to the index\n      if (mergedSymbols.length > 0) {\n        updatedIndex[normalizedChangedPath] = mergedSymbols;\n      }\n      \n      // Get all project files to resolve dependencies\n      const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n      \n      // Complete the indexing with shared post-processing\n      return this.finishIndexCreation(updatedIndex, projectFiles, rootPath);\n    } catch (error) {\n      console.error('Error updating symbol index:', error);\n      // If anything goes wrong during the update, return the original index unchanged\n      return existingIndex;\n    }\n  },\n\n  /**\n   * Merges symbols from the on-disk and in-memory caches, prioritizing the on-disk version\n   * @param onDiskSymbols - Symbols from the on-disk symbol index\n   * @param inMemorySymbols - Symbols from the in-memory cache\n   * @returns Combined symbols with preserved docstrings\n   */\n  mergeExistingSymbols(\n    onDiskSymbols: SymbolIndexEntry[],\n    inMemorySymbols: SymbolIndexEntry[]\n  ): SymbolIndexEntry[] {\n    // Start with all symbols from in-memory cache\n    const result = [...inMemorySymbols];\n    \n    // For each on-disk symbol, either update or add it to the result\n    for (const onDiskSymbol of onDiskSymbols) {\n      const existingIndex = result.findIndex(\n        s => s.name === onDiskSymbol.name && s.type === onDiskSymbol.type\n      );\n      \n      if (existingIndex >= 0) {\n        // Update existing symbol, prioritizing on-disk docstring\n        if (onDiskSymbol.docstring && \n            onDiskSymbol.docstring !== '/** */' && \n            onDiskSymbol.docstring !== '') {\n          result[existingIndex].docstring = onDiskSymbol.docstring;\n        }\n      } else {\n        // Add on-disk symbol not found in in-memory cache\n        result.push(onDiskSymbol);\n      }\n    }\n    \n    return result;\n  },\n\n  /**\n   * Handles when a file is deleted from the project\n   * @param updatedIndex - The current index being updated\n   * @param normalizedChangedPath - Normalized path of the deleted file\n   * @param rootPath - Project root path\n   * @returns The updated index\n   */\n  async handleDeletedFile(\n    updatedIndex: SymbolIndex,\n    normalizedChangedPath: string,\n    rootPath: string\n  ): Promise<SymbolIndex> {\n    // Remove the file from the index\n    delete updatedIndex[normalizedChangedPath];\n    \n    // Remove references to the deleted file from the index\n    this.pruneSymbolReferences(updatedIndex, normalizedChangedPath);\n    \n    // Write the updated index to file\n    await SymbolIndexService.writeSymbolIndex(rootPath, updatedIndex);\n    \n    return updatedIndex;\n  },\n\n  /**\n   * Merges docstrings from existing symbols to new symbols\n   * @param existingSymbols - Existing symbols from the file\n   * @param newSymbols - Newly extracted symbols\n   * @returns Merged symbols with preserved docstrings\n   */\n  mergeDocstrings(\n    existingSymbols: SymbolIndexEntry[],\n    newSymbols: SymbolIndexEntry[]\n  ): SymbolIndexEntry[] {\n    return newSymbols.map(newSymbol => {\n      // Try to find a matching symbol in the existing file symbols\n      const existingSymbol = existingSymbols.find(\n        existing => existing.name === newSymbol.name && existing.type === newSymbol.type\n      );\n      \n      // If a match is found and it has a non-empty docstring, preserve it\n      if (existingSymbol && existingSymbol.docstring && existingSymbol.docstring !== '/** */' && existingSymbol.docstring !== '') {\n        return {\n          ...newSymbol,\n          docstring: existingSymbol.docstring\n        };\n      }\n      \n      return newSymbol;\n    });\n  },\n\n  /**\n   * Removes references to a specific file from the symbol index\n   * @param index - The symbol index to update\n   * @param filePath - Normalized path of the file to remove references to\n   */\n  pruneSymbolReferences(\n    index: SymbolIndex,\n    filePath: string\n  ): void {\n    for (const indexFilePath in index) {\n      if (indexFilePath === filePath) {\n        continue;\n      }\n      \n      const fileSymbols = index[indexFilePath];\n      \n      for (const symbol of fileSymbols) {\n        // Remove references to the file in dependents\n        symbol.dependents = symbol.dependents.filter(\n          dependent => dependent.filePath !== filePath\n        );\n        \n        // Remove dependencies on symbols from the file\n        symbol.depends_on = symbol.depends_on.filter(dep => \n          dep.filePath !== filePath\n        );\n      }\n    }\n  },\n\n  /**\n   * Completes the index creation process with shared post-processing steps\n   * @param index - The symbol index to finalize\n   * @param projectFiles - List of project files\n   * @param rootPath - Project root path\n   * @param progress - Optional progress reporter\n   * @returns The finalized symbol index\n   */\n  async finishIndexCreation(\n    index: SymbolIndex,\n    projectFiles: string[],\n    rootPath: string,\n    progress?: { report: (info: { message: string }) => void }\n  ): Promise<SymbolIndex> {\n    // Resolve dependencies between symbols\n    progress?.report({ message: 'Resolving symbol dependencies...' });\n    await DependencyResolverService.resolveDependencies(index, projectFiles, rootPath);\n    \n    // Write the symbol index to file\n    progress?.report({ message: 'Writing symbol index to file...' });\n    await SymbolIndexService.writeSymbolIndex(rootPath, index);\n    \n    progress?.report({ message: 'Symbol index creation complete.' });\n    return index;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "projectFiles",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 28,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 31,
          "contextSnippet": "      const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n      \n      // Safety check - limit number of files to process\n      if (projectFiles.length > MAX_FILES_TO_PROCESS) {\n        console.warn(`Project contains ${projectFiles.length} files, which exceeds the limit of ${MAX_FILES_TO_PROCESS}. Only processing the first ${MAX_FILES_TO_PROCESS} files.`);\n        projectFiles.length = MAX_FILES_TO_PROCESS;\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingSymbolIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 37,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "existingSymbolIndex = await SymbolIndexService.readSymbolIndex(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 66,
          "contextSnippet": "        );\n        \n        // Preserve docstrings from existing symbol index if available\n        const existingFileSymbols = existingSymbolIndex?.[normalizedPath] || [];\n        const mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols);\n        \n        // Initialize file entry in the index"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 40,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolIndex: SymbolIndex = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 71,
          "contextSnippet": "        \n        // Initialize file entry in the index\n        if (mergedSymbols.length > 0) {\n          symbolIndex[normalizedPath] = mergedSymbols;\n        }\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 45,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "filePath = projectFiles[i]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 48,
          "contextSnippet": "        const filePath = projectFiles[i];\n        \n        // Skip files we shouldn't analyze\n        if (!FileSystemService.isAnalyzableFile(filePath)) {\n          continue;\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "normalizedPath",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 56,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "normalizedPath = FileSystemService.normalizeFilePath(filePath, rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 61,
          "contextSnippet": "        // Extract symbols from the file\n        const symbols = await SymbolExtractionService.extractSymbols(\n          filePath, \n          normalizedPath, \n          rootPath\n        );\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 59,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "symbols = await SymbolExtractionService.extractSymbols(\n          filePath, \n          normalizedPath, \n          rootPath\n        )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 67,
          "contextSnippet": "        \n        // Preserve docstrings from existing symbol index if available\n        const existingFileSymbols = existingSymbolIndex?.[normalizedPath] || [];\n        const mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols);\n        \n        // Initialize file entry in the index\n        if (mergedSymbols.length > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingFileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 66,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "existingFileSymbols = existingSymbolIndex?.[normalizedPath] || []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 67,
          "contextSnippet": "        \n        // Preserve docstrings from existing symbol index if available\n        const existingFileSymbols = existingSymbolIndex?.[normalizedPath] || [];\n        const mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols);\n        \n        // Initialize file entry in the index\n        if (mergedSymbols.length > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 67,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 70,
          "contextSnippet": "        const mergedSymbols = this.mergeDocstrings(existingFileSymbols, symbols);\n        \n        // Initialize file entry in the index\n        if (mergedSymbols.length > 0) {\n          symbolIndex[normalizedPath] = mergedSymbols;\n        }\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "onDiskSymbolIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 99,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "onDiskSymbolIndex = await SymbolIndexService.readSymbolIndex(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 103,
          "contextSnippet": "      \n      // Create a deep copy of the existing index to avoid modifying the original,\n      // but prioritize the on-disk index if available to preserve manual edits\n      const updatedIndex: SymbolIndex = onDiskSymbolIndex \n        ? JSON.parse(JSON.stringify(onDiskSymbolIndex)) \n        : JSON.parse(JSON.stringify(existingIndex));\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "updatedIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 103,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "updatedIndex: SymbolIndex = onDiskSymbolIndex \n        ? JSON.parse(JSON.stringify(onDiskSymbolIndex)) \n        : JSON.parse(JSON.stringify(existingIndex))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 112,
          "contextSnippet": "      \n      // Skip if not a file we should analyze\n      if (!FileSystemService.isAnalyzableFile(changedFilePath)) {\n        return updatedIndex;\n      }\n      \n      // Handle file deletion"
        }
      ],
      "depends_on": []
    },
    {
      "name": "normalizedChangedPath",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 108,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "normalizedChangedPath = FileSystemService.normalizeFilePath(changedFilePath, rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 118,
          "contextSnippet": "      // Handle file deletion\n      const fileExists = await FileSystemService.fileExists(changedFilePath);\n      if (!fileExists) {\n        return this.handleDeletedFile(updatedIndex, normalizedChangedPath, rootPath);\n      }\n      \n      // Store existing symbols from both the in-memory cache and the on-disk file "
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileExists",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 116,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileExists = await FileSystemService.fileExists(changedFilePath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 117,
          "contextSnippet": "      \n      // Handle file deletion\n      const fileExists = await FileSystemService.fileExists(changedFilePath);\n      if (!fileExists) {\n        return this.handleDeletedFile(updatedIndex, normalizedChangedPath, rootPath);\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingFileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 122,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "existingFileSymbols = updatedIndex[normalizedChangedPath] || []",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "inMemoryFileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 123,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "inMemoryFileSymbols = existingIndex[normalizedChangedPath] || []",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 128,
          "contextSnippet": "      // Combine docstrings from both sources, prioritizing on-disk version\n      const combinedExistingSymbols = this.mergeExistingSymbols(\n        existingFileSymbols,\n        inMemoryFileSymbols\n      );\n      \n      // Remove the changed file from the index"
        }
      ],
      "depends_on": []
    },
    {
      "name": "combinedExistingSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 126,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "combinedExistingSymbols = this.mergeExistingSymbols(\n        existingFileSymbols,\n        inMemoryFileSymbols\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 145,
          "contextSnippet": "      );\n      \n      // Merge docstrings from existing symbols to new symbols\n      const mergedSymbols = this.mergeDocstrings(combinedExistingSymbols, newSymbols);\n      \n      // Add merged symbols to the index\n      if (mergedSymbols.length > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "newSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 138,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "newSymbols = await SymbolExtractionService.extractSymbols(\n        changedFilePath, \n        normalizedChangedPath, \n        rootPath\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 145,
          "contextSnippet": "      );\n      \n      // Merge docstrings from existing symbols to new symbols\n      const mergedSymbols = this.mergeDocstrings(combinedExistingSymbols, newSymbols);\n      \n      // Add merged symbols to the index\n      if (mergedSymbols.length > 0) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "mergedSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 145,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "mergedSymbols = this.mergeDocstrings(combinedExistingSymbols, newSymbols)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "projectFiles",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 153,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 175,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "result = [...inMemorySymbols]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 179,
          "contextSnippet": "    \n    // For each on-disk symbol, either update or add it to the result\n    for (const onDiskSymbol of onDiskSymbols) {\n      const existingIndex = result.findIndex(\n        s => s.name === onDiskSymbol.name && s.type === onDiskSymbol.type\n      );\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 179,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "existingIndex = result.findIndex(\n        s => s.name === onDiskSymbol.name && s.type === onDiskSymbol.type\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 105,
          "contextSnippet": "      // but prioritize the on-disk index if available to preserve manual edits\n      const updatedIndex: SymbolIndex = onDiskSymbolIndex \n        ? JSON.parse(JSON.stringify(onDiskSymbolIndex)) \n        : JSON.parse(JSON.stringify(existingIndex));\n      \n      // Normalize the changed file path\n      const normalizedChangedPath = FileSystemService.normalizeFilePath(changedFilePath, rootPath);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "existingSymbol",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 235,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "existingSymbol = existingSymbols.find(\n        existing => existing.name === newSymbol.name && existing.type === newSymbol.type\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 240,
          "contextSnippet": "      );\n      \n      // If a match is found and it has a non-empty docstring, preserve it\n      if (existingSymbol && existingSymbol.docstring && existingSymbol.docstring !== '/** */' && existingSymbol.docstring !== '') {\n        return {\n          ...newSymbol,\n          docstring: existingSymbol.docstring"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileSymbols",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 265,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileSymbols = index[indexFilePath]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 267,
          "contextSnippet": "      \n      const fileSymbols = index[indexFilePath];\n      \n      for (const symbol of fileSymbols) {\n        // Remove references to the file in dependents\n        symbol.dependents = symbol.dependents.filter(\n          dependent => dependent.filePath !== filePath"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "projectFiles",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 31
        },
        {
          "name": "filePath",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 48
        },
        {
          "name": "normalizedPath",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 61
        },
        {
          "name": "existingSymbolIndex",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 66
        },
        {
          "name": "existingFileSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 67
        },
        {
          "name": "symbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 67
        },
        {
          "name": "mergedSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 70
        },
        {
          "name": "symbolIndex",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 71
        },
        {
          "name": "onDiskSymbolIndex",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 103
        },
        {
          "name": "existingIndex",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 105
        },
        {
          "name": "updatedIndex",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 112
        },
        {
          "name": "fileExists",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 117
        },
        {
          "name": "normalizedChangedPath",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 118
        },
        {
          "name": "inMemoryFileSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 128
        },
        {
          "name": "combinedExistingSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 145
        },
        {
          "name": "newSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 145
        },
        {
          "name": "result",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 179
        },
        {
          "name": "existingSymbol",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 240
        },
        {
          "name": "fileSymbols",
          "filePath": "src/features/symbol-index/symbol-index-orchestrator.ts",
          "line": 267
        }
      ]
    }
  ],
  "src/features/symbol-index/symbol-index.ts": [
    {
      "name": "createSymbolIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index.ts",
      "location": {
        "line": 16,
        "character": 13
      },
      "docstring": "/**\n * Creates a complete symbol index for a project\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore during file processing\n * @param progress - Optional progress reporter\n * @returns The complete symbol index\n */",
      "snippet": "createSymbolIndex = async (\n  rootPath: string,\n  ignoredPatterns: string[] = [],\n  progress?: { report: (info: { message: string }) => void }\n): Promise<SymbolIndex> => {\n  return SymbolIndexOrchestrator.createSymbolIndex(rootPath, ignoredPatterns, progress);\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "extractJSDocComment",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index.ts",
      "location": {
        "line": 30,
        "character": 6
      },
      "docstring": "/**\n * Extracts JSDoc comment from a node if present\n * @param node - The TypeScript node\n * @param sourceFile - The source file\n * @returns The JSDoc comment text or empty string\n */",
      "snippet": "extractJSDocComment = (node: ts.Node, sourceFile: ts.SourceFile): string => {\n  const jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[];\n  \n  if (jsDocComments && jsDocComments.length > 0) {\n    // Get the first JSDoc comment\n    const jsDoc = jsDocComments[0];\n    \n    // Extract the JSDoc text\n    if (jsDoc.getFullText) {\n      return jsDoc.getFullText(sourceFile);\n    }\n  }\n  \n  return '';\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "jsDocComments",
          "filePath": "src/features/symbol-index/symbol-index.ts",
          "line": 33
        },
        {
          "name": "jsDoc",
          "filePath": "src/features/symbol-index/symbol-index.ts",
          "line": 38
        }
      ]
    },
    {
      "name": "jsDocComments",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index.ts",
      "location": {
        "line": 31,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[]",
      "dependents": [
        {
          "name": "extractJSDocComment",
          "filePath": "src/features/symbol-index/symbol-index.ts",
          "line": 33,
          "contextSnippet": "const extractJSDocComment = (node: ts.Node, sourceFile: ts.SourceFile): string => {\n  const jsDocComments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[];\n  \n  if (jsDocComments && jsDocComments.length > 0) {\n    // Get the first JSDoc comment\n    const jsDoc = jsDocComments[0];\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "jsDoc",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index.ts",
      "location": {
        "line": 35,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "jsDoc = jsDocComments[0]",
      "dependents": [
        {
          "name": "extractJSDocComment",
          "filePath": "src/features/symbol-index/symbol-index.ts",
          "line": 38,
          "contextSnippet": "    const jsDoc = jsDocComments[0];\n    \n    // Extract the JSDoc text\n    if (jsDoc.getFullText) {\n      return jsDoc.getFullText(sourceFile);\n    }\n  }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "updateSymbolIndex",
      "type": "variable",
      "filePath": "src/features/symbol-index/symbol-index.ts",
      "location": {
        "line": 54,
        "character": 13
      },
      "docstring": "/**\n * Updates the symbol index for a changed file\n * @param rootPath - Project root path\n * @param existingIndex - The existing symbol index\n * @param changedFilePath - Path to the changed file\n * @param ignoredPatterns - Patterns to ignore during file processing\n * @returns The updated symbol index\n */",
      "snippet": "updateSymbolIndex = async (\n  rootPath: string,\n  existingIndex: SymbolIndex,\n  changedFilePath: string,\n  ignoredPatterns: string[] = []\n): Promise<SymbolIndex> => {\n  return SymbolIndexOrchestrator.updateSymbolIndex(\n    rootPath,\n    existingIndex,\n    changedFilePath,\n    ignoredPatterns\n  );\n}",
      "dependents": [],
      "depends_on": []
    }
  ],
  "src/shared/services/file-system-service.ts": [
    {
      "name": "ANALYZABLE_EXTENSIONS",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 7,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "ANALYZABLE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx']",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 34,
          "contextSnippet": "   */\n  isAnalyzableFile(filePath: string): boolean {\n    const ext = path.extname(filePath).toLowerCase();\n    return ANALYZABLE_EXTENSIONS.includes(ext);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ALWAYS_IGNORED_DIRS",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 8,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "ALWAYS_IGNORED_DIRS = ['node_modules', '.next', 'dist', 'build', '.git', '.vscode']",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 70,
          "contextSnippet": "    const relPath = path.relative(rootPath, filePath);\n    \n    // Check if the path contains any of the always ignored directories\n    if (ALWAYS_IGNORED_DIRS.some(dir => \n      relPath.startsWith(dir + path.sep) || \n      relPath === dir ||\n      relPath.includes(path.sep + dir + path.sep)"
        }
      ],
      "depends_on": []
    },
    {
      "name": "MAX_FILES_TO_PROCESS",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 9,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "MAX_FILES_TO_PROCESS = 2000",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "execAsync",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 11,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "execAsync = promisify(exec)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 106,
          "contextSnippet": "    \n    // Try to use git ls-files first for better performance\n    try {\n      const { stdout } = await execAsync('git ls-files', { cwd: rootPath });\n      const files = stdout.split('\\n').filter(Boolean);\n      \n      // Convert relative paths to absolute"
        }
      ],
      "depends_on": []
    },
    {
      "name": "FileSystemService",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 16,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "FileSystemService = {\n  /**\n   * Normalizes a file path relative to the project root\n   * @param filePath - The file path to normalize\n   * @param rootPath - The project root path\n   * @returns The normalized file path\n   */\n  normalizeFilePath(filePath: string, rootPath: string): string {\n    return path.relative(rootPath, filePath).replace(/\\\\/g, '/');\n  },\n\n  /**\n   * Checks if a file is analyzable based on its extension\n   * @param filePath - The file path to check\n   * @returns Whether the file is analyzable\n   */\n  isAnalyzableFile(filePath: string): boolean {\n    const ext = path.extname(filePath).toLowerCase();\n    return ANALYZABLE_EXTENSIONS.includes(ext);\n  },\n\n  /**\n   * Parses .gitignore and returns its rules\n   * @param rootPath - The project root path\n   * @returns Array of gitignore rules\n   */\n  async parseGitignore(rootPath: string): Promise<string[]> {\n    try {\n      const gitignorePath = path.join(rootPath, '.gitignore');\n      if (await fs.pathExists(gitignorePath)) {\n        const content = await fs.readFile(gitignorePath, 'utf8');\n        return content\n          .split('\\n')\n          .map((line: string) => line.trim())\n          .filter((line: string) => line && !line.startsWith('#'));\n      }\n      return [];\n    } catch (error) {\n      console.error('Error parsing .gitignore:', error);\n      return [];\n    }\n  },\n\n  /**\n   * Checks if a file path should be ignored based on gitignore patterns\n   * @param filePath - The file path to check\n   * @param rootPath - The project root path\n   * @param ignoredPatterns - Array of patterns to ignore\n   * @returns Whether the file should be ignored\n   */\n  isIgnored(filePath: string, rootPath: string, ignoredPatterns: string[]): boolean {\n    const relPath = path.relative(rootPath, filePath);\n    \n    // Check if the path contains any of the always ignored directories\n    if (ALWAYS_IGNORED_DIRS.some(dir => \n      relPath.startsWith(dir + path.sep) || \n      relPath === dir ||\n      relPath.includes(path.sep + dir + path.sep)\n    )) {\n      return true;\n    }\n    \n    // Check against gitignore patterns\n    return ignoredPatterns.some(pattern => {\n      // Simple pattern matching (can be enhanced for more complex gitignore rules)\n      if (pattern.endsWith('/')) {\n        // Directory pattern\n        return relPath.startsWith(pattern) || relPath.includes(`/${pattern}`);\n      }\n      // File pattern\n      return relPath === pattern || relPath.endsWith(`/${pattern}`) || \n             // Handle wildcard patterns like *.vsix\n             (pattern.startsWith('*') && relPath.endsWith(pattern.substring(1)));\n    });\n  },\n\n  /**\n   * Gets all project files, respecting gitignore rules\n   * @param rootPath - The project root path\n   * @param ignoredPatterns - Array of patterns to ignore\n   * @returns Array of file paths\n   */\n  async getProjectFiles(\n    rootPath: string,\n    ignoredPatterns: string[] = []\n  ): Promise<string[]> {\n    const result: string[] = [];\n    \n    // Try to use git ls-files first for better performance\n    try {\n      const { stdout } = await execAsync('git ls-files', { cwd: rootPath });\n      const files = stdout.split('\\n').filter(Boolean);\n      \n      // Convert relative paths to absolute\n      return files\n        .map(file => path.join(rootPath, file))\n        .filter(file => !this.isIgnored(file, rootPath, ignoredPatterns));\n    } catch (error) {\n      // Fallback to manual traversal if git is not available\n      console.warn('Git ls-files failed, falling back to manual traversal:', error);\n      \n      const traverseDirectory = async (currentPath: string): Promise<void> => {\n        const items = await fs.readdir(currentPath);\n        \n        for (const item of items) {\n          const itemPath = path.join(currentPath, item);\n          \n          if (this.isIgnored(itemPath, rootPath, ignoredPatterns)) {\n            continue;\n          }\n          \n          const stats = await fs.stat(itemPath);\n          \n          if (stats.isDirectory()) {\n            await traverseDirectory(itemPath);\n          } else {\n            result.push(itemPath);\n          }\n        }\n      };\n      \n      await traverseDirectory(rootPath);\n      return result;\n    }\n  },\n\n  /**\n   * Gets all analyzable project files, respecting gitignore rules\n   * @param rootPath - The project root path\n   * @param ignoredPatterns - Array of patterns to ignore\n   * @returns Array of analyzable file paths\n   */\n  async getAnalyzableProjectFiles(\n    rootPath: string,\n    ignoredPatterns: string[] = []\n  ): Promise<string[]> {\n    const allFiles = await this.getProjectFiles(rootPath, ignoredPatterns);\n    return allFiles.filter(file => this.isAnalyzableFile(file));\n  },\n\n  /**\n   * Builds a tree structure from a list of file paths\n   * @param paths - Array of file paths\n   * @returns Tree structure as a nested object\n   */\n  buildTreeFromPaths(paths: string[]): Record<string, any> {\n    const tree: Record<string, any> = {};\n    \n    for (const filePath of paths) {\n      const parts = filePath.split('/');\n      let current = tree;\n      \n      // Process all directories in the path\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!current[part]) {\n          current[part] = {};\n        }\n        current = current[part];\n      }\n      \n      // Add the file (last part)\n      const fileName = parts[parts.length - 1];\n      current[fileName] = null; // null indicates it's a file\n    }\n    \n    return tree;\n  },\n\n  /**\n   * Formats a tree structure as a string\n   * @param tree - Tree structure as a nested object\n   * @param prefix - Prefix for formatting (used recursively)\n   * @returns Formatted tree as a string\n   */\n  formatTree(tree: Record<string, any>, prefix: string = ''): string {\n    let result = '';\n    const entries = Object.entries(tree);\n    \n    entries.forEach(([name, subtree], index) => {\n      const isLast = index === entries.length - 1;\n      const linePrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';\n      const childPrefix = isLast ? '    ' : 'â”‚   ';\n      \n      result += `${prefix}${linePrefix}${name}\\n`;\n      \n      if (subtree !== null) {\n        result += this.formatTree(subtree, `${prefix}${childPrefix}`);\n      }\n    });\n    \n    return result;\n  },\n\n  /**\n   * Checks if a file exists\n   * @param filePath - Path to the file\n   * @returns Whether the file exists\n   */\n  async fileExists(filePath: string): Promise<boolean> {\n    try {\n      const stats = await fs.stat(filePath);\n      return stats.isFile();\n    } catch (error) {\n      return false;\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "ext",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 33,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "ext = path.extname(filePath).toLowerCase()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 34,
          "contextSnippet": "   */\n  isAnalyzableFile(filePath: string): boolean {\n    const ext = path.extname(filePath).toLowerCase();\n    return ANALYZABLE_EXTENSIONS.includes(ext);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "gitignorePath",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 44,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "gitignorePath = path.join(rootPath, '.gitignore')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 45,
          "contextSnippet": "  async parseGitignore(rootPath: string): Promise<string[]> {\n    try {\n      const gitignorePath = path.join(rootPath, '.gitignore');\n      if (await fs.pathExists(gitignorePath)) {\n        const content = await fs.readFile(gitignorePath, 'utf8');\n        return content\n          .split('\\n')"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 46,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "content = await fs.readFile(gitignorePath, 'utf8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 47,
          "contextSnippet": "      const gitignorePath = path.join(rootPath, '.gitignore');\n      if (await fs.pathExists(gitignorePath)) {\n        const content = await fs.readFile(gitignorePath, 'utf8');\n        return content\n          .split('\\n')\n          .map((line: string) => line.trim())\n          .filter((line: string) => line && !line.startsWith('#'));"
        }
      ],
      "depends_on": []
    },
    {
      "name": "relPath",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 67,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "relPath = path.relative(rootPath, filePath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 71,
          "contextSnippet": "    \n    // Check if the path contains any of the always ignored directories\n    if (ALWAYS_IGNORED_DIRS.some(dir => \n      relPath.startsWith(dir + path.sep) || \n      relPath === dir ||\n      relPath.includes(path.sep + dir + path.sep)\n    )) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 102,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "result: string[] = []",
      "dependents": [
        {
          "name": "traverseDirectory",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 132,
          "contextSnippet": "          if (stats.isDirectory()) {\n            await traverseDirectory(itemPath);\n          } else {\n            result.push(itemPath);\n          }\n        }\n      };"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 138,
          "contextSnippet": "      };\n      \n      await traverseDirectory(rootPath);\n      return result;\n    }\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "files",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 107,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "files = stdout.split('\\n').filter(Boolean)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 110,
          "contextSnippet": "      const files = stdout.split('\\n').filter(Boolean);\n      \n      // Convert relative paths to absolute\n      return files\n        .map(file => path.join(rootPath, file))\n        .filter(file => !this.isIgnored(file, rootPath, ignoredPatterns));\n    } catch (error) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "traverseDirectory",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 117,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "traverseDirectory = async (currentPath: string): Promise<void> => {\n        const items = await fs.readdir(currentPath);\n        \n        for (const item of items) {\n          const itemPath = path.join(currentPath, item);\n          \n          if (this.isIgnored(itemPath, rootPath, ignoredPatterns)) {\n            continue;\n          }\n          \n          const stats = await fs.stat(itemPath);\n          \n          if (stats.isDirectory()) {\n            await traverseDirectory(itemPath);\n          } else {\n            result.push(itemPath);\n          }\n        }\n      }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 137,
          "contextSnippet": "        }\n      };\n      \n      await traverseDirectory(rootPath);\n      return result;\n    }\n  },"
        }
      ],
      "depends_on": [
        {
          "name": "items",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 120
        },
        {
          "name": "itemPath",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 123
        },
        {
          "name": "stats",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 129
        },
        {
          "name": "result",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 132
        }
      ]
    },
    {
      "name": "items",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 118,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "items = await fs.readdir(currentPath)",
      "dependents": [
        {
          "name": "traverseDirectory",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 120,
          "contextSnippet": "      const traverseDirectory = async (currentPath: string): Promise<void> => {\n        const items = await fs.readdir(currentPath);\n        \n        for (const item of items) {\n          const itemPath = path.join(currentPath, item);\n          \n          if (this.isIgnored(itemPath, rootPath, ignoredPatterns)) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "itemPath",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 121,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "itemPath = path.join(currentPath, item)",
      "dependents": [
        {
          "name": "traverseDirectory",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 123,
          "contextSnippet": "        for (const item of items) {\n          const itemPath = path.join(currentPath, item);\n          \n          if (this.isIgnored(itemPath, rootPath, ignoredPatterns)) {\n            continue;\n          }\n          "
        }
      ],
      "depends_on": []
    },
    {
      "name": "stats",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 127,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "stats = await fs.stat(itemPath)",
      "dependents": [
        {
          "name": "traverseDirectory",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 129,
          "contextSnippet": "          \n          const stats = await fs.stat(itemPath);\n          \n          if (stats.isDirectory()) {\n            await traverseDirectory(itemPath);\n          } else {\n            result.push(itemPath);"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 218,
          "contextSnippet": "  async fileExists(filePath: string): Promise<boolean> {\n    try {\n      const stats = await fs.stat(filePath);\n      return stats.isFile();\n    } catch (error) {\n      return false;\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "allFiles",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 152,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "allFiles = await this.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 153,
          "contextSnippet": "    ignoredPatterns: string[] = []\n  ): Promise<string[]> {\n    const allFiles = await this.getProjectFiles(rootPath, ignoredPatterns);\n    return allFiles.filter(file => this.isAnalyzableFile(file));\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "tree",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 162,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "tree: Record<string, any> = {}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 166,
          "contextSnippet": "    \n    for (const filePath of paths) {\n      const parts = filePath.split('/');\n      let current = tree;\n      \n      // Process all directories in the path\n      for (let i = 0; i < parts.length - 1; i++) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "parts",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 165,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "parts = filePath.split('/')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 169,
          "contextSnippet": "      let current = tree;\n      \n      // Process all directories in the path\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!current[part]) {\n          current[part] = {};"
        }
      ],
      "depends_on": []
    },
    {
      "name": "current",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 166,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "current = tree",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 171,
          "contextSnippet": "      // Process all directories in the path\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!current[part]) {\n          current[part] = {};\n        }\n        current = current[part];"
        }
      ],
      "depends_on": []
    },
    {
      "name": "part",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 170,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "part = parts[i]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 171,
          "contextSnippet": "      // Process all directories in the path\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!current[part]) {\n          current[part] = {};\n        }\n        current = current[part];"
        }
      ],
      "depends_on": []
    },
    {
      "name": "fileName",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 178,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "fileName = parts[parts.length - 1]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 179,
          "contextSnippet": "      \n      // Add the file (last part)\n      const fileName = parts[parts.length - 1];\n      current[fileName] = null; // null indicates it's a file\n    }\n    \n    return tree;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 192,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "result = ''",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "entries",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 193,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "entries = Object.entries(tree)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 195,
          "contextSnippet": "    let result = '';\n    const entries = Object.entries(tree);\n    \n    entries.forEach(([name, subtree], index) => {\n      const isLast = index === entries.length - 1;\n      const linePrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';\n      const childPrefix = isLast ? '    ' : 'â”‚   ';"
        }
      ],
      "depends_on": []
    },
    {
      "name": "isLast",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 196,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "isLast = index === entries.length - 1",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 197,
          "contextSnippet": "    \n    entries.forEach(([name, subtree], index) => {\n      const isLast = index === entries.length - 1;\n      const linePrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';\n      const childPrefix = isLast ? '    ' : 'â”‚   ';\n      \n      result += `${prefix}${linePrefix}${name}\\n`;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "linePrefix",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 197,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "linePrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ '",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 200,
          "contextSnippet": "      const linePrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';\n      const childPrefix = isLast ? '    ' : 'â”‚   ';\n      \n      result += `${prefix}${linePrefix}${name}\\n`;\n      \n      if (subtree !== null) {\n        result += this.formatTree(subtree, `${prefix}${childPrefix}`);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "childPrefix",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 198,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "childPrefix = isLast ? '    ' : 'â”‚   '",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 203,
          "contextSnippet": "      result += `${prefix}${linePrefix}${name}\\n`;\n      \n      if (subtree !== null) {\n        result += this.formatTree(subtree, `${prefix}${childPrefix}`);\n      }\n    });\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "stats",
      "type": "variable",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 217,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "stats = await fs.stat(filePath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/file-system-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "ANALYZABLE_EXTENSIONS",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 34
        },
        {
          "name": "ext",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 34
        },
        {
          "name": "gitignorePath",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 45
        },
        {
          "name": "content",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 47
        },
        {
          "name": "ALWAYS_IGNORED_DIRS",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 70
        },
        {
          "name": "relPath",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 71
        },
        {
          "name": "execAsync",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 106
        },
        {
          "name": "files",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 110
        },
        {
          "name": "traverseDirectory",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 137
        },
        {
          "name": "result",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 138
        },
        {
          "name": "allFiles",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 153
        },
        {
          "name": "tree",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 166
        },
        {
          "name": "parts",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 169
        },
        {
          "name": "current",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 171
        },
        {
          "name": "part",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 171
        },
        {
          "name": "fileName",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 179
        },
        {
          "name": "entries",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 195
        },
        {
          "name": "isLast",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 197
        },
        {
          "name": "linePrefix",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 200
        },
        {
          "name": "childPrefix",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 203
        },
        {
          "name": "stats",
          "filePath": "src/shared/services/file-system-service.ts",
          "line": 218
        }
      ]
    }
  ],
  "src/shared/services/openai-service.ts": [
    {
      "name": "EnvVars",
      "type": "interface",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 10,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface EnvVars {\n  OPENAI_API_KEY?: string;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 74,
          "contextSnippet": "   * @param workspaceFolder - The workspace folder path\n   * @returns An object containing loaded environment variables\n   */\n  loadEnvironmentVars(workspaceFolder?: string): EnvVars {\n    // Try to load from .env.local in workspace root if provided\n    if (workspaceFolder) {\n      const envLocalPath = path.join(workspaceFolder, '.env.local');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "openaiModel",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 14,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "openaiModel = 'o3-mini'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 204,
          "contextSnippet": "          try {\n            // First try the beta.chat.completions.parse method\n            const completion = await client.beta.chat.completions.parse({\n              model: openaiModel,\n              messages: [\n                { \n                  role: 'system', "
        }
      ],
      "depends_on": []
    },
    {
      "name": "DocstringOutput",
      "type": "interface",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 17,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DocstringOutput {\n  docstrings: Array<{\n    name: string;\n    docstring: string;\n    type: 'function' | 'class' | 'interface' | 'type' | 'variable' | 'method' | 'enum' | 'other';\n    line: number;\n  }>;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 197,
          "contextSnippet": "    client: OpenAI, \n    prompt: string,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<DocstringOutput> {\n    try {\n      return await this.withRetry(\n        async () => {"
        }
      ],
      "depends_on": [
        {
          "name": "docstring",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 20
        }
      ]
    },
    {
      "name": "DocstringSchema",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 27,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DocstringSchema = z.object({\n  docstrings: z.array(\n    z.object({\n      name: z.string().describe('The name of the function/method'),\n      type: z.enum(['function', 'class', 'interface', 'type', 'variable', 'method', 'enum', 'other']).describe('The type of the node (function, class, etc.)'),\n      line: z.number().describe('The line number where the node starts'),\n      docstring: z.string().describe('The generated JSDoc comment block')\n    })\n  )\n})",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 212,
          "contextSnippet": "                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DocstringSchema, \"response\"),\n            });\n\n            // Extract the parsed result which is already validated against the schema"
        }
      ],
      "depends_on": []
    },
    {
      "name": "RetryConfig",
      "type": "interface",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 41,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "interface RetryConfig {\n  /** Maximum number of retry attempts */\n  maxRetries: number;\n  /** Initial delay before first retry (in milliseconds) */\n  initialDelayMs: number;\n  /** Factor to multiply delay by after each retry */\n  backoffFactor: number;\n  /** Maximum delay between retries (in milliseconds) */\n  maxDelayMs: number;\n  /** Whether to log detailed retry information */\n  verbose: boolean;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 57,
          "contextSnippet": "/**\n * Default retry configuration\n */\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  backoffFactor: 2,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DEFAULT_RETRY_CONFIG",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 57,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  backoffFactor: 2,\n  maxDelayMs: 10000,\n  verbose: true\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 121,
          "contextSnippet": "   */\n  async withRetry<T>(\n    operation: () => Promise<T>,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<T> {\n    let lastError: unknown;\n    let delay = retryConfig.initialDelayMs;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "OpenAiService",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 68,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "OpenAiService = {\n  /**\n   * Loads environment variables from .env.local file\n   * @param workspaceFolder - The workspace folder path\n   * @returns An object containing loaded environment variables\n   */\n  loadEnvironmentVars(workspaceFolder?: string): EnvVars {\n    // Try to load from .env.local in workspace root if provided\n    if (workspaceFolder) {\n      const envLocalPath = path.join(workspaceFolder, '.env.local');\n      if (fs.existsSync(envLocalPath)) {\n        const result = dotenv.config({ path: envLocalPath });\n        if (result.error) {\n          console.error('Error loading .env.local file:', result.error);\n        } else {\n          console.log('.env.local loaded successfully from workspace folder');\n        }\n      }\n    }\n    \n    // If no OpenAI API key is found in process.env, try to get it from VSCode settings\n    const config = vscode.workspace.getConfiguration('cursorcrawl');\n    const apiKey = process.env.OPENAI_API_KEY || config.get('openaiApiKey');\n    \n    return {\n      OPENAI_API_KEY: apiKey as string,\n    };\n  },\n\n  /**\n   * Creates an OpenAI API client using the API key\n   * @param apiKey - The OpenAI API key\n   * @returns An OpenAI API client instance\n   */\n  createOpenAIClient(apiKey?: string): OpenAI | undefined {\n    if (!apiKey) {\n      console.error('OpenAI API key not found');\n      return undefined;\n    }\n    \n    return new OpenAI({\n      apiKey,\n    });\n  },\n\n  /**\n   * Executes a function with retry logic using exponential backoff\n   * @param operation - Async function to execute with retry logic\n   * @param retryConfig - Configuration for retry behavior\n   * @returns Promise resolving to the operation result\n   */\n  async withRetry<T>(\n    operation: () => Promise<T>,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<T> {\n    let lastError: unknown;\n    let delay = retryConfig.initialDelayMs;\n\n    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {\n      try {\n        if (attempt > 0 && retryConfig.verbose) {\n          console.log(`Retry attempt ${attempt}/${retryConfig.maxRetries} after ${delay}ms delay...`);\n        }\n\n        // Execute the operation\n        return await operation();\n      } catch (error) {\n        lastError = error;\n\n        // Check if we've reached max retries\n        if (attempt >= retryConfig.maxRetries) {\n          if (retryConfig.verbose) {\n            console.error(`All ${retryConfig.maxRetries} retry attempts failed.`);\n          }\n          \n          // Enhance the error message to indicate retry exhaustion\n          if (error instanceof Error) {\n            error.message = `After ${retryConfig.maxRetries} retry attempts: ${error.message}`;\n            // Add a marker property to indicate this error persisted after retries\n            (error as any).retriesExhausted = true;\n          }\n          \n          break;\n        }\n\n        // Check if error is retryable (5xx status codes are usually temporary server errors)\n        const isRetryable = error instanceof Error && \n          (error.message.includes('500') || \n           error.message.includes('502') || \n           error.message.includes('503') || \n           error.message.includes('504') ||\n           error.message.includes('rate limit') ||\n           error.message.includes('timeout'));\n\n        if (!isRetryable) {\n          if (retryConfig.verbose) {\n            console.error('Non-retryable error encountered:', error);\n          }\n          break;\n        }\n\n        // Log the error\n        if (retryConfig.verbose) {\n          console.warn(`Attempt ${attempt + 1} failed:`, error);\n        }\n\n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, delay));\n\n        // Increase delay for next retry using exponential backoff\n        delay = Math.min(delay * retryConfig.backoffFactor, retryConfig.maxDelayMs);\n      }\n    }\n\n    // If we got here, all retries failed\n    throw lastError;\n  },\n\n  /**\n   * Safely generates docstrings for multiple code elements using standard completion\n   * @param client - The OpenAI API client\n   * @param prompt - The prompt to send to the API\n   * @param retryConfig - Configuration for retry behavior\n   * @returns Promise resolving to the parsed response\n   */\n  async safeCompletionWithParse(\n    client: OpenAI, \n    prompt: string,\n    retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG\n  ): Promise<DocstringOutput> {\n    try {\n      return await this.withRetry(\n        async () => {\n          try {\n            // First try the beta.chat.completions.parse method\n            const completion = await client.beta.chat.completions.parse({\n              model: openaiModel,\n              messages: [\n                { \n                  role: 'system', \n                  content: 'You are a helpful assistant that generates high-quality TypeScript docstrings.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DocstringSchema, \"response\"),\n            });\n\n            // Extract the parsed result which is already validated against the schema\n            return completion.choices[0].message.parsed as DocstringOutput;\n          } catch (error) {\n            // If the beta API fails, try the standard chat completion as fallback\n            if (error instanceof Error && (\n                error.message.includes('500') || \n                error.message.includes('beta') ||\n                error.message.includes('parse'))) {\n              console.warn('Beta API failed, falling back to standard chat completion:', error);\n              \n              const fallbackCompletion = await client.chat.completions.create({\n                model: openaiModel,\n                messages: [\n                  { \n                    role: 'system', \n                    content: 'You are a helpful assistant that generates high-quality TypeScript docstrings. Return ONLY valid JSON matching this schema: ' + JSON.stringify(DocstringSchema.shape) \n                  },\n                  { role: 'user', content: prompt + '\\n\\nReturn ONLY valid JSON with no explanation.' }\n                ],\n                response_format: { type: \"json_object\" },\n              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }\n\n              try {\n                // Parse and validate the JSON response\n                return DocstringSchema.parse(JSON.parse(content)) as DocstringOutput;\n              } catch (parseError) {\n                console.error('Failed to parse fallback response:', parseError);\n                throw new Error('Failed to parse response: ' + String(parseError));\n              }\n            }\n            throw error;\n          }\n        },\n        retryConfig\n      );\n    } catch (error) {\n      // Check if this error occurred after exhausting retries\n      if (error instanceof Error && (error as any).retriesExhausted) {\n        console.error('All retry attempts failed in safeCompletionWithParse:', error);\n        \n        // Create enhanced error for cancellation handling\n        const enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`);\n        (enhancedError as any).shouldCancelGeneration = true;\n        throw enhancedError;\n      }\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Generates docstrings for multiple code elements in a file using OpenAI\n   * @param client - The OpenAI API client\n   * @param fileContent - The complete file content\n   * @param nodes - Information about the nodes that need docstrings\n   * @returns Object containing generated docstrings for each node\n   */\n  async generateDocstringsStructured(\n    client: OpenAI,\n    fileContent: string,\n    nodes: Array<{\n      name: string;\n      type: SymbolIndexEntry['type'];\n      location: { line: number; character: number };\n      snippet: string;\n    }>\n  ): Promise<DocstringOutput> {\n    try {\n      const prompt = `I need highly detailed and thorough JSDoc style docstrings for specific declarations in this TypeScript file. \nHere's the complete file content for context:\n\n\\`\\`\\`typescript\n${fileContent}\n\\`\\`\\`\n\nGenerate docstrings for the following declarations (identified by name, type, and line number):\n${JSON.stringify(nodes, null, 2)}\n\nFor each declaration, provide a comprehensive and detailed docstring that explains what it does, its parameters, return type, and possible errors.\nBe concise but complete. Return the docstrings as structured data.`;\n\n      // Use the retry-enabled safe completion function\n      return await this.safeCompletionWithParse(client, prompt);\n\n    } catch (error) {\n      console.error('Error generating structured docstrings:', error);\n      \n      // Show more detailed error information to help with debugging\n      if (error instanceof Error) {\n        console.error('Error details:', {\n          message: error.message,\n          name: error.name,\n          stack: error.stack,\n          shouldCancel: (error as any).shouldCancelGeneration === true\n        });\n        \n        // If the error indicates we should cancel generation, don't return fallback docstrings\n        if ((error as any).shouldCancelGeneration === true) {\n          // Provide user-friendly notification\n          vscode.window.showErrorMessage(`Docstring generation cancelled: ${error.message}`);\n          \n          // Re-throw the error to stop the process\n          throw error;\n        }\n        \n        // For server errors that are temporary, show a notification but continue with fallback\n        if ((error as any).isServerError === true) {\n          vscode.window.showWarningMessage(`OpenAI server error encountered. Using simple docstrings as fallback.`);\n        } else {\n          // For other errors, show a generic error message\n          vscode.window.showErrorMessage(`Failed to generate docstrings: ${error.message}. Using fallback docstrings.`);\n        }\n      }\n      \n      // Return empty docstrings if API call fails (but only for non-cancellation errors)\n      return {\n        docstrings: nodes.map(node => ({\n          name: node.name,\n          type: node.type,\n          line: node.location.line,\n          docstring: `/**\\n * ${node.name}\\n */`\n        }))\n      };\n    }\n  },\n\n  /**\n   * Generates a docstring for a single code element using OpenAI\n   * @param client - The OpenAI API client\n   * @param codeSnippet - The code snippet\n   * @param functionName - The name of the function\n   * @returns The generated docstring\n   */\n  async generateDocstring(\n    client: OpenAI,\n    codeSnippet: string,\n    functionName: string\n  ): Promise<string> {\n    try {\n      const result = await this.generateDocstringsStructured(client, codeSnippet, [{\n        name: functionName,\n        type: 'function', // Assume function as default type\n        location: { line: 1, character: 0 },\n        snippet: codeSnippet\n      }]);\n\n      const docstring = result.docstrings[0]?.docstring || `/**\\n * ${functionName}\\n */`;\n      return docstring;\n    } catch (error) {\n      console.error(`Error generating docstring for ${functionName}:`, error);\n      return `/**\\n * ${functionName}\\n */`;\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "envLocalPath",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 77,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "envLocalPath = path.join(workspaceFolder, '.env.local')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 78,
          "contextSnippet": "    // Try to load from .env.local in workspace root if provided\n    if (workspaceFolder) {\n      const envLocalPath = path.join(workspaceFolder, '.env.local');\n      if (fs.existsSync(envLocalPath)) {\n        const result = dotenv.config({ path: envLocalPath });\n        if (result.error) {\n          console.error('Error loading .env.local file:', result.error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 79,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "result = dotenv.config({ path: envLocalPath })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 80,
          "contextSnippet": "      const envLocalPath = path.join(workspaceFolder, '.env.local');\n      if (fs.existsSync(envLocalPath)) {\n        const result = dotenv.config({ path: envLocalPath });\n        if (result.error) {\n          console.error('Error loading .env.local file:', result.error);\n        } else {\n          console.log('.env.local loaded successfully from workspace folder');"
        }
      ],
      "depends_on": []
    },
    {
      "name": "config",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 89,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "config = vscode.workspace.getConfiguration('cursorcrawl')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 90,
          "contextSnippet": "    \n    // If no OpenAI API key is found in process.env, try to get it from VSCode settings\n    const config = vscode.workspace.getConfiguration('cursorcrawl');\n    const apiKey = process.env.OPENAI_API_KEY || config.get('openaiApiKey');\n    \n    return {\n      OPENAI_API_KEY: apiKey as string,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKey",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 90,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "apiKey = process.env.OPENAI_API_KEY || config.get('openaiApiKey')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 93,
          "contextSnippet": "    const apiKey = process.env.OPENAI_API_KEY || config.get('openaiApiKey');\n    \n    return {\n      OPENAI_API_KEY: apiKey as string,\n    };\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "lastError",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 123,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "lastError: unknown",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 135,
          "contextSnippet": "        // Execute the operation\n        return await operation();\n      } catch (error) {\n        lastError = error;\n\n        // Check if we've reached max retries\n        if (attempt >= retryConfig.maxRetries) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "delay",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 124,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "delay = retryConfig.initialDelayMs",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 129,
          "contextSnippet": "    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {\n      try {\n        if (attempt > 0 && retryConfig.verbose) {\n          console.log(`Retry attempt ${attempt}/${retryConfig.maxRetries} after ${delay}ms delay...`);\n        }\n\n        // Execute the operation"
        }
      ],
      "depends_on": []
    },
    {
      "name": "isRetryable",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 154,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "isRetryable = error instanceof Error && \n          (error.message.includes('500') || \n           error.message.includes('502') || \n           error.message.includes('503') || \n           error.message.includes('504') ||\n           error.message.includes('rate limit') ||\n           error.message.includes('timeout'))",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 162,
          "contextSnippet": "           error.message.includes('rate limit') ||\n           error.message.includes('timeout'));\n\n        if (!isRetryable) {\n          if (retryConfig.verbose) {\n            console.error('Non-retryable error encountered:', error);\n          }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "completion",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 203,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "completion = await client.beta.chat.completions.parse({\n              model: openaiModel,\n              messages: [\n                { \n                  role: 'system', \n                  content: 'You are a helpful assistant that generates high-quality TypeScript docstrings.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DocstringSchema, \"response\"),\n            })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 216,
          "contextSnippet": "            });\n\n            // Extract the parsed result which is already validated against the schema\n            return completion.choices[0].message.parsed as DocstringOutput;\n          } catch (error) {\n            // If the beta API fails, try the standard chat completion as fallback\n            if (error instanceof Error && ("
        }
      ],
      "depends_on": []
    },
    {
      "name": "fallbackCompletion",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 225,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "fallbackCompletion = await client.chat.completions.create({\n                model: openaiModel,\n                messages: [\n                  { \n                    role: 'system', \n                    content: 'You are a helpful assistant that generates high-quality TypeScript docstrings. Return ONLY valid JSON matching this schema: ' + JSON.stringify(DocstringSchema.shape) \n                  },\n                  { role: 'user', content: prompt + '\\n\\nReturn ONLY valid JSON with no explanation.' }\n                ],\n                response_format: { type: \"json_object\" },\n              })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 237,
          "contextSnippet": "                response_format: { type: \"json_object\" },\n              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 237,
        "character": 20
      },
      "docstring": "/** */",
      "snippet": "content = fallbackCompletion.choices[0].message.content",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 238,
          "contextSnippet": "              });\n\n              const content = fallbackCompletion.choices[0].message.content;\n              if (!content) {\n                throw new Error('Empty response from OpenAI API');\n              }\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "enhancedError",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 261,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 262,
          "contextSnippet": "        \n        // Create enhanced error for cancellation handling\n        const enhancedError = new Error(`Persistent OpenAI API errors after multiple retries: ${error.message}`);\n        (enhancedError as any).shouldCancelGeneration = true;\n        throw enhancedError;\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "prompt",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 288,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "prompt = `I need highly detailed and thorough JSDoc style docstrings for specific declarations in this TypeScript file. \nHere's the complete file content for context:\n\n\\`\\`\\`typescript\n${fileContent}\n\\`\\`\\`\n\nGenerate docstrings for the following declarations (identified by name, type, and line number):\n${JSON.stringify(nodes, null, 2)}\n\nFor each declaration, provide a comprehensive and detailed docstring that explains what it does, its parameters, return type, and possible errors.\nBe concise but complete. Return the docstrings as structured data.`",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 210,
          "contextSnippet": "                  role: 'system', \n                  content: 'You are a helpful assistant that generates high-quality TypeScript docstrings.' \n                },\n                { role: 'user', content: prompt }\n              ],\n              response_format: zodResponseFormat(DocstringSchema, \"response\"),\n            });"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 359,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "result = await this.generateDocstringsStructured(client, codeSnippet, [{\n        name: functionName,\n        type: 'function', // Assume function as default type\n        location: { line: 1, character: 0 },\n        snippet: codeSnippet\n      }])",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "docstring",
      "type": "variable",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 366,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "docstring = result.docstrings[0]?.docstring || `/**\\n * ${functionName}\\n */`",
      "dependents": [
        {
          "name": "DocstringOutput",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 20,
          "contextSnippet": "export interface DocstringOutput {\n  docstrings: Array<{\n    name: string;\n    docstring: string;\n    type: 'function' | 'class' | 'interface' | 'type' | 'variable' | 'method' | 'enum' | 'other';\n    line: number;\n  }>;"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 367,
          "contextSnippet": "      }]);\n\n      const docstring = result.docstrings[0]?.docstring || `/**\\n * ${functionName}\\n */`;\n      return docstring;\n    } catch (error) {\n      console.error(`Error generating docstring for ${functionName}:`, error);\n      return `/**\\n * ${functionName}\\n */`;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/openai-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "RetryConfig",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 57
        },
        {
          "name": "EnvVars",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 74
        },
        {
          "name": "envLocalPath",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 78
        },
        {
          "name": "result",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 80
        },
        {
          "name": "config",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 90
        },
        {
          "name": "apiKey",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 93
        },
        {
          "name": "DEFAULT_RETRY_CONFIG",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 121
        },
        {
          "name": "delay",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 129
        },
        {
          "name": "lastError",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 135
        },
        {
          "name": "isRetryable",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 162
        },
        {
          "name": "DocstringOutput",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 197
        },
        {
          "name": "openaiModel",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 204
        },
        {
          "name": "prompt",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 210
        },
        {
          "name": "DocstringSchema",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 212
        },
        {
          "name": "completion",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 216
        },
        {
          "name": "fallbackCompletion",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 237
        },
        {
          "name": "content",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 238
        },
        {
          "name": "enhancedError",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 262
        },
        {
          "name": "docstring",
          "filePath": "src/shared/services/openai-service.ts",
          "line": 367
        }
      ]
    }
  ],
  "src/shared/services/progress-service.ts": [
    {
      "name": "ProgressCallback",
      "type": "interface",
      "filePath": "src/shared/services/progress-service.ts",
      "location": {
        "line": 6,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface ProgressCallback<T = void> {\n  (\n    progress: vscode.Progress<{ message?: string }>,\n    token?: vscode.CancellationToken\n  ): Promise<T>;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 26,
          "contextSnippet": "   */\n  async runWithProgress<T = void>(\n    title: string,\n    callback: ProgressCallback<T>,\n    options: {\n      location?: vscode.ProgressLocation;\n      cancellable?: boolean;"
        }
      ],
      "depends_on": [
        {
          "name": "message",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 8
        }
      ]
    },
    {
      "name": "ProgressService",
      "type": "variable",
      "filePath": "src/shared/services/progress-service.ts",
      "location": {
        "line": 16,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "ProgressService = {\n  /**\n   * Runs a task with progress reporting\n   * @param title - The title of the progress report\n   * @param callback - The callback function to execute with progress\n   * @param options - Additional options for the progress\n   * @returns The result of the callback\n   */\n  async runWithProgress<T = void>(\n    title: string,\n    callback: ProgressCallback<T>,\n    options: {\n      location?: vscode.ProgressLocation;\n      cancellable?: boolean;\n    } = {}\n  ): Promise<T> {\n    const {\n      location = vscode.ProgressLocation.Notification,\n      cancellable = false\n    } = options;\n    \n    return vscode.window.withProgress(\n      {\n        location,\n        title,\n        cancellable\n      },\n      callback\n    );\n  },\n  \n  /**\n   * Creates a progress reporter function that formats messages consistently\n   * @param prefix - A prefix for all progress messages\n   * @returns A function that can be used to report progress with consistent formatting\n   */\n  createReporter(prefix: string = '') {\n    return (progress: vscode.Progress<{ message?: string }>, message: string) => {\n      progress.report({ message: prefix ? `${prefix}: ${message}` : message });\n    };\n  },\n  \n  /**\n   * Reports progress on file processing with a consistent format\n   * @param progress - The VS Code progress object\n   * @param currentFile - The current file being processed\n   * @param currentIndex - The index of the current file\n   * @param totalFiles - The total number of files\n   * @param additionalInfo - Additional information to include in the message\n   */\n  reportFileProgress(\n    progress: vscode.Progress<{ message?: string }>,\n    currentFile: string,\n    currentIndex: number,\n    totalFiles: number,\n    additionalInfo?: string\n  ): void {\n    const message = `Processing file ${currentIndex}/${totalFiles}: ${currentFile}${additionalInfo ? ` (${additionalInfo})` : ''}`;\n    progress.report({ message });\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "message",
      "type": "variable",
      "filePath": "src/shared/services/progress-service.ts",
      "location": {
        "line": 73,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "message = `Processing file ${currentIndex}/${totalFiles}: ${currentFile}${additionalInfo ? ` (${additionalInfo})` : ''}`",
      "dependents": [
        {
          "name": "ProgressCallback",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 8,
          "contextSnippet": " */\nexport interface ProgressCallback<T = void> {\n  (\n    progress: vscode.Progress<{ message?: string }>,\n    token?: vscode.CancellationToken\n  ): Promise<T>;\n}"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 53,
          "contextSnippet": "   * @returns A function that can be used to report progress with consistent formatting\n   */\n  createReporter(prefix: string = '') {\n    return (progress: vscode.Progress<{ message?: string }>, message: string) => {\n      progress.report({ message: prefix ? `${prefix}: ${message}` : message });\n    };\n  },"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/progress-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "ProgressCallback",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 26
        },
        {
          "name": "message",
          "filePath": "src/shared/services/progress-service.ts",
          "line": 53
        }
      ]
    }
  ],
  "src/shared/services/project-service.ts": [
    {
      "name": "ProjectInitResult",
      "type": "interface",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 10,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface ProjectInitResult {\n  rootPath: string;\n  cursorTestDir: string;\n  ignoredPatterns: string[];\n  openAiKey?: string;\n}",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 34,
          "contextSnippet": "    checkOpenAi?: boolean;\n    requireOpenAi?: boolean; \n    validateSymbolIndex?: boolean;\n  } = {}): Promise<ProjectInitResult> {\n    // Get the workspace folder\n    const rootPath = WorkspaceService.getWorkspaceFolder();\n    if (!rootPath) {"
        }
      ],
      "depends_on": [
        {
          "name": "rootPath",
          "filePath": "src/shared/services/project-service.ts",
          "line": 11
        },
        {
          "name": "cursorTestDir",
          "filePath": "src/shared/services/project-service.ts",
          "line": 12
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/services/project-service.ts",
          "line": 13
        }
      ]
    },
    {
      "name": "ProjectService",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 20,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "ProjectService = {\n  /**\n   * Initializes the project workspace\n   * @param options - Initialization options\n   * @returns Project initialization result\n   */\n  async initializeWorkspace({\n    checkOpenAi = false,\n    requireOpenAi = false,\n    validateSymbolIndex = false,\n  }: {\n    checkOpenAi?: boolean;\n    requireOpenAi?: boolean; \n    validateSymbolIndex?: boolean;\n  } = {}): Promise<ProjectInitResult> {\n    // Get the workspace folder\n    const rootPath = WorkspaceService.getWorkspaceFolder();\n    if (!rootPath) {\n      throw new Error('No workspace folder found. Please open a folder first.');\n    }\n\n    // Ensure the .cursortest directory exists\n    const cursorTestDir = await WorkspaceService.ensureCursorTestDir(rootPath);\n\n    // Parse .gitignore patterns\n    const ignoredPatterns = await FileSystemService.parseGitignore(rootPath);\n\n    // Initialize result object\n    const result: ProjectInitResult = {\n      rootPath,\n      cursorTestDir,\n      ignoredPatterns,\n    };\n\n    // Check for OpenAI API key if requested\n    if (checkOpenAi) {\n      const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n      result.openAiKey = envVars.OPENAI_API_KEY;\n\n      if (requireOpenAi && !result.openAiKey) {\n        // Handle missing OpenAI key\n        const setKey = await vscode.window.showErrorMessage(\n          'OpenAI API key not found. Would you like to set it now?',\n          'Yes', 'No'\n        );\n        \n        if (setKey === 'Yes') {\n          const apiKey = await vscode.window.showInputBox({\n            prompt: 'Enter your OpenAI API Key',\n            password: true,\n            ignoreFocusOut: true\n          });\n          \n          if (apiKey) {\n            await vscode.workspace.getConfiguration('cursorcrawl').update(\n              'openaiApiKey',\n              apiKey,\n              vscode.ConfigurationTarget.Global\n            );\n            result.openAiKey = apiKey;\n          } else if (requireOpenAi) {\n            throw new Error('OpenAI API key is required but was not provided');\n          }\n        } else if (requireOpenAi) {\n          throw new Error('OpenAI API key is required but was not provided');\n        }\n      }\n    }\n\n    // Validate symbol index if requested\n    if (validateSymbolIndex) {\n      const symbolIndexExists = await SymbolIndexService.symbolIndexExists(rootPath);\n      \n      if (!symbolIndexExists) {\n        const response = await vscode.window.showErrorMessage(\n          'Symbol index not found. Would you like to build the symbol index first?',\n          'Yes', 'No'\n        );\n        \n        if (response === 'Yes') {\n          // Run build symbol index first\n          await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n        } else {\n          throw new Error('Symbol index is required but does not exist');\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Generates a project tree respecting .gitignore rules\n   * @param rootPath - The workspace root path\n   * @param ignoredPatterns - Patterns to ignore\n   * @returns Tree content as a string\n   */\n  async generateProjectTree(rootPath: string, ignoredPatterns: string[]): Promise<string> {\n    try {\n      // Use git ls-files to get a list of files not ignored by gitignore\n      const { stdout } = await execAsync('git ls-files', { cwd: rootPath });\n      const files = stdout.split('\\n').filter(Boolean);\n      \n      // Build the tree structure\n      const tree = FileSystemService.buildTreeFromPaths(files);\n      return FileSystemService.formatTree(tree);\n    } catch (error) {\n      console.error('Error using git ls-files, using fallback method:', error);\n      \n      // Get all project files\n      const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n      \n      // Convert to relative paths\n      const relativePaths = projectFiles.map(file => \n        FileSystemService.normalizeFilePath(file, rootPath)\n      );\n      \n      // Build and format the tree\n      const tree = FileSystemService.buildTreeFromPaths(relativePaths);\n      return FileSystemService.formatTree(tree);\n    }\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "rootPath",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 36,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "rootPath = WorkspaceService.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "ProjectInitResult",
          "filePath": "src/shared/services/project-service.ts",
          "line": 11,
          "contextSnippet": " * Project initialization result type\n */\nexport interface ProjectInitResult {\n  rootPath: string;\n  cursorTestDir: string;\n  ignoredPatterns: string[];\n  openAiKey?: string;"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 37,
          "contextSnippet": "  } = {}): Promise<ProjectInitResult> {\n    // Get the workspace folder\n    const rootPath = WorkspaceService.getWorkspaceFolder();\n    if (!rootPath) {\n      throw new Error('No workspace folder found. Please open a folder first.');\n    }\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "cursorTestDir",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 42,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "cursorTestDir = await WorkspaceService.ensureCursorTestDir(rootPath)",
      "dependents": [
        {
          "name": "ProjectInitResult",
          "filePath": "src/shared/services/project-service.ts",
          "line": 12,
          "contextSnippet": " */\nexport interface ProjectInitResult {\n  rootPath: string;\n  cursorTestDir: string;\n  ignoredPatterns: string[];\n  openAiKey?: string;\n}"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 50,
          "contextSnippet": "    // Initialize result object\n    const result: ProjectInitResult = {\n      rootPath,\n      cursorTestDir,\n      ignoredPatterns,\n    };\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ignoredPatterns",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 45,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "ignoredPatterns = await FileSystemService.parseGitignore(rootPath)",
      "dependents": [
        {
          "name": "ProjectInitResult",
          "filePath": "src/shared/services/project-service.ts",
          "line": 13,
          "contextSnippet": "export interface ProjectInitResult {\n  rootPath: string;\n  cursorTestDir: string;\n  ignoredPatterns: string[];\n  openAiKey?: string;\n}\n"
        },
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 51,
          "contextSnippet": "    const result: ProjectInitResult = {\n      rootPath,\n      cursorTestDir,\n      ignoredPatterns,\n    };\n\n    // Check for OpenAI API key if requested"
        }
      ],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 48,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "result: ProjectInitResult = {\n      rootPath,\n      cursorTestDir,\n      ignoredPatterns,\n    }",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 57,
          "contextSnippet": "    // Check for OpenAI API key if requested\n    if (checkOpenAi) {\n      const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n      result.openAiKey = envVars.OPENAI_API_KEY;\n\n      if (requireOpenAi && !result.openAiKey) {\n        // Handle missing OpenAI key"
        }
      ],
      "depends_on": []
    },
    {
      "name": "envVars",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 56,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "envVars = OpenAiService.loadEnvironmentVars(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 57,
          "contextSnippet": "    // Check for OpenAI API key if requested\n    if (checkOpenAi) {\n      const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n      result.openAiKey = envVars.OPENAI_API_KEY;\n\n      if (requireOpenAi && !result.openAiKey) {\n        // Handle missing OpenAI key"
        }
      ],
      "depends_on": []
    },
    {
      "name": "setKey",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 61,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "setKey = await vscode.window.showErrorMessage(\n          'OpenAI API key not found. Would you like to set it now?',\n          'Yes', 'No'\n        )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 66,
          "contextSnippet": "          'Yes', 'No'\n        );\n        \n        if (setKey === 'Yes') {\n          const apiKey = await vscode.window.showInputBox({\n            prompt: 'Enter your OpenAI API Key',\n            password: true,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKey",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 67,
        "character": 16
      },
      "docstring": "/** */",
      "snippet": "apiKey = await vscode.window.showInputBox({\n            prompt: 'Enter your OpenAI API Key',\n            password: true,\n            ignoreFocusOut: true\n          })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 73,
          "contextSnippet": "            ignoreFocusOut: true\n          });\n          \n          if (apiKey) {\n            await vscode.workspace.getConfiguration('cursorcrawl').update(\n              'openaiApiKey',\n              apiKey,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndexExists",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 91,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "symbolIndexExists = await SymbolIndexService.symbolIndexExists(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 93,
          "contextSnippet": "    if (validateSymbolIndex) {\n      const symbolIndexExists = await SymbolIndexService.symbolIndexExists(rootPath);\n      \n      if (!symbolIndexExists) {\n        const response = await vscode.window.showErrorMessage(\n          'Symbol index not found. Would you like to build the symbol index first?',\n          'Yes', 'No'"
        }
      ],
      "depends_on": []
    },
    {
      "name": "response",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 94,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "response = await vscode.window.showErrorMessage(\n          'Symbol index not found. Would you like to build the symbol index first?',\n          'Yes', 'No'\n        )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 99,
          "contextSnippet": "          'Yes', 'No'\n        );\n        \n        if (response === 'Yes') {\n          // Run build symbol index first\n          await vscode.commands.executeCommand('cursorcrawl.buildSymbolIndex');\n        } else {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "files",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 121,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "files = stdout.split('\\n').filter(Boolean)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 124,
          "contextSnippet": "      const files = stdout.split('\\n').filter(Boolean);\n      \n      // Build the tree structure\n      const tree = FileSystemService.buildTreeFromPaths(files);\n      return FileSystemService.formatTree(tree);\n    } catch (error) {\n      console.error('Error using git ls-files, using fallback method:', error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "tree",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 124,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "tree = FileSystemService.buildTreeFromPaths(files)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 125,
          "contextSnippet": "      \n      // Build the tree structure\n      const tree = FileSystemService.buildTreeFromPaths(files);\n      return FileSystemService.formatTree(tree);\n    } catch (error) {\n      console.error('Error using git ls-files, using fallback method:', error);\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "projectFiles",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 130,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 133,
          "contextSnippet": "      const projectFiles = await FileSystemService.getProjectFiles(rootPath, ignoredPatterns);\n      \n      // Convert to relative paths\n      const relativePaths = projectFiles.map(file => \n        FileSystemService.normalizeFilePath(file, rootPath)\n      );\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "relativePaths",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 133,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "relativePaths = projectFiles.map(file => \n        FileSystemService.normalizeFilePath(file, rootPath)\n      )",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/project-service.ts",
          "line": 138,
          "contextSnippet": "      );\n      \n      // Build and format the tree\n      const tree = FileSystemService.buildTreeFromPaths(relativePaths);\n      return FileSystemService.formatTree(tree);\n    }\n  }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "tree",
      "type": "variable",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 138,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "tree = FileSystemService.buildTreeFromPaths(relativePaths)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/project-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "ProjectInitResult",
          "filePath": "src/shared/services/project-service.ts",
          "line": 34
        },
        {
          "name": "rootPath",
          "filePath": "src/shared/services/project-service.ts",
          "line": 37
        },
        {
          "name": "cursorTestDir",
          "filePath": "src/shared/services/project-service.ts",
          "line": 50
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/services/project-service.ts",
          "line": 51
        },
        {
          "name": "result",
          "filePath": "src/shared/services/project-service.ts",
          "line": 57
        },
        {
          "name": "envVars",
          "filePath": "src/shared/services/project-service.ts",
          "line": 57
        },
        {
          "name": "setKey",
          "filePath": "src/shared/services/project-service.ts",
          "line": 66
        },
        {
          "name": "apiKey",
          "filePath": "src/shared/services/project-service.ts",
          "line": 73
        },
        {
          "name": "symbolIndexExists",
          "filePath": "src/shared/services/project-service.ts",
          "line": 93
        },
        {
          "name": "response",
          "filePath": "src/shared/services/project-service.ts",
          "line": 99
        },
        {
          "name": "files",
          "filePath": "src/shared/services/project-service.ts",
          "line": 124
        },
        {
          "name": "tree",
          "filePath": "src/shared/services/project-service.ts",
          "line": 125
        },
        {
          "name": "projectFiles",
          "filePath": "src/shared/services/project-service.ts",
          "line": 133
        },
        {
          "name": "relativePaths",
          "filePath": "src/shared/services/project-service.ts",
          "line": 138
        }
      ]
    }
  ],
  "src/shared/services/symbol-index-service.ts": [
    {
      "name": "SYMBOL_INDEX_FILENAME",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 7,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "SYMBOL_INDEX_FILENAME = 'symbol-index.json'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 19,
          "contextSnippet": "   * @returns The path to the symbol index file\n   */\n  getSymbolIndexPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', SYMBOL_INDEX_FILENAME);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "SymbolIndexService",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 12,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "SymbolIndexService = {\n  /**\n   * Gets the path to the symbol index file\n   * @param rootPath - The workspace root path\n   * @returns The path to the symbol index file\n   */\n  getSymbolIndexPath(rootPath: string): string {\n    return path.join(rootPath, '.cursortest', SYMBOL_INDEX_FILENAME);\n  },\n\n  /**\n   * Reads the symbol index from disk\n   * @param rootPath - The workspace root path\n   * @returns The symbol index, or undefined if it doesn't exist\n   */\n  async readSymbolIndex(rootPath: string): Promise<SymbolIndex | undefined> {\n    try {\n      const indexPath = this.getSymbolIndexPath(rootPath);\n      \n      if (!await fs.pathExists(indexPath)) {\n        return undefined;\n      }\n      \n      const content = await fs.readFile(indexPath, 'utf8');\n      return JSON.parse(content) as SymbolIndex;\n    } catch (error) {\n      console.error('Error reading symbol index:', error);\n      return undefined;\n    }\n  },\n\n  /**\n   * Writes the symbol index to disk\n   * @param rootPath - The workspace root path\n   * @param symbolIndex - The symbol index to write\n   */\n  async writeSymbolIndex(rootPath: string, symbolIndex: SymbolIndex): Promise<void> {\n    try {\n      await WorkspaceService.ensureCursorTestDir(rootPath);\n      const indexPath = this.getSymbolIndexPath(rootPath);\n      await fs.writeJson(indexPath, symbolIndex, { spaces: 2 });\n      console.log(`Symbol index written to ${indexPath}`);\n    } catch (error) {\n      console.error('Error writing symbol index:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Checks if the symbol index exists\n   * @param rootPath - The workspace root path\n   * @returns Whether the symbol index exists\n   */\n  async symbolIndexExists(rootPath: string): Promise<boolean> {\n    const indexPath = this.getSymbolIndexPath(rootPath);\n    return fs.pathExists(indexPath);\n  },\n\n  /**\n   * Gets the symbol index, reading it from disk if needed\n   * Either returns the symbol index or throws an error\n   * @param rootPath - The workspace root path\n   * @param errorMessage - Optional custom error message when index doesn't exist\n   * @returns The symbol index\n   * @throws Error if the symbol index doesn't exist\n   */\n  async getSymbolIndexOrThrow(\n    rootPath: string,\n    errorMessage: string = 'Symbol index not found'\n  ): Promise<SymbolIndex> {\n    const symbolIndex = await this.readSymbolIndex(rootPath);\n    \n    if (!symbolIndex) {\n      throw new Error(errorMessage);\n    }\n    \n    return symbolIndex;\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "indexPath",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 29,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "indexPath = this.getSymbolIndexPath(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 31,
          "contextSnippet": "    try {\n      const indexPath = this.getSymbolIndexPath(rootPath);\n      \n      if (!await fs.pathExists(indexPath)) {\n        return undefined;\n      }\n      "
        }
      ],
      "depends_on": []
    },
    {
      "name": "content",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 35,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "content = await fs.readFile(indexPath, 'utf8')",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 36,
          "contextSnippet": "      }\n      \n      const content = await fs.readFile(indexPath, 'utf8');\n      return JSON.parse(content) as SymbolIndex;\n    } catch (error) {\n      console.error('Error reading symbol index:', error);\n      return undefined;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "indexPath",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 51,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "indexPath = this.getSymbolIndexPath(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "indexPath",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 66,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "indexPath = this.getSymbolIndexPath(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 82,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await this.readSymbolIndex(rootPath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 52,
          "contextSnippet": "    try {\n      await WorkspaceService.ensureCursorTestDir(rootPath);\n      const indexPath = this.getSymbolIndexPath(rootPath);\n      await fs.writeJson(indexPath, symbolIndex, { spaces: 2 });\n      console.log(`Symbol index written to ${indexPath}`);\n    } catch (error) {\n      console.error('Error writing symbol index:', error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/symbol-index-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "SYMBOL_INDEX_FILENAME",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 19
        },
        {
          "name": "indexPath",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 31
        },
        {
          "name": "content",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 36
        },
        {
          "name": "symbolIndex",
          "filePath": "src/shared/services/symbol-index-service.ts",
          "line": 52
        }
      ]
    }
  ],
  "src/shared/services/ts-analyzer-service.ts": [
    {
      "name": "TsAnalyzerService",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 6,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "TsAnalyzerService = {\n  /**\n   * Computes the line starts for a source file\n   * @param text - The source file text\n   * @returns Array of line start positions\n   */\n  computeLineStarts(text: string): number[] {\n    const result: number[] = [0];\n    for (let i = 0; i < text.length; i++) {\n      if (text[i] === '\\n') {\n        result.push(i + 1);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * Gets the line number for a given position in a source file\n   * @param sourceFile - The TypeScript source file\n   * @param position - The position in the source file\n   * @returns The line number (1-indexed)\n   */\n  getLineNumber(sourceFile: ts.SourceFile, position: number): number {\n    const lineStarts = sourceFile.getLineStarts();\n    let lineNumber = 0;\n    for (let i = 0; i < lineStarts.length; i++) {\n      if (lineStarts[i] > position) {\n        break;\n      }\n      lineNumber = i;\n    }\n    return lineNumber + 1; // Convert to 1-indexed\n  },\n\n  /**\n   * Gets the line and character for a given position in a source file\n   * @param sourceFile - The TypeScript source file\n   * @param node - The TypeScript node\n   * @returns The line and character position\n   */\n  getLineAndCharacter(\n    sourceFile: ts.SourceFile, \n    node: ts.Node\n  ): { line: number; character: number } {\n    const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    return { line: line + 1, character }; // Convert to 1-indexed\n  },\n\n  /**\n   * Creates a TypeScript program for a file\n   * @param filePath - The file path\n   * @returns The TypeScript program and source file\n   */\n  createTsProgram(\n    filePath: string\n  ): { program: ts.Program; sourceFile: ts.SourceFile } {\n    // Create a program from the file\n    const program = ts.createProgram([filePath], {\n      target: ts.ScriptTarget.ES2020,\n      module: ts.ModuleKind.ESNext,\n      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      jsx: ts.JsxEmit.React,\n      esModuleInterop: true,\n      allowJs: true,\n      checkJs: false,\n    });\n    \n    const sourceFile = program.getSourceFile(filePath);\n    if (!sourceFile) {\n      throw new Error(`Could not get source file for ${filePath}`);\n    }\n    \n    return { program, sourceFile };\n  },\n\n  /**\n   * Extracts a code snippet from a node\n   * @param sourceFile - The TypeScript source file\n   * @param node - The TypeScript node\n   * @returns The code snippet\n   */\n  extractCodeSnippet(sourceFile: ts.SourceFile, node: ts.Node): string {\n    const start = node.getStart(sourceFile);\n    const end = node.getEnd();\n    return sourceFile.text.substring(start, end);\n  },\n\n  /**\n   * Gets a context snippet around a position\n   * @param sourceFile - The TypeScript source file\n   * @param position - The position in the source file\n   * @param contextLines - The number of context lines before and after\n   * @returns The context snippet\n   */\n  getContextSnippet(\n    sourceFile: ts.SourceFile, \n    position: number, \n    contextLines: number = 3\n  ): string {\n    const lineStarts = sourceFile.getLineStarts();\n    const { line } = sourceFile.getLineAndCharacterOfPosition(position);\n    \n    const startLine = Math.max(0, line - contextLines);\n    const endLine = Math.min(lineStarts.length - 1, line + contextLines);\n    \n    const startPos = lineStarts[startLine];\n    const endPos = endLine < lineStarts.length - 1 \n      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length;\n    \n    return sourceFile.text.substring(startPos, endPos);\n  },\n\n  /**\n   * Compares two arrays to see if they have the same items\n   * @param arr1 - First array\n   * @param arr2 - Second array\n   * @returns Whether the arrays have the same items\n   */\n  arraysHaveSameItems<T>(arr1: T[], arr2: T[]): boolean {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n    \n    const set = new Set(arr1);\n    return arr2.every(item => set.has(item));\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "result",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 13,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "result: number[] = [0]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 16,
          "contextSnippet": "    const result: number[] = [0];\n    for (let i = 0; i < text.length; i++) {\n      if (text[i] === '\\n') {\n        result.push(i + 1);\n      }\n    }\n    return result;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "lineStarts",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 29,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "lineStarts = sourceFile.getLineStarts()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 31,
          "contextSnippet": "  getLineNumber(sourceFile: ts.SourceFile, position: number): number {\n    const lineStarts = sourceFile.getLineStarts();\n    let lineNumber = 0;\n    for (let i = 0; i < lineStarts.length; i++) {\n      if (lineStarts[i] > position) {\n        break;\n      }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "lineNumber",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 30,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "lineNumber = 0",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 35,
          "contextSnippet": "      if (lineStarts[i] > position) {\n        break;\n      }\n      lineNumber = i;\n    }\n    return lineNumber + 1; // Convert to 1-indexed\n  },"
        }
      ],
      "depends_on": []
    },
    {
      "name": "program",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 63,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "program = ts.createProgram([filePath], {\n      target: ts.ScriptTarget.ES2020,\n      module: ts.ModuleKind.ESNext,\n      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      jsx: ts.JsxEmit.React,\n      esModuleInterop: true,\n      allowJs: true,\n      checkJs: false,\n    })",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 61,
          "contextSnippet": "   */\n  createTsProgram(\n    filePath: string\n  ): { program: ts.Program; sourceFile: ts.SourceFile } {\n    // Create a program from the file\n    const program = ts.createProgram([filePath], {\n      target: ts.ScriptTarget.ES2020,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "sourceFile",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 73,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "sourceFile = program.getSourceFile(filePath)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 29,
          "contextSnippet": "   * @returns The line number (1-indexed)\n   */\n  getLineNumber(sourceFile: ts.SourceFile, position: number): number {\n    const lineStarts = sourceFile.getLineStarts();\n    let lineNumber = 0;\n    for (let i = 0; i < lineStarts.length; i++) {\n      if (lineStarts[i] > position) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "start",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 88,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "start = node.getStart(sourceFile)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 90,
          "contextSnippet": "  extractCodeSnippet(sourceFile: ts.SourceFile, node: ts.Node): string {\n    const start = node.getStart(sourceFile);\n    const end = node.getEnd();\n    return sourceFile.text.substring(start, end);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "end",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 89,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "end = node.getEnd()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 90,
          "contextSnippet": "  extractCodeSnippet(sourceFile: ts.SourceFile, node: ts.Node): string {\n    const start = node.getStart(sourceFile);\n    const end = node.getEnd();\n    return sourceFile.text.substring(start, end);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "lineStarts",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 105,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "lineStarts = sourceFile.getLineStarts()",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "startLine",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 108,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "startLine = Math.max(0, line - contextLines)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 111,
          "contextSnippet": "    const startLine = Math.max(0, line - contextLines);\n    const endLine = Math.min(lineStarts.length - 1, line + contextLines);\n    \n    const startPos = lineStarts[startLine];\n    const endPos = endLine < lineStarts.length - 1 \n      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "endLine",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 109,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "endLine = Math.min(lineStarts.length - 1, line + contextLines)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 112,
          "contextSnippet": "    const endLine = Math.min(lineStarts.length - 1, line + contextLines);\n    \n    const startPos = lineStarts[startLine];\n    const endPos = endLine < lineStarts.length - 1 \n      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length;\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "startPos",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 111,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "startPos = lineStarts[startLine]",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 116,
          "contextSnippet": "      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length;\n    \n    return sourceFile.text.substring(startPos, endPos);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "endPos",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 112,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "endPos = endLine < lineStarts.length - 1 \n      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 116,
          "contextSnippet": "      ? lineStarts[endLine + 1] - 1 // Exclude newline\n      : sourceFile.text.length;\n    \n    return sourceFile.text.substring(startPos, endPos);\n  },\n\n  /**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "set",
      "type": "variable",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 130,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "set = new Set(arr1)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 131,
          "contextSnippet": "    }\n    \n    const set = new Set(arr1);\n    return arr2.every(item => set.has(item));\n  }\n}; "
        }
      ],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/ts-analyzer-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "result",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 16
        },
        {
          "name": "sourceFile",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 29
        },
        {
          "name": "lineStarts",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 31
        },
        {
          "name": "lineNumber",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 35
        },
        {
          "name": "program",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 61
        },
        {
          "name": "start",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 90
        },
        {
          "name": "end",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 90
        },
        {
          "name": "startLine",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 111
        },
        {
          "name": "endLine",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 112
        },
        {
          "name": "startPos",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 116
        },
        {
          "name": "endPos",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 116
        },
        {
          "name": "set",
          "filePath": "src/shared/services/ts-analyzer-service.ts",
          "line": 131
        }
      ]
    }
  ],
  "src/shared/types/progress-reporter.ts": [
    {
      "name": "ProgressReporter",
      "type": "interface",
      "filePath": "src/shared/types/progress-reporter.ts",
      "location": {
        "line": 6,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface ProgressReporter {\n  /**\n   * Reports progress with a message\n   * @param info - The progress information to report\n   */\n  report: (info: { message: string }) => void;\n  \n  /**\n   * Checks if the operation has been cancelled\n   * @returns True if the operation has been cancelled, false otherwise\n   */\n  isCancelled?: () => boolean;\n}",
      "dependents": [
        {
          "name": "createNullProgressReporter",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 29,
          "contextSnippet": " * Creates a null progress reporter that does nothing\n * @returns A progress reporter that does nothing\n */\nexport const createNullProgressReporter = (): ProgressReporter => ({\n  report: () => {},\n  isCancelled: () => false\n});"
        },
        {
          "name": "adaptVSCodeProgress",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 43,
          "contextSnippet": "export const adaptVSCodeProgress = (\n  vscodeProgress: VSCodeProgressReporter, \n  token?: vscode.CancellationToken\n): ProgressReporter => ({\n  report: (info: { message: string }) => vscodeProgress.report({ message: info.message }),\n  isCancelled: token ? () => token.isCancellationRequested : undefined\n}); "
        }
      ],
      "depends_on": []
    },
    {
      "name": "VSCodeProgressReporter",
      "type": "type",
      "filePath": "src/shared/types/progress-reporter.ts",
      "location": {
        "line": 23,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export type VSCodeProgressReporter = vscode.Progress<{ message?: string }>;",
      "dependents": [
        {
          "name": "adaptVSCodeProgress",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 41,
          "contextSnippet": " * @returns A progress reporter that forwards to the VSCode progress reporter\n */\nexport const adaptVSCodeProgress = (\n  vscodeProgress: VSCodeProgressReporter, \n  token?: vscode.CancellationToken\n): ProgressReporter => ({\n  report: (info: { message: string }) => vscodeProgress.report({ message: info.message }),"
        }
      ],
      "depends_on": []
    },
    {
      "name": "createNullProgressReporter",
      "type": "variable",
      "filePath": "src/shared/types/progress-reporter.ts",
      "location": {
        "line": 29,
        "character": 13
      },
      "docstring": "/**\n * Creates a null progress reporter that does nothing\n * @returns A progress reporter that does nothing\n */",
      "snippet": "createNullProgressReporter = (): ProgressReporter => ({\n  report: () => {},\n  isCancelled: () => false\n})",
      "dependents": [],
      "depends_on": [
        {
          "name": "ProgressReporter",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 29
        }
      ]
    },
    {
      "name": "adaptVSCodeProgress",
      "type": "variable",
      "filePath": "src/shared/types/progress-reporter.ts",
      "location": {
        "line": 40,
        "character": 13
      },
      "docstring": "/**\n * Adapts a VSCode progress reporter to match the ProgressReporter interface\n * @param vscodeProgress - The VSCode progress reporter to adapt\n * @param token - Optional cancellation token for the operation\n * @returns A progress reporter that forwards to the VSCode progress reporter\n */",
      "snippet": "adaptVSCodeProgress = (\n  vscodeProgress: VSCodeProgressReporter, \n  token?: vscode.CancellationToken\n): ProgressReporter => ({\n  report: (info: { message: string }) => vscodeProgress.report({ message: info.message }),\n  isCancelled: token ? () => token.isCancellationRequested : undefined\n})",
      "dependents": [],
      "depends_on": [
        {
          "name": "VSCodeProgressReporter",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 41
        },
        {
          "name": "ProgressReporter",
          "filePath": "src/shared/types/progress-reporter.ts",
          "line": 43
        }
      ]
    }
  ],
  "src/shared/types/relevant-info.ts": [
    {
      "name": "RelevantInfo",
      "type": "interface",
      "filePath": "src/shared/types/relevant-info.ts",
      "location": {
        "line": 4,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface RelevantInfo {\n  /**\n   * Map of file paths to their content and symbols\n   */\n  files: Record<string, FileContentInfo>;\n  \n  /**\n   * The dependency graph information for all context files\n   */\n  dependencyGraph: Record<string, FileImportInfo>;\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "FileContentInfo",
          "filePath": "src/shared/types/relevant-info.ts",
          "line": 8
        },
        {
          "name": "FileImportInfo",
          "filePath": "src/shared/types/relevant-info.ts",
          "line": 13
        }
      ]
    },
    {
      "name": "FileImportInfo",
      "type": "interface",
      "filePath": "src/shared/types/relevant-info.ts",
      "location": {
        "line": 22,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface FileImportInfo {\n  /**\n   * Files that this file imports from (forward dependencies)\n   */\n  imports: { from: string; imports: string[] }[];\n  \n  /**\n   * Files that import this file (reverse dependencies)\n   */\n  importedBy: { from: string; imports: string[] }[];\n}",
      "dependents": [
        {
          "name": "RelevantInfo",
          "filePath": "src/shared/types/relevant-info.ts",
          "line": 13,
          "contextSnippet": "  /**\n   * The dependency graph information for all context files\n   */\n  dependencyGraph: Record<string, FileImportInfo>;\n}\n\n// Import types from symbol-index.ts"
        }
      ],
      "depends_on": []
    },
    {
      "name": "FileContentInfo",
      "type": "interface",
      "filePath": "src/shared/types/relevant-info.ts",
      "location": {
        "line": 37,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface FileContentInfo {\n  /**\n   * The content of the file with context\n   */\n  content: string;\n  \n  /**\n   * The symbols defined in the file\n   */\n  symbols: SymbolIndexEntry[];\n}",
      "dependents": [
        {
          "name": "RelevantInfo",
          "filePath": "src/shared/types/relevant-info.ts",
          "line": 8,
          "contextSnippet": "  /**\n   * Map of file paths to their content and symbols\n   */\n  files: Record<string, FileContentInfo>;\n  \n  /**\n   * The dependency graph information for all context files"
        }
      ],
      "depends_on": []
    }
  ],
  "src/shared/types/symbol-index-with-scores.ts": [
    {
      "name": "ScoreInfo",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index-with-scores.ts",
      "location": {
        "line": 6,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface ScoreInfo {\n  /**\n   * Type of the score (e.g., \"duplicateAnalysis\")\n   */\n  type: string;\n  \n  /**\n   * Score value\n   */\n  score: number;\n}",
      "dependents": [
        {
          "name": "SymbolIndexEntryWithScores",
          "filePath": "src/shared/types/symbol-index-with-scores.ts",
          "line": 25,
          "contextSnippet": "  /**\n   * Array of scores associated with this symbol\n   */\n  scores: ScoreInfo[];\n}\n\n/**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "SymbolIndexEntryWithScores",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index-with-scores.ts",
      "location": {
        "line": 21,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface SymbolIndexEntryWithScores extends SymbolIndexEntry {\n  /**\n   * Array of scores associated with this symbol\n   */\n  scores: ScoreInfo[];\n}",
      "dependents": [
        {
          "name": "SymbolIndexWithScores",
          "filePath": "src/shared/types/symbol-index-with-scores.ts",
          "line": 36,
          "contextSnippet": "  /**\n   * Map of file paths to arrays of symbol entries with scores\n   */\n  [filePath: string]: SymbolIndexEntryWithScores[];\n} "
        }
      ],
      "depends_on": [
        {
          "name": "ScoreInfo",
          "filePath": "src/shared/types/symbol-index-with-scores.ts",
          "line": 25
        }
      ]
    },
    {
      "name": "SymbolIndexWithScores",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index-with-scores.ts",
      "location": {
        "line": 32,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface SymbolIndexWithScores {\n  /**\n   * Map of file paths to arrays of symbol entries with scores\n   */\n  [filePath: string]: SymbolIndexEntryWithScores[];\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "SymbolIndexEntryWithScores",
          "filePath": "src/shared/types/symbol-index-with-scores.ts",
          "line": 36
        }
      ]
    }
  ],
  "src/shared/types/symbol-index.ts": [
    {
      "name": "SymbolIndexEntry",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index.ts",
      "location": {
        "line": 8,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface SymbolIndexEntry {\n  /**\n   * Name of the symbol\n   */\n  name: string;\n\n  /**\n   * Type of the symbol\n   */\n  type: 'function' | 'class' | 'interface' | 'type' | 'variable' | 'method' | 'enum' | 'other';\n\n  /**\n   * Path to the file containing the symbol\n   */\n  filePath: string;\n\n  /**\n   * Location of the symbol in the file\n   */\n  location: { \n    line: number; \n    character: number; \n  };\n\n  /**\n   * Generated docstring for the symbol\n   */\n  docstring: string;\n\n  /**\n   * Original code snippet\n   */\n  snippet: string;\n\n  /**\n   * Symbols that depend on this symbol\n   */\n  dependents: DependentInfo[];\n\n  /**\n   * Symbols that this symbol depends on\n   */\n  depends_on: DependencyInfo[];\n}",
      "dependents": [
        {
          "name": "SymbolIndex",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 106,
          "contextSnippet": "  /**\n   * Map of file paths to arrays of symbol entries\n   */\n  [filePath: string]: SymbolIndexEntry[];\n} "
        }
      ],
      "depends_on": [
        {
          "name": "DependentInfo",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 45
        },
        {
          "name": "DependencyInfo",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 50
        }
      ]
    },
    {
      "name": "DependentInfo",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index.ts",
      "location": {
        "line": 56,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DependentInfo {\n  /**\n   * Name of the dependent symbol\n   */\n  name: string;\n\n  /**\n   * Path to the file containing the dependent symbol\n   */\n  filePath: string;\n\n  /**\n   * Line number where the dependency occurs\n   */\n  line: number;\n\n  /**\n   * Code context around the dependency\n   */\n  contextSnippet?: string;\n}",
      "dependents": [
        {
          "name": "SymbolIndexEntry",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 45,
          "contextSnippet": "  /**\n   * Symbols that depend on this symbol\n   */\n  dependents: DependentInfo[];\n\n  /**\n   * Symbols that this symbol depends on"
        }
      ],
      "depends_on": []
    },
    {
      "name": "DependencyInfo",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index.ts",
      "location": {
        "line": 81,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface DependencyInfo {\n  /**\n   * Name of the symbol being depended on\n   */\n  name: string;\n\n  /**\n   * Path to the file containing the symbol being depended on\n   */\n  filePath: string;\n\n  /**\n   * Line number where the dependency occurs\n   */\n  line: number;\n}",
      "dependents": [
        {
          "name": "SymbolIndexEntry",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 50,
          "contextSnippet": "  /**\n   * Symbols that this symbol depends on\n   */\n  depends_on: DependencyInfo[];\n}\n\n/**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "SymbolIndex",
      "type": "interface",
      "filePath": "src/shared/types/symbol-index.ts",
      "location": {
        "line": 102,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface SymbolIndex {\n  /**\n   * Map of file paths to arrays of symbol entries\n   */\n  [filePath: string]: SymbolIndexEntry[];\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "SymbolIndexEntry",
          "filePath": "src/shared/types/symbol-index.ts",
          "line": 106
        }
      ]
    }
  ],
  "src/shared/utils/project-analysis.ts": [
    {
      "name": "ProjectAnalysisOptions",
      "type": "interface",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 14,
        "character": 0
      },
      "docstring": "/** */",
      "snippet": "export interface ProjectAnalysisOptions {\n    generateDocstrings?: boolean;\n    showMessages?: boolean;\n    progress?: vscode.Progress<{ message: string }>;\n    incremental?: boolean;\n    changedFile?: string;\n    symbolIndexCache?: SymbolIndex;\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 197,
          "contextSnippet": " */\nexport async function ensureProjectAnalysis(\n    rootPath: string,\n    options: ProjectAnalysisOptions = {}\n): Promise<{ success: boolean; symbolIndex: SymbolIndex | null }> {\n    const { \n        generateDocstrings: shouldGenerateDocstrings = false, "
        }
      ],
      "depends_on": [
        {
          "name": "generateDocstrings",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 15
        }
      ]
    },
    {
      "name": "ensureProjectSetup",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 28,
        "character": 0
      },
      "docstring": "/**\n * Ensures the .cursortest directory exists and setup is complete\n * @param rootPath - The workspace root path\n * @returns Whether the operation was successful\n */",
      "snippet": "export async function ensureProjectSetup(rootPath: string): Promise<boolean> {\n    try {\n        await WorkspaceService.ensureCursorCrawlDir(rootPath);\n        return true;\n    } catch (error) {\n        console.error('Error setting up project directory:', error);\n        return false;\n    }\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 210,
          "contextSnippet": "    \n    try {\n        // Step 1: Setup project directory\n        const setupSuccess = await ensureProjectSetup(rootPath);\n        if (!setupSuccess) {throw new Error('Failed to setup project directory');}\n        \n        // Step 2: Get ignored patterns"
        }
      ],
      "depends_on": []
    },
    {
      "name": "getIgnoredPatterns",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 43,
        "character": 0
      },
      "docstring": "/**\n * Gets the ignored patterns from .gitignore\n * @param rootPath - The workspace root path\n * @returns List of ignored patterns\n */",
      "snippet": "export async function getIgnoredPatterns(rootPath: string): Promise<string[]> {\n    return await FileSystemService.parseGitignore(rootPath);\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 214,
          "contextSnippet": "        if (!setupSuccess) {throw new Error('Failed to setup project directory');}\n        \n        // Step 2: Get ignored patterns\n        const ignoredPatterns = await getIgnoredPatterns(rootPath);\n        \n        // Step 3: Generate project tree\n        await generateProjectTreeFile(rootPath, ignoredPatterns, progress);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateProjectTreeFile",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 54,
        "character": 0
      },
      "docstring": "/**\n * Generates and saves the project tree\n * @param rootPath - The workspace root path\n * @param ignoredPatterns - Patterns to ignore\n * @param progress - Optional progress reporter\n * @returns Whether the operation was successful\n */",
      "snippet": "export async function generateProjectTreeFile(\n    rootPath: string,\n    ignoredPatterns: string[],\n    progress?: vscode.Progress<{ message: string }>\n): Promise<boolean> {\n    try {\n        progress?.report({ message: 'Generating project tree...' });\n        const treeContent = await ProjectService.generateProjectTree(rootPath, ignoredPatterns);\n        await WorkspaceService.writeCursorCrawlFile(rootPath, 'project-tree.mdc', `# Project Tree\\n\\n\\`\\`\\`\\n${treeContent}\\`\\`\\`\\n`);\n        return true;\n    } catch (error) {\n        console.error('Error generating project tree:', error);\n        return false;\n    }\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 217,
          "contextSnippet": "        const ignoredPatterns = await getIgnoredPatterns(rootPath);\n        \n        // Step 3: Generate project tree\n        await generateProjectTreeFile(rootPath, ignoredPatterns, progress);\n        \n        // Step 4: Build symbol index\n        const symbolIndex = await buildSymbolIndex(rootPath, ignoredPatterns, {"
        }
      ],
      "depends_on": [
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 61
        },
        {
          "name": "treeContent",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 62
        }
      ]
    },
    {
      "name": "treeContent",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 61,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "treeContent = await ProjectService.generateProjectTree(rootPath, ignoredPatterns)",
      "dependents": [
        {
          "name": "generateProjectTreeFile",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 62,
          "contextSnippet": "    try {\n        progress?.report({ message: 'Generating project tree...' });\n        const treeContent = await ProjectService.generateProjectTree(rootPath, ignoredPatterns);\n        await WorkspaceService.writeCursorCrawlFile(rootPath, 'project-tree.mdc', `# Project Tree\\n\\n\\`\\`\\`\\n${treeContent}\\`\\`\\`\\n`);\n        return true;\n    } catch (error) {\n        console.error('Error generating project tree:', error);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "buildSymbolIndex",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 77,
        "character": 0
      },
      "docstring": "/**\n * Builds or updates the symbol index\n * @param rootPath - The workspace root path\n * @param ignoredPatterns - Patterns to ignore\n * @param options - Symbol index options\n * @returns The generated/updated symbol index\n */",
      "snippet": "export async function buildSymbolIndex(\n    rootPath: string,\n    ignoredPatterns: string[],\n    options: {\n        progress?: vscode.Progress<{ message: string }>;\n        incremental?: boolean;\n        changedFile?: string;\n        symbolIndexCache?: SymbolIndex;\n    } = {}\n): Promise<SymbolIndex | null> {\n    try {\n        const { progress, incremental = false, changedFile, symbolIndexCache } = options;\n        \n        progress?.report({ message: 'Building symbol index...' });\n        \n        if (incremental && symbolIndexCache && changedFile) {\n            return await SymbolIndexOrchestrator.updateSymbolIndex(\n                rootPath,\n                symbolIndexCache,\n                changedFile,\n                ignoredPatterns\n            );\n        } else {\n            return await SymbolIndexOrchestrator.createSymbolIndex(rootPath, ignoredPatterns, progress);\n        }\n    } catch (error) {\n        console.error('Error building symbol index:', error);\n        return null;\n    }\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 220,
          "contextSnippet": "        await generateProjectTreeFile(rootPath, ignoredPatterns, progress);\n        \n        // Step 4: Build symbol index\n        const symbolIndex = await buildSymbolIndex(rootPath, ignoredPatterns, {\n            progress,\n            incremental,\n            changedFile,"
        }
      ],
      "depends_on": [
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 97
        }
      ]
    },
    {
      "name": "ensureOpenAIApiKey",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 114,
        "character": 0
      },
      "docstring": "/**\n * Checks for and handles OpenAI API key requirement for docstring generation\n * @param rootPath - The workspace root path\n * @param showMessages - Whether to show UI messages\n * @returns Whether the API key is available\n */",
      "snippet": "export async function ensureOpenAIApiKey(\n    rootPath: string,\n    showMessages: boolean\n): Promise<boolean> {\n    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    if (envVars.OPENAI_API_KEY) {\n        return true;\n    }\n    \n    if (showMessages) {\n        const setKey = await vscode.window.showErrorMessage(\n            'OpenAI API key not found. Would you like to set it now?',\n            'Yes', 'No'\n        );\n        \n        if (setKey === 'Yes') {\n            const apiKey = await vscode.window.showInputBox({\n                prompt: 'Enter your OpenAI API Key',\n                password: true,\n                ignoreFocusOut: true\n            });\n            \n            if (apiKey) {\n                await vscode.workspace.getConfiguration('cursorcrawl').update('openaiApiKey', apiKey, vscode.ConfigurationTarget.Global);\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 232,
          "contextSnippet": "        // Step 5: Optionally generate docstrings\n        let docsGenerated = false;\n        if (shouldGenerateDocstrings) {\n            const apiKeyAvailable = await ensureOpenAIApiKey(rootPath, showMessages);\n            \n            if (apiKeyAvailable) {\n                docsGenerated = await generateDocstrings(rootPath, ignoredPatterns, progress);"
        }
      ],
      "depends_on": [
        {
          "name": "envVars",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 120
        },
        {
          "name": "setKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 130
        },
        {
          "name": "apiKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 137
        }
      ]
    },
    {
      "name": "envVars",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 118,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "envVars = OpenAiService.loadEnvironmentVars(rootPath)",
      "dependents": [
        {
          "name": "ensureOpenAIApiKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 120,
          "contextSnippet": "): Promise<boolean> {\n    const envVars = OpenAiService.loadEnvironmentVars(rootPath);\n    \n    if (envVars.OPENAI_API_KEY) {\n        return true;\n    }\n    "
        }
      ],
      "depends_on": []
    },
    {
      "name": "setKey",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 125,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "setKey = await vscode.window.showErrorMessage(\n            'OpenAI API key not found. Would you like to set it now?',\n            'Yes', 'No'\n        )",
      "dependents": [
        {
          "name": "ensureOpenAIApiKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 130,
          "contextSnippet": "            'Yes', 'No'\n        );\n        \n        if (setKey === 'Yes') {\n            const apiKey = await vscode.window.showInputBox({\n                prompt: 'Enter your OpenAI API Key',\n                password: true,"
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKey",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 131,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "apiKey = await vscode.window.showInputBox({\n                prompt: 'Enter your OpenAI API Key',\n                password: true,\n                ignoreFocusOut: true\n            })",
      "dependents": [
        {
          "name": "ensureOpenAIApiKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 137,
          "contextSnippet": "                ignoreFocusOut: true\n            });\n            \n            if (apiKey) {\n                await vscode.workspace.getConfiguration('cursorcrawl').update('openaiApiKey', apiKey, vscode.ConfigurationTarget.Global);\n                return true;\n            }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "generateDocstrings",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 155,
        "character": 0
      },
      "docstring": "/**\n * Generates docstrings for symbols in the index\n * @param rootPath - Path to the project root\n * @param ignoredPatterns - Patterns to ignore\n * @param progress - Optional progress reporter\n * @param token - Optional cancellation token\n * @returns Whether the operation was successful\n */",
      "snippet": "export async function generateDocstrings(\n    rootPath: string,\n    ignoredPatterns: string[],\n    progress?: vscode.Progress<{ message: string }>,\n    token?: vscode.CancellationToken\n): Promise<boolean> {\n    try {\n        progress?.report({ message: 'Generating docstrings...' });\n        await generateDocstringIndex(rootPath, ignoredPatterns, progress, token);\n        return true;\n    } catch (error) {\n        console.error('Error generating docstrings:', error);\n        return false;\n    }\n}",
      "dependents": [
        {
          "name": "ProjectAnalysisOptions",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 15,
          "contextSnippet": " * Type definition for project analysis options\n */\nexport interface ProjectAnalysisOptions {\n    generateDocstrings?: boolean;\n    showMessages?: boolean;\n    progress?: vscode.Progress<{ message: string }>;\n    incremental?: boolean;"
        },
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 200,
          "contextSnippet": "    options: ProjectAnalysisOptions = {}\n): Promise<{ success: boolean; symbolIndex: SymbolIndex | null }> {\n    const { \n        generateDocstrings: shouldGenerateDocstrings = false, \n        showMessages = true, \n        progress,\n        incremental = false,"
        }
      ],
      "depends_on": [
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 163
        }
      ]
    },
    {
      "name": "showAnalysisMessages",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 176,
        "character": 0
      },
      "docstring": "/**\n * Shows appropriate messages based on analysis results\n * @param showMessages - Whether to show messages\n * @param withDocstrings - Whether docstrings were generated\n */",
      "snippet": "export function showAnalysisMessages(\n    showMessages: boolean,\n    withDocstrings: boolean\n): void {\n    if (!showMessages) {return;}\n    \n    if (withDocstrings) {\n        showInformationMessage('Project analysis completed successfully with docstrings!');\n    } else {\n        showInformationMessage('Project analysis completed successfully (without docstrings).');\n    }\n}",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 240,
          "contextSnippet": "        }\n        \n        // Step 6: Show appropriate messages\n        showAnalysisMessages(showMessages, docsGenerated);\n        \n        return { success: true, symbolIndex };\n    } catch (error) {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ensureProjectAnalysis",
      "type": "function",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 195,
        "character": 0
      },
      "docstring": "/**\n * Ensures project analysis artifacts are generated and up-to-date\n * @param rootPath - The workspace root path\n * @param options - Optional configuration\n * @returns Whether the operation was successful and the symbol index if available\n */",
      "snippet": "export async function ensureProjectAnalysis(\n    rootPath: string,\n    options: ProjectAnalysisOptions = {}\n): Promise<{ success: boolean; symbolIndex: SymbolIndex | null }> {\n    const { \n        generateDocstrings: shouldGenerateDocstrings = false, \n        showMessages = true, \n        progress,\n        incremental = false,\n        changedFile,\n        symbolIndexCache\n    } = options;\n    \n    try {\n        // Step 1: Setup project directory\n        const setupSuccess = await ensureProjectSetup(rootPath);\n        if (!setupSuccess) {throw new Error('Failed to setup project directory');}\n        \n        // Step 2: Get ignored patterns\n        const ignoredPatterns = await getIgnoredPatterns(rootPath);\n        \n        // Step 3: Generate project tree\n        await generateProjectTreeFile(rootPath, ignoredPatterns, progress);\n        \n        // Step 4: Build symbol index\n        const symbolIndex = await buildSymbolIndex(rootPath, ignoredPatterns, {\n            progress,\n            incremental,\n            changedFile,\n            symbolIndexCache\n        });\n        \n        if (!symbolIndex) {throw new Error('Failed to build symbol index');}\n        \n        // Step 5: Optionally generate docstrings\n        let docsGenerated = false;\n        if (shouldGenerateDocstrings) {\n            const apiKeyAvailable = await ensureOpenAIApiKey(rootPath, showMessages);\n            \n            if (apiKeyAvailable) {\n                docsGenerated = await generateDocstrings(rootPath, ignoredPatterns, progress);\n            }\n        }\n        \n        // Step 6: Show appropriate messages\n        showAnalysisMessages(showMessages, docsGenerated);\n        \n        return { success: true, symbolIndex };\n    } catch (error) {\n        console.error('Error in project analysis:', error);\n        if (showMessages) {\n            showErrorMessage('Error generating project analysis', error);\n        }\n        return { success: false, symbolIndex: null };\n    }\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "ProjectAnalysisOptions",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 197
        },
        {
          "name": "symbolIndex",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 198
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 200
        },
        {
          "name": "ensureProjectSetup",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 210
        },
        {
          "name": "setupSuccess",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 211
        },
        {
          "name": "getIgnoredPatterns",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 214
        },
        {
          "name": "generateProjectTreeFile",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 217
        },
        {
          "name": "ignoredPatterns",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 217
        },
        {
          "name": "buildSymbolIndex",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 220
        },
        {
          "name": "ensureOpenAIApiKey",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 232
        },
        {
          "name": "apiKeyAvailable",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 234
        },
        {
          "name": "docsGenerated",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 235
        },
        {
          "name": "showAnalysisMessages",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 240
        }
      ]
    },
    {
      "name": "setupSuccess",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 210,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "setupSuccess = await ensureProjectSetup(rootPath)",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 211,
          "contextSnippet": "    try {\n        // Step 1: Setup project directory\n        const setupSuccess = await ensureProjectSetup(rootPath);\n        if (!setupSuccess) {throw new Error('Failed to setup project directory');}\n        \n        // Step 2: Get ignored patterns\n        const ignoredPatterns = await getIgnoredPatterns(rootPath);"
        }
      ],
      "depends_on": []
    },
    {
      "name": "ignoredPatterns",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 214,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "ignoredPatterns = await getIgnoredPatterns(rootPath)",
      "dependents": [
        {
          "name": "generateProjectTreeFile",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 61,
          "contextSnippet": "): Promise<boolean> {\n    try {\n        progress?.report({ message: 'Generating project tree...' });\n        const treeContent = await ProjectService.generateProjectTree(rootPath, ignoredPatterns);\n        await WorkspaceService.writeCursorCrawlFile(rootPath, 'project-tree.mdc', `# Project Tree\\n\\n\\`\\`\\`\\n${treeContent}\\`\\`\\`\\n`);\n        return true;\n    } catch (error) {"
        },
        {
          "name": "buildSymbolIndex",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 97,
          "contextSnippet": "                rootPath,\n                symbolIndexCache,\n                changedFile,\n                ignoredPatterns\n            );\n        } else {\n            return await SymbolIndexOrchestrator.createSymbolIndex(rootPath, ignoredPatterns, progress);"
        },
        {
          "name": "generateDocstrings",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 163,
          "contextSnippet": "): Promise<boolean> {\n    try {\n        progress?.report({ message: 'Generating docstrings...' });\n        await generateDocstringIndex(rootPath, ignoredPatterns, progress, token);\n        return true;\n    } catch (error) {\n        console.error('Error generating docstrings:', error);"
        },
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 217,
          "contextSnippet": "        const ignoredPatterns = await getIgnoredPatterns(rootPath);\n        \n        // Step 3: Generate project tree\n        await generateProjectTreeFile(rootPath, ignoredPatterns, progress);\n        \n        // Step 4: Build symbol index\n        const symbolIndex = await buildSymbolIndex(rootPath, ignoredPatterns, {"
        }
      ],
      "depends_on": []
    },
    {
      "name": "symbolIndex",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 220,
        "character": 14
      },
      "docstring": "/** */",
      "snippet": "symbolIndex = await buildSymbolIndex(rootPath, ignoredPatterns, {\n            progress,\n            incremental,\n            changedFile,\n            symbolIndexCache\n        })",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 198,
          "contextSnippet": "export async function ensureProjectAnalysis(\n    rootPath: string,\n    options: ProjectAnalysisOptions = {}\n): Promise<{ success: boolean; symbolIndex: SymbolIndex | null }> {\n    const { \n        generateDocstrings: shouldGenerateDocstrings = false, \n        showMessages = true, "
        }
      ],
      "depends_on": []
    },
    {
      "name": "docsGenerated",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 230,
        "character": 12
      },
      "docstring": "/** */",
      "snippet": "docsGenerated = false",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 235,
          "contextSnippet": "            const apiKeyAvailable = await ensureOpenAIApiKey(rootPath, showMessages);\n            \n            if (apiKeyAvailable) {\n                docsGenerated = await generateDocstrings(rootPath, ignoredPatterns, progress);\n            }\n        }\n        "
        }
      ],
      "depends_on": []
    },
    {
      "name": "apiKeyAvailable",
      "type": "variable",
      "filePath": "src/shared/utils/project-analysis.ts",
      "location": {
        "line": 232,
        "character": 18
      },
      "docstring": "/** */",
      "snippet": "apiKeyAvailable = await ensureOpenAIApiKey(rootPath, showMessages)",
      "dependents": [
        {
          "name": "ensureProjectAnalysis",
          "filePath": "src/shared/utils/project-analysis.ts",
          "line": 234,
          "contextSnippet": "        if (shouldGenerateDocstrings) {\n            const apiKeyAvailable = await ensureOpenAIApiKey(rootPath, showMessages);\n            \n            if (apiKeyAvailable) {\n                docsGenerated = await generateDocstrings(rootPath, ignoredPatterns, progress);\n            }\n        }"
        }
      ],
      "depends_on": []
    }
  ],
  "src/shared/services/workspace-service.ts": [
    {
      "name": "CURSOR_TEST_DIR",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 6,
        "character": 6
      },
      "docstring": "/** */",
      "snippet": "CURSOR_TEST_DIR = '.cursorcrawl'",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 43,
          "contextSnippet": "   * @returns The path to the .cursorcrawl directory\n   */\n  async ensureCursorCrawlDir(rootPath: string): Promise<string> {\n    const cursorCrawlDir = path.join(rootPath, CURSOR_TEST_DIR);\n    await fs.ensureDir(cursorCrawlDir);\n    return cursorCrawlDir;\n  },"
        }
      ],
      "depends_on": []
    },
    {
      "name": "WorkspaceService",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 11,
        "character": 13
      },
      "docstring": "/** */",
      "snippet": "WorkspaceService = {\n  /**\n   * Gets the current workspace folder\n   * @returns The workspace folder path or undefined if no workspace is open\n   */\n  getWorkspaceFolder(): string | undefined {\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders || workspaceFolders.length === 0) {\n      return undefined;\n    }\n    return workspaceFolders[0].uri.fsPath;\n  },\n\n  /**\n   * Gets the current workspace folder or throws an error if none is open\n   * @returns The workspace folder path\n   * @throws Error if no workspace folder is open\n   */\n  getWorkspaceFolderOrThrow(): string {\n    const workspaceFolder = this.getWorkspaceFolder();\n    if (!workspaceFolder) {\n      throw new Error('No workspace folder open');\n    }\n    return workspaceFolder;\n  },\n\n  /**\n   * Ensures the .cursorcrawl directory exists in the workspace\n   * @param rootPath - The workspace root path\n   * @returns The path to the .cursorcrawl directory\n   */\n  async ensureCursorCrawlDir(rootPath: string): Promise<string> {\n    const cursorCrawlDir = path.join(rootPath, CURSOR_TEST_DIR);\n    await fs.ensureDir(cursorCrawlDir);\n    return cursorCrawlDir;\n  },\n\n  /**\n   * Gets the path to the .cursorcrawl directory\n   * @param rootPath - The workspace root path\n   * @returns The path to the .cursorcrawl directory\n   */\n  getCursorCrawlDir(rootPath: string): string {\n    return path.join(rootPath, CURSOR_TEST_DIR);\n  },\n\n  /**\n   * Writes data to a file in the .cursorcrawl directory\n   * @param rootPath - The workspace root path\n   * @param filename - The name of the file to write\n   * @param data - The data to write\n   * @returns The path to the written file\n   */\n  async writeCursorCrawlFile(\n    rootPath: string,\n    filename: string,\n    data: any\n  ): Promise<string> {\n    const cursorCrawlDir = await this.ensureCursorCrawlDir(rootPath);\n    const filePath = path.join(cursorCrawlDir, filename);\n    \n    if (typeof data === 'string') {\n      await fs.writeFile(filePath, data, 'utf8');\n    } else {\n      await fs.writeJson(filePath, data, { spaces: 2 });\n    }\n    \n    return filePath;\n  },\n\n  /**\n   * Reads data from a file in the .cursorcrawl directory\n   * @param rootPath - The workspace root path\n   * @param filename - The name of the file to read\n   * @param isJson - Whether the file contains JSON data\n   * @returns The file data\n   */\n  async readCursorCrawlFile<T>(\n    rootPath: string,\n    filename: string,\n    isJson: boolean = true\n  ): Promise<T> {\n    const filePath = path.join(rootPath, CURSOR_TEST_DIR, filename);\n    \n    if (!await fs.pathExists(filePath)) {\n      throw new Error(`File not found: ${filePath}`);\n    }\n    \n    if (isJson) {\n      return await fs.readJson(filePath);\n    } else {\n      return await fs.readFile(filePath, 'utf8') as unknown as T;\n    }\n  },\n\n  /**\n   * Checks if a file exists in the .cursorcrawl directory\n   * @param rootPath - The workspace root path\n   * @param filename - The name of the file to check\n   * @returns Whether the file exists\n   */\n  async cursorCrawlFileExists(\n    rootPath: string,\n    filename: string\n  ): Promise<boolean> {\n    const filePath = path.join(rootPath, CURSOR_TEST_DIR, filename);\n    return fs.pathExists(filePath);\n  }\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "workspaceFolders",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 17,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "workspaceFolders = vscode.workspace.workspaceFolders",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 18,
          "contextSnippet": "   */\n  getWorkspaceFolder(): string | undefined {\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders || workspaceFolders.length === 0) {\n      return undefined;\n    }\n    return workspaceFolders[0].uri.fsPath;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "workspaceFolder",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 30,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "workspaceFolder = this.getWorkspaceFolder()",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 31,
          "contextSnippet": "   */\n  getWorkspaceFolderOrThrow(): string {\n    const workspaceFolder = this.getWorkspaceFolder();\n    if (!workspaceFolder) {\n      throw new Error('No workspace folder open');\n    }\n    return workspaceFolder;"
        }
      ],
      "depends_on": []
    },
    {
      "name": "cursorCrawlDir",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 43,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "cursorCrawlDir = path.join(rootPath, CURSOR_TEST_DIR)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 44,
          "contextSnippet": "   */\n  async ensureCursorCrawlDir(rootPath: string): Promise<string> {\n    const cursorCrawlDir = path.join(rootPath, CURSOR_TEST_DIR);\n    await fs.ensureDir(cursorCrawlDir);\n    return cursorCrawlDir;\n  },\n"
        }
      ],
      "depends_on": []
    },
    {
      "name": "cursorCrawlDir",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 69,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "cursorCrawlDir = await this.ensureCursorCrawlDir(rootPath)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 70,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filePath = path.join(cursorCrawlDir, filename)",
      "dependents": [
        {
          "name": "__file__",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 73,
          "contextSnippet": "    const filePath = path.join(cursorCrawlDir, filename);\n    \n    if (typeof data === 'string') {\n      await fs.writeFile(filePath, data, 'utf8');\n    } else {\n      await fs.writeJson(filePath, data, { spaces: 2 });\n    }"
        }
      ],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 93,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filePath = path.join(rootPath, CURSOR_TEST_DIR, filename)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "filePath",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 116,
        "character": 10
      },
      "docstring": "/** */",
      "snippet": "filePath = path.join(rootPath, CURSOR_TEST_DIR, filename)",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "showInformationMessage",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 125,
        "character": 13
      },
      "docstring": "/**\n * Shows an information message in VS Code\n * @param message - The message to show\n */",
      "snippet": "showInformationMessage = (message: string): void => {\n  vscode.window.showInformationMessage(message);\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "showErrorMessage",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 134,
        "character": 13
      },
      "docstring": "/**\n * Shows an error message in VS Code\n * @param message - The message to show\n * @param error - The error object\n */",
      "snippet": "showErrorMessage = (message: string, error?: any): void => {\n  const errorMessage = error instanceof Error ? error.message : String(error || '');\n  vscode.window.showErrorMessage(`${message}${errorMessage ? `: ${errorMessage}` : ''}`);\n}",
      "dependents": [],
      "depends_on": [
        {
          "name": "errorMessage",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 136
        }
      ]
    },
    {
      "name": "errorMessage",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 135,
        "character": 8
      },
      "docstring": "/** */",
      "snippet": "errorMessage = error instanceof Error ? error.message : String(error || '')",
      "dependents": [
        {
          "name": "showErrorMessage",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 136,
          "contextSnippet": " */\nexport const showErrorMessage = (message: string, error?: any): void => {\n  const errorMessage = error instanceof Error ? error.message : String(error || '');\n  vscode.window.showErrorMessage(`${message}${errorMessage ? `: ${errorMessage}` : ''}`);\n};\n\n/**"
        }
      ],
      "depends_on": []
    },
    {
      "name": "showWarningMessage",
      "type": "variable",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 143,
        "character": 13
      },
      "docstring": "/**\n * Shows a warning message in VS Code\n * @param message - The message to show\n */",
      "snippet": "showWarningMessage = (message: string): void => {\n  vscode.window.showWarningMessage(message);\n}",
      "dependents": [],
      "depends_on": []
    },
    {
      "name": "__file__",
      "type": "other",
      "filePath": "src/shared/services/workspace-service.ts",
      "location": {
        "line": 1,
        "character": 0
      },
      "docstring": "/** File-level symbol */",
      "snippet": "",
      "dependents": [],
      "depends_on": [
        {
          "name": "workspaceFolders",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 18
        },
        {
          "name": "workspaceFolder",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 31
        },
        {
          "name": "CURSOR_TEST_DIR",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 43
        },
        {
          "name": "cursorCrawlDir",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 44
        },
        {
          "name": "filePath",
          "filePath": "src/shared/services/workspace-service.ts",
          "line": 73
        }
      ]
    }
  ]
}
